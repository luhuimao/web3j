{"version":3,"file":"index.esm.js","sources":["../src/bvm-addr.js","../src/bvm-acct.js","../src/timing.js","../src/buffer-cntl.js","../src/integer-array-encoding.js","../src/tx-dapp.js","../src/rpc-parameter.js","../src/rpc-call.js","../src/dormant.js","../src/netutility.js","../src/launch-then-acknowledge-tx.js","../src/sys-dapp.js","../src/dapp-mounter.js","../src/bvm-dapp-mounter.js","../src/js.js","../src/preconditions.js","../src/bvm-script.js","../src/builtin-mounter.js","../src/asset-dapp.js","../src/launch-then-acknowledge-original-tx.js","../src/index.js"],"sourcesContent":["// @flow\n\nconst request = require(\"request\");\n\n\nconst AbiCoder = require('web3-eth-abi');\n// const abiCoder = new AbiCoder.AbiCoder();\n\nconst Web3 = require('web3');\nconst Promise = require(\"bluebird\");\nconst truffle_Contract = require('truffle-contract');\nconst assert = require('assert');\n// const tracer = require('./EVM2Code');\nconst fs = require('fs');\nconst locks = require('locks');\n// mutex\nconst mutex = locks.createMutex();\nconst async = require('async');\nlet httpRpcAddr = \"http://localhost:8546\"\nlet Provider = new Web3.providers.HttpProvider(httpRpcAddr);\nlet web3  =  new Web3(new Web3.providers.HttpProvider(httpRpcAddr));\nlet g_account_list = web3.eth.accounts;\nlet g_from_account = g_account_list[0];\n  /// unlock initial user, which is also miner account\n// web3.personal.unlockAccount(g_from_account, \"123\", 200 * 60 * 60);\n\nimport BN from 'bn.js';\nimport bs58 from 'bs58';\n\nasync function get_instance(artifact_path){\n  let artifact = require(artifact_path);\n  let network_id = Object.keys(artifact[\"networks\"])[0];\n  let conf = {\n    contract_name:artifact[\"contractName\"],\n    abi:  artifact[\"abi\"],                     // Array; required.  Application binary interface.\n    unlinked_binary: artifact[\"bytecode\"],       // String; optional. Binary without resolve library links.\n    address: artifact[\"networks\"][network_id][\"address\"],               // String; optional. Deployed address of contract.\n    network_id: parseInt(network_id),            // String; optional. ID of network being saved within abstraction.\n    default_network: parseInt(network_id)       // String; optional. ID of default network this abstraction should use.\n  };\n  // console.log(conf);\n  let MyContract = truffle_Contract(conf);\n  MyContract.setProvider(Provider);\n  let instance = await MyContract.deployed();\n  return instance;\n}\nasync function send(){\n  let private_bank = await get_instance(\"../build/contracts/Private_Bank.json\");\n  await web3.eth.sendTransaction({from:g_from_account,to:private_bank.address,value:10000000000000000000,gas:500000000000});\n}\nasync function test(){\n  let private_bank = await get_instance(\"../build/contracts/Private_Bank.json\");\n  let attack_private_bank = await get_instance(\"../build/contracts/Attack_Private_Bank0.json\");\n  let bal_private = await web3.eth.getBalance(private_bank.address);\n  let bal_attack_private = await web3.eth.getBalance(attack_private_bank.address);\n  console.log(\"Before\");\n  console.log(\"ether of contract:\",bal_private.toString(),bal_attack_private.toString());\n  let book_val = await private_bank.balances(attack_private_bank.address,{from:g_from_account,gas:500000000000});\n  console.log(\"book of contract:\",book_val.toString())\n  await attack_private_bank.vultron_Deposit(10000000000000000000,{from:g_from_account,gas:500000000000});\n \n  book_val = await private_bank.balances(attack_private_bank.address,{from:g_from_account,gas:500000000000});\n  console.log(\"Middle\");\n  console.log(\"book of contract:\",book_val.toString())\n  bal_private = await web3.eth.getBalance(private_bank.address);\n  bal_attack_private = await web3.eth.getBalance(attack_private_bank.address);\n  console.log(\"ether of contract:\",bal_private.toString(),bal_attack_private.toString());\n\n\n  await attack_private_bank.vultron_CashOut(10000000000000000000,{from:g_from_account,gas:50000000000000});\n\n  console.log(\"After\");\n  book_val = await private_bank.balances(attack_private_bank.address,{from:g_from_account,gas:500000000000});\n  console.log(book_val.toString())\n  bal_private = await web3.eth.getBalance(private_bank.address);\n  bal_attack_private = await web3.eth.getBalance(attack_private_bank.address);\n  console.log(\"ether of contract:\",bal_private.toString(),bal_attack_private.toString());\n  book_val = await private_bank.balances(attack_private_bank.address,{from:g_from_account,gas:500000000000});\n  console.log(\"book of contract:\",book_val.toString())\n    \n}\n\n\nfunction setCharAt(str,index,chr) {\n  if(index > str.length-1) return str;\n  return str.substr(0,index) + chr + str.substr(index+1);\n}\n\nfunction transform(id) {\n  var newStr = id;\n  if (typeof id === 'string') {\n      for (var i = 0; i < newStr.length; i++) {\n          // console.log(newStr.charAt(i));\n          \n          if (newStr.charAt(i) === '0') {\n              newStr = setCharAt(newStr, i, 'X2');\n          }\n          else if (newStr.charAt(i) === 'O') {\n              newStr = setCharAt(newStr, i, 'X1');\n          }\n          else if (newStr.charAt(i) === 'I') {\n              newStr = setCharAt(newStr, i, 'X3');\n          }\n          else if (newStr.charAt(i) === 'l') {\n              newStr = setCharAt(newStr, i, 'X4');\n          }\n      }\n  } else {\n      throw new Error(`can't transform a not string type value`);\n  }\n  return newStr;\n}\n\nfunction reverse(id) {\n  var originalStr = id;\n  if (typeof id === 'string') {\n      for (var i = 0; i < originalStr.length; i++) {\n          if (originalStr.includes(\"X2\")) {\n              originalStr = originalStr.replace(/X2/g, \"0\");\n          }\n          else if (originalStr.includes(\"X1\")) {\n              originalStr = originalStr.replace(/X1/g, \"O\");\n          }\n          else if (originalStr.includes(\"X3\")) {\n              originalStr = originalStr.replace(/X3/g, \"I\");\n          }\n          else if (originalStr.includes(\"X4\")) {\n              originalStr = originalStr.replace(/X4/g, \"l\");\n          }\n      }\n  } else {\n      throw new Error(`can't transform a not string type value`);\n  }\n  return originalStr;\n}\n\n/**\n * A bvm address\n */\nexport class BvmAddr {\n  _bn: BN;\n\n  /**\n   * Create a new BvmAddr object\n   */\n  constructor(value: number | string | Buffer | Array<number>) {\n    if (typeof value === 'string') {\n      // hexadecimal number\n      if (value.startsWith('0x')) {\n        this._bn = new BN(value.substring(2), 16);\n      } else {\n        // assume base 58 encoding by default\n        var newstr = transform(value);\n        this._bn = new BN(bs58.decode(newstr));\n      }\n    } else {\n      this._bn = new BN(value);\n    }\n\n    if (this._bn.byteLength() > 32) {\n      throw new Error(`Invalid bvm address input`);\n    }\n  }\n\n  /**\n   * Checks if the provided object is a BvmAddr\n   */\n  static isBvmAddr(o: Object): boolean {\n    return o instanceof BvmAddr;\n  }\n\n  /**\n   * Checks if two bvm addresses are equal\n   */\n  checkIfEquals(bvmaddr: BvmAddr): boolean {\n    return this._bn.eq(bvmaddr._bn);\n  }\n\n  /**\n   * Return the base-58 representation of the bvm address\n   */\n  converseToBase58(): string {\n    return bs58.encode(this.converseToBuffer());\n  }\n\n  /**\n   * Return the Buffer representation of the bvm address\n   */\n  converseToBuffer(): Buffer {\n    const bign = this._bn.toArrayLike(Buffer);\n    if (bign.length === 32) {\n      return bign;\n    }\n\n    const zeroPad = Buffer.alloc(32);\n    bign.copy(zeroPad, 32 - bign.length);\n    return zeroPad;\n  }\n\n  /**\n   * Returns a string representation of the bvm address\n   */\n  converseToString(): string {\n    return reverse(this.converseToBase58());\n    // return this.converseToBase58();\n  }\n}\n\n\n// web3 abstractions\n// var web3;\nvar target_con;\nvar attack_con;\nvar account_list;\nvar bookKeepingAbi;\n\n// tracer abstractions at instruction level\nvar targetIns_map;\nvar attackIns_map;\n\n// static dependency\nvar staticDep_target;\nvar staticDep_attack;\n\n/// the gas amount\nconst gasMin = 25000;\nconst gasMax = 8000000000;\n/// dynamci array\nconst dyn_array_min = 1;\nconst dyn_array_max = 10;\n\n/// the maximum length of seed_callSequence\nconst sequence_maxLen = 4;\n/// the maximum number of muated call sequences \nconst mutateSeque_maxLen = 4;\n/// the maximum number of muated operation for each call sequence\nconst mutateOper_maxLen = 3;\n/// the maximum length of changed call sequence\nconst operSeque_maxLen = 3;\n\n/// the set to keep the coverage for guided fuzzing\nvar stmt_trace = [];\nvar seque_stmt_trace = [];\nvar trans_depen_set = new Set();\nvar seque_depen_set = new Set();\nvar contr_depen_set = new Set();\n","// @flow\n\n    // static getPayload(cursor) {\n    //   const argType = cursor.read32();\n    //   if (argType === transaction_pb_1.TransactionArgument.ArgType.U64) {\n    //       const data = cursor.read64();\n    //       return TransactionArgumentLCS_1.TransactionArgumentLCS.fromU64(data.toString());\n    //   }\n    //   else if (argType === transaction_pb_1.TransactionArgument.ArgType.ADDRESS) {\n    //       const data = this.getAddress(cursor);\n    //       return TransactionArgumentLCS_1.TransactionArgumentLCS.fromAddress(data);\n    //   }\n    //   else if (argType === transaction_pb_1.TransactionArgument.ArgType.STRING) {\n    //       const data = this.getString(cursor);\n    //       return TransactionArgumentLCS_1.TransactionArgumentLCS.fromString(data);\n    //   }\n    //   else if (argType === transaction_pb_1.TransactionArgument.ArgType.BYTEARRAY) {\n    //       const data = this.getByteArray(cursor);\n    //       return TransactionArgumentLCS_1.TransactionArgumentLCS.fromByteArray(data);\n    //   }\n    //   return new TransactionArgumentLCS_1.TransactionArgumentLCS();\n    // }\n\nimport nacl from 'tweetnacl';\nimport type {KeyPair} from 'tweetnacl';\n\nimport {BvmAddr} from './bvm-addr';\n\nclass CursorBuffer {\n    constructor(typedArray, littleEndian = true) {\n        this.dataView = new DataView(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n        this.littleEndian = littleEndian;\n        this.bytePositon = 0;\n    }\n    /**\n     * Reads 1 byte\n     *\n     */\n    read8() {\n        const value = this.dataView.getUint8(this.bytePositon);\n        this.bytePositon += 1;\n        return value;\n    }\n    /**\n     * Reads 4 bytes\n     *\n     */\n    read32() {\n        const value = this.dataView.getUint32(this.bytePositon, this.littleEndian);\n        this.bytePositon += 4;\n        return value;\n    }\n    /**\n     * Reads 8 bytes\n     *\n     *\n     */\n    // read64() {\n    //     const firstPart = this.read32();\n    //     const secondPart = this.read32();\n    //     const combined = this.littleEndian\n    //         ? secondPart.toString(16) + firstPart.toString(16).padStart(8, '0')\n    //         : firstPart.toString(16) + secondPart.toString(16).padStart(8, '0');\n    //     return new bignumber_js_1.default(`0x${combined}`, 16);\n    // }\n    readXBytes(x) {\n        // console.log(this.bytePositon, this.dataView.byteOffset);\n        // this.bytePositon -= 8;\n\n        const startPosition = this.bytePositon + this.dataView.byteOffset; // original = 27\n        console.log(startPosition);\n        const value = new Uint8Array(this.dataView.buffer, startPosition, x);\n        this.bytePositon += x;\n        return value;\n\n        // + 8 // receiver | 19 // sender (when not skipping bytes with .read32 before signedTxn)\n\n        // const startPosition = this.bytePositon + this.dataView.byteOffset + 8; // receiver = 35\n        // const value = new Uint8Array(this.dataView.buffer, startPosition, x);\n        // this.bytePositon += x;\n        // return value;\n\n        // const value = new Uint8Array(this.dataView.buffer, 19, x); // sender\n        // return value;\n    }\n    readXXBytes(x) {\n      this.bytePositon += 4;\n      \n      const value = new Uint8Array(this.dataView.buffer, 271, x);\n      return value;\n    }\n    /**\n     * Read bool as 1 byte\n     *\n     */\n    readBool() {\n        const value = this.dataView.getUint8(this.bytePositon);\n        this.bytePositon += 1;\n        if (value !== 0 && value !== 1) {\n            throw new Error(`bool must be 0 or 1, found ${value}`);\n        }\n        return value !== 0;\n    }\n}\n\n/**\n * An account key pair (public and secret keys).\n */\nexport class BvmAcct {\n  _keypair: KeyPair;\n\n  /**\n   * Create a new BvmAcct object\n   *\n   * If the privateKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param privateKey Secret key for the account\n   */\n  constructor(privateKey: ?Buffer = null) {\n    if (privateKey) {\n      this._keypair = nacl.sign.keyPair.fromSecretKey(privateKey);\n    } else {\n      this._keypair = nacl.sign.keyPair();\n    }\n  }\n\n  /**\n   * The bvm address for this account\n   */\n  get pubKey(): BvmAddr {\n    return new BvmAddr(this._keypair.publicKey);\n  }\n\n  /**\n   * The **unencrypted** secret key for this account\n   */\n  get privateKey(): Buffer {\n    return this._keypair.secretKey;\n  }\n}\n\n\n\n// static getRawTransaction(cursor) {\n    //     const sender = this.getAddress(cursor);\n    //     const sequence = cursor.read64();\n    //     const payload = this.getTransactionPayload(cursor);\n    //     const maxGasAmount = cursor.read64();\n    //     const gasUnitPrice = cursor.read64();\n    //     const expiryTime = cursor.read64();\n    //     const transaction = new RawTransactionLCS_1.RawTransactionLCS(sender.value, sequence.toString(), payload);\n    //     transaction.maxGasAmount = maxGasAmount;\n    //     transaction.gasUnitPrice = gasUnitPrice;\n    //     transaction.expirtationTime = expiryTime;\n    //     return transaction;\n    // }\n\n\n\n    \n\n    // static getRawTransaction(cursor) {\n    //   const sender = this.getAddress(cursor);\n    //   const sequence = cursor.read64();\n    //   // const payload = this.getTransactionPayload(cursor);\n    //   const maxGasAmount = cursor.read64();\n    //   const gasUnitPrice = new BigNumber.default(cursor.read64());\n    //   const expiryTime = new BigNumber.default(cursor.read64());\n    //   // const transaction = new RawTransactionLCS_1.RawTransactionLCS(sender.value, sequence.toString(), payload);\n    //   // transaction.maxGasAmount = maxGasAmount;\n    //   // transaction.gasUnitPrice = gasUnitPrice;\n    //   // transaction.expirtationTime = expiryTime;\n    //   return ({sender:sender, sequence:sequence, maxGasAmount:maxGasAmount, gasUnitPrice:gasUnitPrice, expiryTime:expiryTime});\n    // }\n\n\n    import * as fs from 'fs'\nimport * as path from 'path'\n\ntype PackageJson = {\n  name: string,\n  version?: string,\n  description?: string,\n  main?: string,\n  scripts?: { [string]: string },\n  dependencies?: { [string]: string },\n  devDependencies?: { [string]: string }\n}\n\nexport async function findNearestPackageJson(\n  directoryPath: string = path.resolve()\n): Promise<{ path: string, data: PackageJson }> {\n  try {\n    const packageJsonPath = path.join(directoryPath, 'package.json')\n    const packageJsonData = JSON.parse(await readFile(packageJsonPath))\n    return {\n      path: packageJsonPath,\n      data: packageJsonData\n    }\n  } catch (error) {\n    const parentDirectoryPath = path.dirname(directoryPath)\n    if (parentDirectoryPath === directoryPath) {\n      throw new Error('No package.json files found')\n    }\n    return findNearestPackageJson(parentDirectoryPath)\n  }\n}\n\nfunction readFile(filePath: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    fs.readFile(filePath, 'utf8', (error, result) => {\n      if (error) reject(error)\n      else resolve(result)\n    })\n  })\n}\n\nexport function findNearestPackageJsonSync(\n  directoryPath: string = path.resolve()\n): { path: string, data: PackageJson } {\n  try {\n    const packageJsonPath = path.join(directoryPath, 'package.json')\n    const packageJsonData = JSON.parse(readFileSync(packageJsonPath))\n    return {\n      path: packageJsonPath,\n      data: packageJsonData\n    }\n  } catch (error) {\n    const parentDirectoryPath = path.dirname(directoryPath)\n    if (parentDirectoryPath === directoryPath) {\n      throw new Error('No package.json files found')\n    }\n    return findNearestPackageJsonSync(parentDirectoryPath)\n  }\n}\n\nfunction readFileSync(filePath: string): string {\n  return fs.readFileSync(filePath, 'utf8')\n}\n\n\nclass StatusCode {\n    static getStatusMessage(status) {\n        let message = '';\n        switch (status) {\n            case this.Success:\n                message = 'success';\n                break;\n            case this.Unknown:\n                message = 'unknown';\n                break;\n            case this.BadRLP:\n                message = 'bad RLP';\n                break;\n            case this.InvalidFormat:\n                message = 'invalid format';\n                break;\n            case this.OutOfGasIntrinsic:\n                message = 'out of gas intrinsic';\n                break;\n            case this.InvalidSignature:\n                message = 'invalid signature';\n                break;\n            case this.InvalidNonce:\n                message = 'invalid nonce';\n                break;\n            case this.NotEnoughCash:\n                message = 'not enough cash';\n                break;\n            case this.OutOfGasBase:\n                message = 'out of gas base';\n                break;\n            case this.BlockGasLimitReached:\n                message = 'block gas limit reached';\n                break;\n            case this.BadInstruction:\n                message = 'bad instruction';\n                break;\n            case this.BadJumpDestination:\n                message = 'bad jump destination';\n                break;\n            case this.OutOfGas:\n                message = 'out of gas';\n                break;\n            case this.OutOfStack:\n                message = 'out of stack';\n                break;\n            case this.StackUnderflow:\n                message = 'stack underflow';\n                break;\n            case this.NonceCheckFail:\n                message = 'nonce check fail';\n                break;\n            case this.BlockLimitCheckFail:\n                message = 'block limit check fail';\n                break;\n            case this.FilterCheckFail:\n                message = 'filter check fail';\n                break;\n            case this.NoDeployPermission:\n                message = 'no deploy permission';\n                break;\n            case this.NoCallPermission:\n                message = 'no call permission';\n                break;\n            case this.NoTxPermission:\n                message = 'no tx permission';\n                break;\n            case this.PrecompiledError:\n                message = 'precompiled error';\n                break;\n            case this.RevertInstruction:\n                message = 'revert instruction';\n                break;\n            case this.InvalidZeroSignatureFormat:\n                message = 'invalid zero signature format';\n                break;\n            case this.AddressAlreadyUsed:\n                message = 'address already used';\n                break;\n            case this.PermissionDenied:\n                message = 'permission denied';\n                break;\n            case this.CallAddressError:\n                message = 'call address error';\n                break;\n            default:\n                message = `unknown status code:${status}`;\n                break;\n        }\n\n        return message;\n    }\n}\n\nStatusCode.Success = '0x0';\nStatusCode.Unknown = '0x1';\nStatusCode.BadRLP = '0x2';\nStatusCode.InvalidFormat = '0x3';\nStatusCode.OutOfGasIntrinsic = '0x4';\nStatusCode.InvalidSignature = '0x5';\nStatusCode.InvalidNonce = '0x6';\nStatusCode.NotEnoughCash = '0x7';\nStatusCode.OutOfGasBase = '0x8';\nStatusCode.BlockGasLimitReached = '0x9';\nStatusCode.BadInstruction = '0xa';\nStatusCode.BadJumpDestination = '0xb';\nStatusCode.OutOfGas = '0xc';\nStatusCode.OutOfStack = '0xd';\nStatusCode.StackUnderflow = '0xe';\nStatusCode.NonceCheckFail = '0xf';\nStatusCode.BlockLimitCheckFail = '0x10';\nStatusCode.FilterCheckFail = '0x11';\nStatusCode.NoDeployPermission = '0x12';\nStatusCode.NoCallPermission = '0x13';\nStatusCode.NoTxPermission = '0x14';\nStatusCode.PrecompiledError = '0x15';\nStatusCode.RevertInstruction = '0x16';\nStatusCode.InvalidZeroSignatureFormat = '0x17';\nStatusCode.AddressAlreadyUsed = '0x18';\nStatusCode.PermissionDenied = '0x19';\nStatusCode.CallAddressError = '0x1a';","// @flow\n\n\n\n/// conver scientific number to string\nfunction uintToString(num){\n  var num_str = \"\" + num;\n  /// scientific number\n  var index = num_str.indexOf(\"+\");\n  if(index != -1){\n    var result = num_str[0];\n    var power_len = parseInt(num_str.slice(index +1), 10);\n    var power_index = 0;\n    while(power_index < power_len){\n      /// num_str[index-1:] is 'e+...'\n      if((power_index +2) < (index -1)){\n        result += num_str[power_index +2];\n      }\n      else{\n        result += '0';\n      }\n      power_index += 1;\n    }\n    return result;\n  }\n  else{\n    return num_str;\n  }\n}\n\n/// generate an unsigned integer\n/// unum_min is defined, in most case it is 0\n/// unum_max may not be defined, e.g., undefined\nfunction gen_uint(uint_type, unum_min, unum_max){\n  /// get rid of uint in e.g., 'uint256'\n  var num_left = 4;\n  /// maybe it is an array, e,g., 'uint256[]'\n  var num_right = uint_type.indexOf('[');\n  if(num_right == -1){\n    /// it is primitive unit, not an array\n    num_right = uint_type.length;\n  } \n  /// the number of bytes\n  var byte_num = parseInt(uint_type.slice(num_left, num_right), 10) / 8;\n  var byte_index = 0;\n  var num_str = '0x';\n  while(byte_index < byte_num){\n    num_str += 'ff';\n    byte_index += 1;\n  }\n  if(unum_max === undefined){\n    /// unum_max is undefined, we use the default maximum value\n    unum_max = parseInt(num_str, 16); \n  }\n  else{\n    var num_max = parseInt(num_str, 16);\n    if(num_max < unum_max){\n      unum_max = num_max;\n    }\n  }\n  if(uint_type.indexOf('[') == -1){\n    /// primitive type\n    var value_int = randomNum(unum_min, unum_max);\n    var value = uintToString(value_int);\n    return value;\n  }\n  else if(adds_type.indexOf('[]') != -1){\n    /// dynamic array\n    var value_list = [];\n    var value_num = randomNum(dyn_array_min, dyn_array_max);\n    var value_index = 0;\n    while(value_index < value_num){\n      var value_int = randomNum(unum_min, unum_max);\n      var value = uintToString(value_int);;      \n      value_list.push(value);\n      value_index += 1;\n    }\n    return value_list;\n  }\n  else{\n    /// static array\n    var value_list = [];\n    var left_index = uint_type.indexOf('[');\n    var right_index = uint_type.indexOf(']');\n    var value_num = parseInt(uint_type.slice(left_index +1, right_index), 10);\n    var value_index = 0;\n    while(value_index < value_num){\n      var value_int = randomNum(unum_min, unum_max);\n      var value = uintToString(value_int);\n      value_list.push(value);\n      value_index += 1;\n    }\n    return value_list;\n  }\n}\n\n/**\n * @ignore\n */\nexport const NUM_TICKS_PER_SEC = 10;\n\n// tracer abstractions at instruction level\nvar targetIns_map;\nvar attackIns_map;\n\n// static dependency\nvar staticDep_target;\nvar staticDep_attack;\n\n/// the gas amount\nconst gasMin = 25000;\nconst gasMax = 8000000000;\n/// dynamci array\nconst dyn_array_min = 1;\nconst dyn_array_max = 10;\n\n/**\n * @ignore\n */\nexport const DEFAULT_TICKS_PER_SLOT = 8;\n\n\n\n\n/// the maximum length of seed_callSequence\nconst sequence_maxLen = 4;\n/// the maximum number of muated call sequences \nconst mutateSeque_maxLen = 4;\n/// the maximum number of muated operation for each call sequence\nconst mutateOper_maxLen = 3;\n/// the maximum length of changed call sequence\nconst operSeque_maxLen = 3;\n\n/// the set to keep the coverage for guided fuzzing\nvar stmt_trace = [];\nvar seque_stmt_trace = [];\nvar trans_depen_set = new Set();\nvar seque_depen_set = new Set();\nvar contr_depen_set = new Set();\n\n/// the last call\nvar lastCall = new Map();\n/// the call function list for the execution\nvar sequence_call_list = [];\n/// the executed call sequence\nvar sequence_executed = [];\n/// the index in sequence_executed\nvar sequeExe_index = 0;\n/// the sequence_exexuted become more meaningful\nvar sequeExe_meaningful = false;\n/// the execution results of a call function\nvar exec_results = [];\n/// another new call seqeunce\nvar new_sequence_start = false;\n\n/// the hash of previous transaction\nvar pre_txHash = \"0x0\";\nvar startTime, endTime;\nvar timeDiff;\n\n/// the candidate abi that can be used to start transaction\nvar cand_sequence = [];\n\nvar reset_num = 0;\nvar reset_index = 0;\n\nvar fuzzing_finish = false;","// @flow\n\n\n/// the last call\nvar lastCall = new Map();\n/// the call function list for the execution\nvar sequence_call_list = [];\n/// the executed call sequence\nvar sequence_executed = [];\n/// the index in sequence_executed\nvar sequeExe_index = 0;\n/// the sequence_exexuted become more meaningful\nvar sequeExe_meaningful = false;\n/// the execution results of a call function\nvar exec_results = [];\n/// another new call seqeunce\nvar new_sequence_start = false;\n\n/// the hash of previous transaction\nvar pre_txHash = \"0x0\";\nvar startTime, endTime;\nvar timeDiff;\n\n/// the candidate abi that can be used to start transaction\nvar cand_sequence = [];\n\nvar reset_num = 0;\nvar reset_index = 0;\n\nvar fuzzing_finish = false;\n\nimport * as BufferLayout from 'buffer-layout';\n\n/// the mutation for gas neighbor\nvar gas_neighbor = [];\ngas_neighbor.push('0.01');\ngas_neighbor.push('0.1');\ngas_neighbor.push('0.2');\ngas_neighbor.push('0.3');\ngas_neighbor.push('0.5');\ngas_neighbor.push('0.8');\ngas_neighbor.push('0.9');\ngas_neighbor.push('0.92');\ngas_neighbor.push('0.93');\ngas_neighbor.push('0.95');\ngas_neighbor.push('0.96');\ngas_neighbor.push('0.97');\ngas_neighbor.push('0.98');\ngas_neighbor.push('0.99');\ngas_neighbor.push('1.01');\ngas_neighbor.push('1.02');\ngas_neighbor.push('1.03');\ngas_neighbor.push('1.0');\ngas_neighbor.push('1.05');\ngas_neighbor.push('1.06');\ngas_neighbor.push('1.08');\ngas_neighbor.push('1.1');\ngas_neighbor.push('1.2');\ngas_neighbor.push('1.5');\ngas_neighbor.push('1.7');\ngas_neighbor.push('2.0');\ngas_neighbor.push('3.0');\ngas_neighbor.push('5.0');\ngas_neighbor.push('10.0');\ngas_neighbor.push('50.0');\ngas_neighbor.push('80.0');\ngas_neighbor.push('100.0');\ngas_neighbor.push('1000.0');\n\n/**\n * Layout for a bvm address\n */\nexport const pubKey = (property: string = 'pubKey'): Object => {\n  return BufferLayout.blob(32, property);\n};\n\n/// the mutation operation for uint neighbor\nvar uint_neighbor = [];\nuint_neighbor.push('1.05');\nuint_neighbor.push('0.95');\nuint_neighbor.push('1.1');\nuint_neighbor.push('0.9');\nuint_neighbor.push('1.15');\nuint_neighbor.push('0.85');  \nuint_neighbor.push('1.2');\nuint_neighbor.push('0.8');\nuint_neighbor.push('1.5');\nuint_neighbor.push('0.5');\nuint_neighbor.push('2.0');\nuint_neighbor.push('0.02');  \nuint_neighbor.push('3.0');\nuint_neighbor.push('0.015'); \nuint_neighbor.push('4.0');\nuint_neighbor.push('0.01'); \nuint_neighbor.push('5.0');\nuint_neighbor.push('0.001'); \nuint_neighbor.push('0.0001')\nuint_neighbor.push(1);\nuint_neighbor.push(-1);\nuint_neighbor.push(2);\nuint_neighbor.push(-2);\nuint_neighbor.push(4);\nuint_neighbor.push(-4);\nuint_neighbor.push(8);\nuint_neighbor.push(-8);\n\n/**\n * Layout for a 64bit unsigned value\n */\nexport const uint64 = (property: string = 'uint64'): Object => {\n  return BufferLayout.blob(8, property);\n};\n\n/**\n * Layout for a Rust String type\n */\nexport const rustString = (property: string = 'string') => {\n  const rsl = BufferLayout.struct(\n    [\n      BufferLayout.u32('length'),\n      BufferLayout.u32('lengthPadding'),\n      BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), 'chars'),\n    ],\n    property,\n  );\n  const _decode = rsl.decode.bind(rsl);\n  const _encode = rsl.encode.bind(rsl);\n\n  rsl.decode = (buffer, offset) => {\n    const data = _decode(buffer, offset);\n    return data.chars.toString('utf8');\n  };\n\n  rsl.encode = (str, buffer, offset) => {\n    const data = {\n      chars: Buffer.from(str, 'utf8'),\n    };\n    return _encode(data, buffer, offset);\n  };\n\n  return rsl;\n};\n\n\nasync function reset() {\n  if (target_con === undefined) {\n    throw \"Target contract is not loaded!\";\n  }\n  if (attack_con === undefined) {\n    throw \"Attack contract is not loaded!\";\n  }\n  // await resetBookKeeping();\n  await redeploy();\n  return \"Contracts are reset!\";\n}\n\n\n/// find the bookkeeping variable\nasync function findBookKeepingAbi(abis) {\n  for (var abi of abis) {\n    if (abi.type === 'function' && abi.constant &&\n        abi.inputs.length === 1 && abi.inputs[0].type === 'address' &&\n        abi.outputs.length === 1 && abi.outputs[0].type === 'uint256') {\n      return abi;\n    }\n  }\n  throw \"Cannot find bookkeeping variable!\";\n  return;\n}\n\n\nasync function findCandSequence(target_abis, attack_abis){\n  var target_switch = true;\n  var attack_switch = true;\n\n  if(target_switch){\n    await target_abis.forEach(function(abi) {\n      /// if abi.constant is true, it would not change state variables\n      if (abi.type === 'function' && abi.constant == false){\n        var notsupport = false;\n        var input_len = abi.inputs.length;\n        var input_index = 0;\n        while(input_index < input_len){\n          var input = abi.inputs[input_index];\n          if(input.type.indexOf('address') !== 0 && input.type.indexOf('uint') !== 0){\n            notsupport = true;\n            break;\n          }\n          input_index += 1;\n        }\n        if(!notsupport){\n          cand_sequence.push(abi);\n        }\n      }\n    }); \n  }\n  if(attack_switch){\n    await attack_abis.forEach(function(abi) {\n      if (abi.type === 'function' && abi.constant == false){\n        var notsupport = false;\n        var input_len = abi.inputs.length;\n        var input_index = 0;\n        while(input_index < input_len){\n          var input = abi.inputs[input_index];\n          if(input.type.indexOf('address') !== 0 && input.type.indexOf('uint') !== 0){\n            notsupport = true;\n            break;\n          }\n          input_index += 1;\n        }\n        if(!notsupport){\n          cand_sequence.push(abi);\n        }\n      }\n    }); \n  }\n}","// @flow\n\n// var util = require('util');\n// var _ = require('underscore');\n// var clc = require('cli-color');\n// var moment = require('moment');\n// import  RpcClient from './rpc-client' ;\n// var logger = require('bunyan').createLogger({\n//     name: 'RpcClient',\n//     level: 'trace'\n// });\n\n// function inspect(obj) {\n//     return obj ? util.inspect(obj, {\n//         depth: null\n//     }) : '';\n// }\n\n// function printResult(error, result) {\n//     console.log(clc.red(inspect(error)));\n//     console.log(clc.cyan(inspect(result)));\n// }\n\n// function printJsonResult(error, result) {\n//     console.log(clc.red(inspect(error)));\n\n//     var output = result;\n//     try {\n//         output = JSON.parse(result);\n//     } catch (err) {\n//         // use default\n//     }\n\n//     console.log(clc.cyan(inspect(output)));\n// }\n\n// var context = 'OR CPRS GUI CHART';\n\n// var configuration = {\n//     context: 'HMP UI CONTEXT',\n//     host: 'IP        ',\n//     port: 2222,\n//     accessCode: 'REDACTED',\n//     verifyCode: 'REDACTED',\n//     localIP: 'IP      ',\n//     localAddress: 'localhost'\n// };\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst buffer_1 = require(\"buffer\");\nclass BufferUtil {\n    static fromHex(source) {\n        const data = source.match(/.{1,2}/g).map(x => parseInt(x, 16));\n        return new Uint8Array(data);\n    }\n    static fromBase64(source) {\n        return Uint8Array.from(buffer_1.Buffer.from(source, 'base64'));\n    }\n    static fromString(source) {\n        const buffer = new ArrayBuffer(source.length);\n        const view = new DataView(buffer);\n        for (let i = 0; i < source.length; i++) {\n            view.setUint8(i, source.charCodeAt(i));\n        }\n        return new Uint8Array(buffer);\n    }\n    static toString(source) {\n        const data = [];\n        source.forEach(x => {\n            data.push(String.fromCharCode(x));\n        });\n        return data.join('');\n    }\n    static toHex(sources) {\n        const data = [];\n        sources.forEach(x => {\n            data.push(x.toString(16).padStart(2, '0'));\n        });\n        return data.join('');\n    }\n    static toBase64(sources) {\n        return buffer_1.Buffer.from(sources).toString('base64');\n    }\n    static concat(a, b) {\n        const c = new Uint8Array(a.length + b.length);\n        c.set(a);\n        c.set(b, a.length);\n        return c;\n    }\n}\nexports.BufferUtil = BufferUtil;\n\n/*\ndecode an array of number and return it's length.\n */\nexport function getDecodedArrayLength(bytes: Array<number>): number {\n  let len_to_return = 0;\n  let size = 0;\n  for (;;) {\n    let elem_of_array = bytes.shift();\n    len_to_return |= (elem_of_array & 0x7f) << (size * 7);\n    size += 1;\n    if ((elem_of_array & 0x80) === 0) {\n      break;\n    }\n  }\n  return len_to_return;\n}\n/*\nencode an array of number. \n*/\nexport function encodeArrayWithInteger(bytes: Array<number>, len: number) {\n  let new_len = len;\n  for (;;) {\n    let new_elem = new_len & 0x7f;\n    new_len >>= 7;\n    if (new_len == 0) {\n      bytes.push(new_elem);\n      break;\n    } else {\n      new_elem |= 0x80;\n      bytes.push(new_elem);\n    }\n  }\n}\n\n\n// Object.defineProperty(exports, \"__esModule\", { value: true });\nexports.CollectionUtil = {\n    binarySearch(sortedArray, item) {\n        let lowIdx = 0;\n        let highIdx = sortedArray.length - 1;\n        while (lowIdx <= highIdx) {\n            const midIdx = Math.floor((lowIdx + highIdx) / 2);\n            if (sortedArray[midIdx] === item) {\n                return midIdx;\n            }\n            else if (sortedArray[midIdx] < item) {\n                lowIdx = midIdx + 1;\n            }\n            else {\n                highIdx = midIdx - 1;\n            }\n        }\n        return null;\n    },\n};\nexports.default = exports.CollectionUtil;\n\n\nclass CursorBuffer {\n    constructor(typedArray, littleEndian = true) {\n        this.dataView = new DataView(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n        this.littleEndian = littleEndian;\n        this.bytePositon = 0;\n    }\n    /**\n     * Reads 1 byte\n     *\n     */\n    read8() {\n        const value = this.dataView.getUint8(this.bytePositon);\n        this.bytePositon += 1;\n        return value;\n    }\n    /**\n     * Reads 4 bytes\n     *\n     */\n    read32() {\n        const value = this.dataView.getUint32(this.bytePositon, this.littleEndian);\n        this.bytePositon += 4;\n        return value;\n    }\n    /**\n     * Reads 8 bytes\n     *\n     *\n     */\n    read64() {\n        const firstPart = this.read32();\n        const secondPart = this.read32();\n        const combined = this.littleEndian\n            ? secondPart.toString(16) + firstPart.toString(16).padStart(8, '0')\n            : firstPart.toString(16) + secondPart.toString(16).padStart(8, '0');\n        return new bignumber_js_1.default(`0x${combined}`, 16);\n    }\n    readXBytes(x) {\n        // console.log(this.bytePositon, this.dataView.byteOffset);\n        // this.bytePositon -= 8;\n\n        const startPosition = this.bytePositon + this.dataView.byteOffset; // original = 27\n        console.log(startPosition);\n        const value = new Uint8Array(this.dataView.buffer, startPosition, x);\n        this.bytePositon += x;\n        return value;\n\n        // + 8 // receiver | 19 // sender (when not skipping bytes with .read32 before signedTxn)\n\n        // const startPosition = this.bytePositon + this.dataView.byteOffset + 8; // receiver = 35\n        // const value = new Uint8Array(this.dataView.buffer, startPosition, x);\n        // this.bytePositon += x;\n        // return value;\n\n        // const value = new Uint8Array(this.dataView.buffer, 19, x); // sender\n        // return value;\n    }\n    readXXBytes(x) {\n      this.bytePositon += 4;\n      \n      const value = new Uint8Array(this.dataView.buffer, 271, x);\n      return value;\n    }\n    /**\n     * Read bool as 1 byte\n     *\n     */\n    readBool() {\n        const value = this.dataView.getUint8(this.bytePositon);\n        this.bytePositon += 1;\n        if (value !== 0 && value !== 1) {\n            throw new Error(`bool must be 0 or 1, found ${value}`);\n        }\n        return value !== 0;\n    }\n}","// @flow\n\n/////////////////////////////////////////////////////////////////////////////////////////\nasync function mutate_callFun(call, callSequence, index) {\n  var sequence_new_list = [];\n  /// mutate the gas\n  var gas_sequence_list = await mutate_gas(call, callSequence, index);\n  for(var gas_sequence of gas_sequence_list){\n    sequence_new_list.push(gas_sequence);\n  }\n  /// mutate the input based on the balance\n  var bal_sequence_list = await mutate_balance(call, callSequence, index);\n  for(var bal_sequence of bal_sequence_list){\n    sequence_new_list.push(bal_sequence);\n  }\n  /// mutate the input based on the neighbor\n  var uint_sequence_list = await mutate_uint(call, callSequence, index);\n  for(var uint_sequence of uint_sequence_list){\n    sequence_new_list.push(uint_sequence);\n  }  \n  return sequence_new_list;\n}\n\n\nasync function mutate_callFun_uint_meaningful(call, callSequence, index) {\n  var unum_diff = '0.0000001';\n  /// unum_diff is not handled here, because it is relevant to multiple parameters\n  /// generate a new call function\n  var modify_result = await modify_callFun_uint_meaningful(call, unum_diff);\n  if(modify_result[0]){\n    /// callSequence itself is changed, not change at its copy \n    callSequence[index] = modify_result[1]; \n    return true;\n  }\n  else{\n    return false;\n  }\n}\n\nasync function mutate_callFun_gas_meaningful(call, callSequence, index) {\n  var gas_diff = '30.0';\n  var modify_result = await modify_callFun_gas_meaningful(call, gas_diff);\n  /// callSequence itself is changed, not change at its copy \n  if(modify_result[0]){\n    callSequence[index] = modify_result[1]; \n    return true;\n  }\n  else{\n    return false;\n  }\n}\n\nasync function mutate_callSequence(callSequence){\n  var callSequence_new_set = new Set();\n  var mutateSeque_index = 0;\n  while(mutateSeque_index < mutateSeque_maxLen){\n    /// copy the previous sequence, it would be modified\n    var callSequence_new = callSequence.slice();\n    var sequence_len = callSequence_new.length;\n    var mutateOper_index = 0;\n    while(mutateOper_index < mutateOper_maxLen){\n      /// the location to mutate\n      var sequence_index = randomNum(0, sequence_len);\n      /// the type of mutation, e.g., add, delete, and modify\n      var mutation_type = randomNum(0, 3);\n      if(mutation_type == 0){\n        /// add operation\n        var operSeque_num = randomNum(0, operSeque_maxLen);\n        var operSeque_index = 0;\n        while(operSeque_index < operSeque_num){\n          var abi_index = randomNum(0, cand_sequence.length);\n          var abi = cand_sequence[abi_index];\n          var callFun = await gen_callFun(abi);\n          /// add the element\n          callSequence_new.splice(sequence_index, 0, callFun);\n          operSeque_index += 1;\n        }\n      }\n      else if(mutation_type == 1){\n        /// delete operation\n        var operSeque_num = randomNum(0, operSeque_maxLen);\n        /// delete operSeque_num element\n        callSequence_new.splice(sequence_index, operSeque_num);     \n      }\n      else if(mutation_type == 2){\n        /// modify operation\n        var operSeque_num = randomNum(0, operSeque_maxLen);\n        var operSeque_index = 0;\n        while(operSeque_index < operSeque_num){\n          var abi_index = randomNum(0, cand_sequence.length);\n          var abi = cand_sequence[abi_index];\n          var callFun = await gen_callFun(abi);\n          /// replace the element\n          callSequence_new.splice(sequence_index + operSeque_index, 1, callFun);\n          operSeque_index += 1;\n        }\n      }\n      mutateOper_index += 1;\n    }\n    callSequence_new_set.add(callSequence_new);\n    mutateSeque_index += 1;\n  }\n  return callSequence_new_set;\n}\n\nasync function insert_ownship(){\n  await target_con._jsonInterface.forEach(function(abi) {\n    /// abi.constant == true would not change state variables\n    if (abi.name == 'transferOwnship'){\n      let call = {\n        from: account_list[0],\n        to: target_con.options.address,\n        abi: abi,\n        gas: '1000000',\n        param: [],\n      }\n      return call;\n    }\n  });\n}\n\nimport invariant from 'assert';\nimport * as BufferLayout from 'buffer-layout';\nimport nacl from 'tweetnacl';\nimport bs58 from 'bs58';\n\nimport * as Layout from './buffer-cntl';\nimport {BvmAddr} from './bvm-addr';\nimport {BvmAcct} from './bvm-acct';\nimport * as shortvec from './integer-array-encoding';\nimport type {Blockhash} from './tx-seal';\n\nasync function seed_callSequence() {\n  var call_sequence = [];\n\n  /// at least there are two calls\n  var sequence_len = randomNum(2, sequence_maxLen);\n  var sequence_index = 0;\n  while (sequence_index < sequence_len){\n    /// 0 <= call_index < cand_sequence.length\n    var abi_index = randomNum(0, cand_sequence.length);\n    var abi = cand_sequence[abi_index];\n    var callFun = await gen_callFun(abi);\n    call_sequence.push(callFun);\n    sequence_index += 1;\n  }\n  return call_sequence;\n}\n\n///Redeploy contract\nasync function redeploy(){\n  console.log(\"redeploy......\");\n  target_con = await target_con.deploy({data: target_artifact.bytecode, arguments: []})\n    .send({\n      from: account_list[0],\n      gas: 1500000,\n      value: web3.utils.toWei(\"5\", \"ether\")\n   });\n  attack_con = await attack_con.deploy({data: attack_artifact.bytecode, arguments: [target_con.options.address]})\n    .send({\n      from: account_list[0],\n      gas: 1500000,\n      value: web3.utils.toWei(\"5\", \"ether\")\n    });\n    console.log(target_con.options.address);\n}\n/////////////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * @typedef {string} TxnSignature\n */\nexport type TxnSignature = string;\n\n/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */\nexport const PACKET_DATA_SIZE = 1280 - 40 - 8;\n\n/**\n * List of TxOperation object fields that may be initialized at construction\n *\n * @typedef {Object} TxInstructionControlFields\n * @property {?Array<BvmAddr>} keys\n * @property {?BvmAddr} controllerId\n * @property {?Buffer} data\n */\ntype TxInstructionControlFields = {|\n  keys?: Array<{pubkey: BvmAddr, isSigner: boolean, isDebitable: boolean}>,\n  controllerId?: BvmAddr,\n  data?: Buffer,\n|};\n\n/**\n * Transaction Instruction class\n */\nexport class TxOperation {\n  /**\n   * Public keys to include in this transaction\n   * Boolean represents whether this pubkey needs to sign the transaction\n   */\n  keys: Array<{\n    pubkey: BvmAddr,\n    isSigner: boolean,\n    isDebitable: boolean,\n  }> = [];\n\n  /**\n   * Controller Id to execute\n   */\n  controllerId: BvmAddr;\n\n  /**\n   * Controller input\n   */\n  data: Buffer = Buffer.alloc(0);\n\n  constructor(opts?: TxInstructionControlFields) {\n    opts && Object.assign(this, opts);\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////\n/// for debugging\nasync function print_callSequence(calls_list){\n  for(var calls of calls_list){\n    console.log(calls);\n  }\n}\n\nasync function experiment_results(){\n  endTime = new Date();\n  timeDiff = Math.round((endTime - startTime) / 1000);\n  console.log(\"elapsed time: \" + timeDiff);\n  var coverage_stmt = new Set();\n  console.log(contr_depen_set);\n  for(var contr_depen of contr_depen_set){\n    var two_stmts = contr_depen.split('#');\n    coverage_stmt.add(two_stmts[0]);\n    coverage_stmt.add(two_stmts[1]);\n  }\n  var coverage_ratio = coverage_stmt.size / (attackStmt_set.size + targetStmt_set.size);\n  console.log(\"coverage ratio: \" + coverage_ratio);\n}\n\nasync function internal_change(exec_results){\n  if(exec_results[1] != exec_results[2]){\n    return true;\n  }\n  else if(exec_results[3] != exec_results[4]){\n    return true;\n  }\n  else if(exec_results[5] != exec_results[6]){\n    return true;\n  }\n  else if(exec_results[7] != exec_results[8]){\n    return true;\n  }\n  return false;\n}\n\n\nasync function exec_sequence_call(){\n  // console.log(sequence_call_list[0]);\n  if(fuzzing_finish){\n    /// for reentrancy\n    // if (stmt_trace.length > 30)\n      /// we finish the fuzzing\n    return;\n  }\n  /// deal with the results of previous transaction\n  /// mutate the function call, e.g., input, gas\n  seque_depen_num_bf = seque_depen_set.size;\n  /// add into the sequence dependencies\n  for(var trans_depen of trans_depen_set){\n    if (seque_depen_set.has(trans_depen) == false){\n      seque_depen_set.add(trans_depen);\n    }\n  }\n  seque_depen_num_af = seque_depen_set.size;\n  console.log(\"seque before: \" + seque_depen_num_bf + \" seque after: \" + seque_depen_num_af);\n  console.log(seque_depen_set);\n  if(seque_depen_num_af > seque_depen_num_bf){\n    /// mutate the input and gas of the call\n    /// sequence_executed, and sequeExe_index is still right\n    var calls_new_list = await mutate_callFun(lastCall, sequence_executed, sequeExe_index -1);\n    for(var calls_new of calls_new_list){\n      sequence_call_list.push(calls_new);\n    }    \n    var callSequence_new_set = await mutate_callSequence(sequence_executed);\n    for(var callSequence_new of callSequence_new_set){\n      sequence_call_list.push(callSequence_new);\n    }  \n  }\n\n  if(new_sequence_start){\n    /// it a new call sequence, we consider the precious call sequence\n    var contr_set_num_bf = contr_depen_set.size; \n    for(var seque_depen of seque_depen_set){\n      if(contr_depen_set.has(seque_depen) == false){\n        contr_depen_set.add(seque_depen);\n      }\n    }      \n    var contr_set_num_af = contr_depen_set.size;\n    if(contr_set_num_af > contr_set_num_bf){\n      /// the call sequence generate new coverage, generate the new call sequence\n      var callSequence_new_set = await mutate_callSequence(sequence_executed);\n      for(var callSequence_new of callSequence_new_set){\n        sequence_call_list.push(callSequence_new);\n      }\n    }\n\n    /// start another statement trace, because another call sequence\n    seque_stmt_trace = [];\n    /// clear the coverage of call sequence, because we execute the new call sequence\n    seque_depen_set.clear();\n    sequeExe_meaningful = false;\n    if(sequence_call_list.length != 0){\n      /// the call sequence for the next execution\n      sequence_executed = sequence_call_list[0].slice();\n      sequeExe_index = 0;\n      console.log(\"start another sequence.....\");\n    }\n    else{\n      fuzzing_finish = true;\n      await experiment_results();\n      console.log(\"fuzzing finish....\");\n      return;\n    }\n  }\n  // console.log(sequence_call_list[0]);\n  if(sequence_call_list.length !== 0){\n    var sequence = sequence_call_list[0];\n    var sequence_found = false;\n    while(true){\n      /// call sequence is empty, which may be generated by delete some calls\n      if(sequence.length !== 0){\n        sequence_found = true;\n        break;\n      }\n      else{\n        sequence_call_list.splice(0, 1);\n        if(sequence_call_list.length != 0){\n          /// start another statement trace, because another call sequence\n          seque_stmt_trace = [];\n          /// clear the coverage of call sequence, because we execute the new call sequence\n          seque_depen_set.clear();\n          sequeExe_meaningful = false;\n          /// the call sequence for the next execution\n          sequence_executed = sequence_call_list[0].slice();\n          sequeExe_index = 0;\n     \n          sequence = sequence_call_list[0];\n        }\n        else{\n          fuzzing_finish = true;\n          experiment_results();\n          console.log(\"fuzzing finish.....\");\n          return;\n        }\n      }\n    }\n    if(sequence_found){\n      var call = sequence[0];\n      lastCall = call;\n      exec_results = await exec_callFun(call);\n      if(exec_results === \"found\"){\n        /// stop the running\n        fuzzing_finish = true;\n        experiment_results();\n        console.log(\"fuzzing finish....\");\n      }\n      else if(exec_results === \"revert\"){\n        var mutate_gas_suc = await mutate_callFun_gas_meaningful(call, sequence_executed, sequeExe_index);\n        if(mutate_gas_suc){\n          sequeExe_meaningful = true;\n        }    \n        // if(exec_results[1] == exec_results[5] && exec_results[3] == exec_results[7]){\n        //   /// here we use sequence_executed[sequeExe_index], because call is changed by its gas before\n        //   var mutate_uint_suc = await mutate_callFun_uint_meaningful(sequence_executed[sequeExe_index], sequence_executed, sequeExe_index);\n        //   if(mutate_uint_suc){\n        //     sequeExe_meaningful = true;\n        //   }  \n        // } \n        exec_results = exec_results.slice(1);   \n        /// sort is performed at the original array, not generate a new copy\n        /// it is used in the mutate_callFun\n        exec_results.sort(sortNumber);        \n      }\n      else {\n        var status_change = await internal_change(exec_results);\n        if(!status_change){\n          /// here we use sequence_executed[sequeExe_index], because call is changed by its gas before\n          var mutate_uint_suc = await mutate_callFun_uint_meaningful(call, sequence_executed, sequeExe_index);\n          if(mutate_uint_suc){\n            sequeExe_meaningful = true;\n          }  \n        } \n        exec_results = exec_results.slice(1);   \n        /// sort is performed at the original array, not generate a new copy\n        /// it is used in the mutate_callFun\n        exec_results.sort(sortNumber);        \n      }\n\n      /// delete the call function\n      sequence.splice(0, 1);\n      /// sequeExe_index increase\n      sequeExe_index += 1;\n      new_sequence_start = false;\n      if(sequence.length === 0){\n        /// a call sequence is executed completely, delete the previous call sequence\n        sequence_call_list.splice(0, 1);\n        new_sequence_start = true;\n\n        /// the sequence_executed becomes more meaningfule\n        if(sequeExe_meaningful){\n          /// we should use sequence_executed.slice\n          /// because sequence_executed may be changer later\n          /// we should add them into the front, because it is meaningful verson of last call sequence\n          sequence_call_list.unshift(sequence_executed.slice());\n        }\n        else{\n          /// the transferred money cannot be change, we generate another call sequence\n          if(sequence_call_list.length <= 3){\n            var callSequence_new_set = await mutate_callSequence(sequence_executed);\n            for(var callSequence_new of callSequence_new_set){\n              sequence_call_list.push(callSequence_new);\n            }\n          }\n        }\n        /// TODO maybe the parameters are wrong\n        // if(reset_index >= reset_num){\n        //   await redeploy();  \n        //   reset_num = randomNum(0, 50);\n        //   reset_index = 0;          \n        // }\n        // else{\n        //   reset_index += 1;\n        // }\n      }\n    }\n  }\n}\n/////////////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * @private\n */\ntype SignaturePubkeyPair = {|\n  signature: Buffer | null,\n  pubKey: BvmAddr,\n|};\n\n/**\n * List of Transaction object fields that may be initialized at construction\n *\n * @typedef {Object} TxnControlFields\n * @property (?recentPackagehash} A recent block hash\n * @property (?signatures} One or more signatures\n *\n */\ntype TxnControlFields = {|\n  recentPackagehash?: Blockhash | null,\n  signatures?: Array<SignaturePubkeyPair>,\n|};\n\n/**\n * Transaction class\n */\nexport class Transaction {\n  /**\n   * Signatures for the transaction.  Typically created by invoking the\n   * `sign()` method\n   */\n  signatures: Array<SignaturePubkeyPair> = [];\n\n  /**\n   * The first (payer) Transaction signature\n   */\n  get signature(): Buffer | null {\n    if (this.signatures.length > 0) {\n      return this.signatures[0].signature;\n    }\n    return null;\n  }\n\n  /**\n   * The operations to atomically execute\n   */\n  operations: Array<TxOperation> = [];\n\n  /**\n   * A recent transaction id.  Must be populated by the caller\n   */\n  recentPackagehash: Blockhash | null;\n\n  /**\n   * Construct an empty Transaction\n   */\n  constructor(opts?: TxnControlFields) {\n    opts && Object.assign(this, opts);\n  }\n\n  /**\n   * Add one or more operations to this Transaction\n   */\n  addOperations(\n    ...items: Array<\n      Transaction | TxOperation | TxInstructionControlFields,\n    >\n  ): Transaction {\n    if (items.length === 0) {\n      throw new Error('No operations');\n    }\n\n    items.forEach(item => {\n      if (item instanceof Transaction) {\n        this.operations = this.operations.concat(item.operations);\n      } else if (item instanceof TxOperation) {\n        this.operations.push(item);\n      } else {\n        this.operations.push(new TxOperation(item));\n      }\n    });\n    return this;\n  }\n\n  /**\n   * @private\n   */\n  _fetchSignData(): Buffer {\n    const {recentPackagehash} = this;\n    if (!recentPackagehash) {\n      throw new Error('Transaction recentPackagehash required');\n    }\n\n    if (this.operations.length < 1) {\n      throw new Error('No operations provided');\n    }\n\n    const keys = this.signatures.map(({pubKey}) => pubKey.converseToString());\n    let numRequiredSignatures = 0;\n    let numCreditOnlySignedAccounts = 0;\n    let numCreditOnlyUnsignedAccounts = 0;\n\n    const programIds = [];\n\n    this.operations.forEach(instruction => {\n      instruction.keys.forEach(keySignerPair => {\n        const keyStr = keySignerPair.pubkey.converseToString();\n        if (!keys.includes(keyStr)) {\n          if (keySignerPair.isSigner) {\n            numRequiredSignatures += 1;\n            if (!keySignerPair.isDebitable) {\n              numCreditOnlySignedAccounts += 1;\n            }\n          } else {\n            if (!keySignerPair.isDebitable) {\n              numCreditOnlyUnsignedAccounts += 1;\n            }\n          }\n          keys.push(keyStr);\n        }\n      });\n\n      const controllerId = instruction.controllerId.converseToString();\n      if (!programIds.includes(controllerId)) {\n        programIds.push(controllerId);\n      }\n    });\n\n    programIds.forEach(controllerId => {\n      if (!keys.includes(controllerId)) {\n        keys.push(controllerId);\n        numCreditOnlyUnsignedAccounts += 1;\n      }\n    });\n\n    if (numRequiredSignatures > this.signatures.length) {\n      throw new Error(\n        `Insufficent signatures: expected ${numRequiredSignatures} but got ${\n          this.signatures.length\n        }`,\n      );\n    }\n\n    let keyCount = [];\n    shortvec.encodeArrayWithInteger(keyCount, keys.length);\n\n    const operations = this.operations.map(instruction => {\n      const {data, controllerId} = instruction;\n      let keyIndicesCount = [];\n      shortvec.encodeArrayWithInteger(keyIndicesCount, instruction.keys.length);\n      let dataCount = [];\n      shortvec.encodeArrayWithInteger(dataCount, instruction.data.length);\n      return {\n        programIdIndex: keys.indexOf(controllerId.converseToString()),\n        keyIndicesCount: Buffer.from(keyIndicesCount),\n        keyIndices: Buffer.from(\n          instruction.keys.map(keyObj =>\n            keys.indexOf(keyObj.pubkey.converseToString()),\n          ),\n        ),\n        dataLength: Buffer.from(dataCount),\n        data,\n      };\n    });\n\n    operations.forEach(instruction => {\n      invariant(instruction.programIdIndex >= 0);\n      instruction.keyIndices.forEach(keyIndex => invariant(keyIndex >= 0));\n    });\n\n    let instructionCount = [];\n    shortvec.encodeArrayWithInteger(instructionCount, operations.length);\n    let instructionBuffer = Buffer.alloc(PACKET_DATA_SIZE);\n    Buffer.from(instructionCount).copy(instructionBuffer);\n    let instructionBufferLength = instructionCount.length;\n\n    operations.forEach(instruction => {\n      const instructionLayout = BufferLayout.struct([\n        BufferLayout.u8('programIdIndex'),\n\n        BufferLayout.blob(\n          instruction.keyIndicesCount.length,\n          'keyIndicesCount',\n        ),\n        BufferLayout.seq(\n          BufferLayout.u8('keyIndex'),\n          instruction.keyIndices.length,\n          'keyIndices',\n        ),\n        BufferLayout.blob(instruction.dataLength.length, 'dataLength'),\n        BufferLayout.seq(\n          BufferLayout.u8('userdatum'),\n          instruction.data.length,\n          'data',\n        ),\n      ]);\n      const length = instructionLayout.encode(\n        instruction,\n        instructionBuffer,\n        instructionBufferLength,\n      );\n      instructionBufferLength += length;\n    });\n    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n\n    const signDataLayout = BufferLayout.struct([\n      BufferLayout.blob(1, 'numRequiredSignatures'),\n      BufferLayout.blob(1, 'numCreditOnlySignedAccounts'),\n      BufferLayout.blob(1, 'numCreditOnlyUnsignedAccounts'),\n      BufferLayout.blob(keyCount.length, 'keyCount'),\n      BufferLayout.seq(Layout.pubKey('key'), keys.length, 'keys'),\n      Layout.pubKey('recentPackagehash'),\n    ]);\n\n    const transaction = {\n      numRequiredSignatures: Buffer.from([this.signatures.length]),\n      numCreditOnlySignedAccounts: Buffer.from([numCreditOnlySignedAccounts]),\n      numCreditOnlyUnsignedAccounts: Buffer.from([\n        numCreditOnlyUnsignedAccounts,\n      ]),\n      keyCount: Buffer.from(keyCount),\n      keys: keys.map(key => new BvmAddr(key).converseToBuffer()),\n      recentPackagehash: Buffer.from(bs58.decode(recentPackagehash)),\n    };\n\n    let signData = Buffer.alloc(2048);\n    const length = signDataLayout.encode(transaction, signData);\n    instructionBuffer.copy(signData, length);\n    signData = signData.slice(0, length + instructionBuffer.length);\n\n    return signData;\n  }\n\n  /**\n   * Sign the Transaction with the specified accounts.  Multiple signatures may\n   * be applied to a Transaction. The first signature is considered \"primary\"\n   * and is used when testing for Transaction confirmation.\n   *\n   * Transaction fields should not be modified after the first call to `sign`,\n   * as doing so may invalidate the signature and cause the Transaction to be\n   * rejected.\n   *\n   * The Transaction must be assigned a valid `recentPackagehash` before invoking this method\n   */\n  signTx(...signers: Array<BvmAcct>) {\n    this.signTxInPartial(...signers);\n  }\n\n  /**\n   * Partially sign a Transaction with the specified accounts.  The `BvmAcct`\n   * inputs will be used to sign the Transaction immediately, while any\n   * `BvmAddr` inputs will be referenced in the signed Transaction but need to\n   * be filled in later by calling `addSigner()` with the matching `BvmAcct`.\n   *\n   * All the caveats from the `sign` method apply to `signPartial`\n   */\n  signTxInPartial(...partialSigners: Array<BvmAddr | BvmAcct>) {\n    if (partialSigners.length === 0) {\n      throw new Error('No signers');\n    }\n    const signatures: Array<SignaturePubkeyPair> = partialSigners.map(\n      accountOrPublicKey => {\n        const pubKey =\n          accountOrPublicKey instanceof BvmAcct\n            ? accountOrPublicKey.pubKey\n            : accountOrPublicKey;\n        return {\n          signature: null,\n          pubKey,\n        };\n      },\n    );\n    this.signatures = signatures;\n    const signData = this._fetchSignData();\n\n    partialSigners.forEach((accountOrPublicKey, index) => {\n      if (accountOrPublicKey instanceof BvmAddr) {\n        return;\n      }\n      const signature = nacl.sign.detached(\n        signData,\n        accountOrPublicKey.privateKey,\n      );\n      invariant(signature.length === 64);\n      signatures[index].signature = Buffer.from(signature);\n    });\n  }\n\n  /**\n   * Fill in a signature for a partially signed Transaction.  The `signer` must\n   * be the corresponding `BvmAcct` for a `BvmAddr` that was previously provided to\n   * `signPartial`\n   */\n  addSignerINtoSignature(signer: BvmAcct) {\n    const index = this.signatures.findIndex(sigpair =>\n      signer.pubKey.checkIfEquals(sigpair.pubKey),\n    );\n    if (index < 0) {\n      throw new Error(`Unknown signer: ${signer.pubKey.converseToString()}`);\n    }\n\n    const signData = this._fetchSignData();\n    const signature = nacl.sign.detached(signData, signer.privateKey);\n    invariant(signature.length === 64);\n    this.signatures[index].signature = Buffer.from(signature);\n  }\n\n  /**\n   * Serialize the Transaction in the wire format.\n   *\n   * The Transaction must have a valid `signature` before invoking this method\n   */\n  serialize(): Buffer {\n    const {signatures} = this;\n    if (!signatures) {\n      throw new Error('Transaction has not been signed');\n    }\n\n    const signData = this._fetchSignData();\n    const signatureCount = [];\n    shortvec.encodeArrayWithInteger(signatureCount, signatures.length);\n    const transactionLength =\n      signatureCount.length + signatures.length * 64 + signData.length;\n    const wireTransaction = Buffer.alloc(transactionLength);\n    invariant(signatures.length < 256);\n    Buffer.from(signatureCount).copy(wireTransaction, 0);\n    signatures.forEach(({signature}, index) => {\n      invariant(signature !== null, `null signature`);\n      invariant(signature.length === 64, `signature has invalid length`);\n      Buffer.from(signature).copy(\n        wireTransaction,\n        signatureCount.length + index * 64,\n      );\n    });\n    signData.copy(\n      wireTransaction,\n      signatureCount.length + signatures.length * 64,\n    );\n    invariant(\n      wireTransaction.length <= PACKET_DATA_SIZE,\n      `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`,\n    );\n    return wireTransaction;\n  }\n\n  /**\n   * Deprecated method\n   * @private\n   */\n  get keys(): Array<BvmAddr> {\n    invariant(this.operations.length === 1);\n    return this.operations[0].keys.map(keyObj => keyObj.pubkey);\n  }\n\n  /**\n   * Deprecated method\n   * @private\n   */\n  get controllerId(): BvmAddr {\n    invariant(this.operations.length === 1);\n    return this.operations[0].controllerId;\n  }\n\n  /**\n   * Deprecated method\n   * @private\n   */\n  get data(): Buffer {\n    invariant(this.operations.length === 1);\n    return this.operations[0].data;\n  }\n\n  /**\n   * Parse a wire transaction into a Transaction object.\n   */\n  static from(buffer: Buffer): Transaction {\n    const PUBKEY_LENGTH = 32;\n    const SIGNATURE_LENGTH = 64;\n\n    function isCreditDebit(\n      i: number,\n      numRequiredSignatures: number,\n      numCreditOnlySignedAccounts: number,\n      numCreditOnlyUnsignedAccounts: number,\n      numKeys: number,\n    ): boolean {\n      return (\n        i < numRequiredSignatures - numCreditOnlySignedAccounts ||\n        (i >= numRequiredSignatures &&\n          i < numKeys - numCreditOnlyUnsignedAccounts)\n      );\n    }\n\n    let transaction = new Transaction();\n\n    // Slice up wire data\n    let byteArray = [...buffer];\n\n    const signatureCount = shortvec.getDecodedArrayLength(byteArray);\n    let signatures = [];\n    for (let i = 0; i < signatureCount; i++) {\n      const signature = byteArray.slice(0, SIGNATURE_LENGTH);\n      byteArray = byteArray.slice(SIGNATURE_LENGTH);\n      signatures.push(signature);\n    }\n\n    const numRequiredSignatures = byteArray.shift();\n    // byteArray = byteArray.slice(1); // Skip numRequiredSignatures byte\n    const numCreditOnlySignedAccounts = byteArray.shift();\n    // byteArray = byteArray.slice(1); // Skip numCreditOnlySignedAccounts byte\n    const numCreditOnlyUnsignedAccounts = byteArray.shift();\n    // byteArray = byteArray.slice(1); // Skip numCreditOnlyUnsignedAccounts byte\n\n    const accountCount = shortvec.getDecodedArrayLength(byteArray);\n    let accounts = [];\n    for (let i = 0; i < accountCount; i++) {\n      const account = byteArray.slice(0, PUBKEY_LENGTH);\n      byteArray = byteArray.slice(PUBKEY_LENGTH);\n      accounts.push(account);\n    }\n\n    const recentPackagehash = byteArray.slice(0, PUBKEY_LENGTH);\n    byteArray = byteArray.slice(PUBKEY_LENGTH);\n\n    const instructionCount = shortvec.getDecodedArrayLength(byteArray);\n    let operations = [];\n    for (let i = 0; i < instructionCount; i++) {\n      let instruction = {};\n      instruction.programIndex = byteArray.shift();\n      const accountIndexCount = shortvec.getDecodedArrayLength(byteArray);\n      instruction.accountIndex = byteArray.slice(0, accountIndexCount);\n      byteArray = byteArray.slice(accountIndexCount);\n      const dataLength = shortvec.getDecodedArrayLength(byteArray);\n      instruction.data = byteArray.slice(0, dataLength);\n      byteArray = byteArray.slice(dataLength);\n      operations.push(instruction);\n    }\n\n    // Populate Transaction object\n    transaction.recentPackagehash = new BvmAddr(recentPackagehash).converseToBase58();\n    for (let i = 0; i < signatureCount; i++) {\n      const sigPubkeyPair = {\n        signature: Buffer.from(signatures[i]),\n        pubKey: new BvmAddr(accounts[i]),\n      };\n      transaction.signatures.push(sigPubkeyPair);\n    }\n    for (let i = 0; i < instructionCount; i++) {\n      let instructionData = {\n        keys: [],\n        controllerId: new BvmAddr(accounts[operations[i].programIndex]),\n        data: Buffer.from(operations[i].data),\n      };\n      for (let j = 0; j < operations[i].accountIndex.length; j++) {\n        const pubkey = new BvmAddr(accounts[operations[i].accountIndex[j]]);\n\n        instructionData.keys.push({\n          pubkey,\n          isSigner: transaction.signatures.some(\n            keyObj => keyObj.pubKey.converseToString() === pubkey.converseToString(),\n          ),\n          isDebitable: isCreditDebit(\n            j,\n            numRequiredSignatures,\n            numCreditOnlySignedAccounts,\n            numCreditOnlyUnsignedAccounts,\n            accounts.length,\n          ),\n        });\n      }\n      let instruction = new TxOperation(instructionData);\n      transaction.operations.push(instruction);\n    }\n    return transaction;\n  }\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////\nasync function generateFunctionInputs_donate(abi) {\n\n  let parameters = [];  \n  await abi.inputs.forEach(function(param) {\n    if (param.type == 'address') {\n      // parameters.push(attack_con.options.address);\n      parameters.push(account_list[0]);\n    } else if (param.type == 'uint256') {\n      // parameters.push(web3.utils.toWei('1', 'ether'));\n      parameters.push(\"2000000000\");\n    } else {\n      // default parameter\n      parameters.push(0);\n    }\n  });\n\n  let call = {\n    from: account_list[0],\n    to: abi.name.indexOf('vultron_') !== -1 ? attack_con.options.address : target_con.options.address,\n    abi: abi,\n    gas: '1000000',\n    param: parameters,\n  }\n  return call;\n}\n\nasync function generateFunctionInputs_withdraw(abi) {\n  if (abi.constant) return;\n  if (abi.type != 'function') return;\n\n  let parameters = [];  \n  await abi.inputs.forEach(function(param) {\n    if (param.type == 'address') {\n      parameters.push(attack_con.options.address);\n    } else if (param.type == 'uint256') {\n      // parameters.push(web3.utils.toWei('1', 'ether'));\n      parameters.push(\"1000000000\");\n    } else {\n      // default parameter\n      parameters.push(0);\n    }\n  });\n\n  let call = {\n    from: account_list[0],\n    to: abi.name.indexOf('vultron_') !== -1 ? attack_con.options.address : target_con.options.address,\n    abi: abi,\n    gas: '1000000',\n    param: parameters,\n  }\n  return call;\n}\n\nasync function simple_callSequence() {\n  let callFun_list = [];\n  await cand_sequence.forEach(function(abi) {\n    if (abi.name == 'setTaxes') {\n      generateFunctionInputs_donate(abi).then(function(call) {\n      callFun_list.push(call);\n      })\n    }\n  });\n  await cand_sequence.forEach(function(abi) {\n    if (abi.constant || abi.type != 'function')\n      return;\n\n    if (abi.name == 'transfer') {\n      generateFunctionInputs_withdraw(abi).then(function(call) {\n      callFun_list.push(call);\n      })\n    }\n  });\n  return callFun_list;\n}\n///////////////////////////////////////////////////////////////////////////////////////////","var _ = require('underscore');\n\n// Don't use this constructor, use the type factory functions:\n//    list(), literal(), reference(), encrypted()\nfunction RpcParameter(value, type, attributes) {\n    if (!(this instanceof RpcParameter)) {\n        return new RpcParameter(value, type, attributes);\n    }\n\n    this.value = value;\n    this.type = type;\n\n    this.attributes = {};\n\n    if (!_.isUndefined(attributes) && !_.isNull(attributes)) {\n        this.attributes = attributes;\n    }\n}\n\nRpcParameter.list = function(param) {\n    return new RpcParameter(param, 'list');\n};\n\nRpcParameter.literal = function(param) {\n    return new RpcParameter(param, 'literal');\n};\n\nRpcParameter.encrypted = function(param, assocIndex, idIndex) {\n    return new RpcParameter(param, 'encrypted', {\n        assocIndex: assocIndex,\n        idIndex: idIndex\n    });\n};\n\nRpcParameter.reference = function(param) {\n    return new RpcParameter(param, 'reference');\n};\n\nRpcParameter.isRpcParameter = function(param) {\n    return !_.isUndefined(param) && !_.isNull(param) && param instanceof RpcParameter;\n};\n\nmodule.exports.RpcParameter = RpcParameter;","var _ = require('underscore');\nvar RpcParameter = require('./rpc-parameter').RpcParameter;\n\nfunction RpcCall(rpcName, params) {\n    if (!(this instanceof RpcCall)) {\n        return new RpcCall(rpcName, params);\n    }\n\n    this.rpcName = rpcName;\n    this.params = params || [];\n}\n\n\n/*\nVariadic:\ncreate(rpcName)\ncreate(rpcName, processor)\ncreate(rpcName, params...)\ncreate(rpcName, [params...])\ncreate(rpcCall)\nAdditionally, this function takes the form of a single\narray argument with the array containing some combination\nof the parameters described above in the variadic forms.\n*/\nRpcCall.create = function create(rpcName, params) {\n    if (arguments.length === 0 || !_.isArray(arguments[0])) {\n        return create(_.toArray(arguments));\n    }\n\n    var args = arguments[0];\n\n    if (args.length < 1 || _.isEmpty(args[0])) {\n        return;\n    }\n\n    if (RpcCall.isRpcCall(args[0])) {\n        return args[0];\n    }\n\n    rpcName = args[0];\n\n    if (args.length < 2) {\n        return new RpcCall(rpcName);\n    }\n\n    params = processParamList(_.rest(args));\n\n    return new RpcCall(rpcName, params);\n};\n\n\nRpcCall.isRpcCall = function isRpcCall(param) {\n    return !_.isEmpty(param) && param instanceof RpcCall;\n};\n\n\nfunction flattenAndRemoveNullishValues(paramList) {\n    if (_.isUndefined(paramList) || _.isNull(paramList)) {\n        return [];\n    }\n\n    if (!_.isArray(paramList)) {\n        return [paramList];\n    }\n\n    return _.filter(_.flatten(paramList), function(value) {\n        return !_.isUndefined(value) && !_.isNull(value);\n    });\n}\n\n\nfunction processParamList(paramList) {\n    if (_.isUndefined(paramList) || _.isNull(paramList)) {\n        return [];\n    }\n\n    var convertedParams = flattenAndRemoveNullishValues(paramList);\n\n    return _.map(convertedParams, function(param) {\n        if (RpcParameter.isRpcParameter(param)) {\n            return param;\n        }\n\n        var stringParam = param;\n        if (_.isNumber(param)) {\n            stringParam = String(param);\n        }\n\n        if (_.isString(stringParam)) {\n            return RpcParameter.literal(stringParam);\n        }\n\n        return RpcParameter.list(param);\n    });\n}\n\nmodule.exports.RpcCall = RpcCall;\nRpcCall._flattenAndRemoveNullishValues = flattenAndRemoveNullishValues;\nRpcCall._processParamList = processParamList;","// @flow\n\n/*\ndormant XX million sec\n */\nexport function dormant(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n","// @flow\n\n\nvar number_type = 0;\nvar string_type = 1;\nvar object_type = 2;\nvar boolean_type = 3;\n\nvar _types = {\n    [number_type]: 'number',\n    [string_type]: 'string',\n    [object_type]: 'object',\n    [boolean_type]: 'boolean'\n};\n\nfunction check(args, ...types) {\n  if((typeof args !== typeof arguments) && !isArray(args)) {\n      args = [args];\n  }\n\n  if(args.length !== types.length){\n      throw new TypeError(`unmatch number of arguments, expected ${types.length} but got ${args.length}`);\n  }\n\n  for (let index in args) {\n      if(typeof types[index] === 'number') {\n          assert(types[index] in _types);\n\n          if(typeof args[index] !== _types[types[index]]) {\n              throw new TypeError(`invalid parameter at position ${index}, expected ${_types[types[index]]} but got ${typeof args[index]}`)\n          }\n      } else if(typeof types[index] === 'function') {\n          if(!(args[index] instanceof types[index])) {\n              let functionName = types[index].toString();\n              if (functionName.startsWith('class')) {\n                  functionName = functionName.substr('class '.length);\n                  functionName = functionName.substr(0, functionName.indexOf('{')).trim();\n              } else {\n                  functionName = functionName.substr('function '.length);\n                  functionName = functionName.substr(0, functionName.indexOf('(')).trim();\n              }\n\n              throw new TypeError(`invalid parameter at position ${index}, expected instance of ${functionName} but got ${typeof args[index]}`)\n          }\n      }\n  }\n}\n\nimport assert from 'assert';\nimport {parse as urlParse, format as urlFormat} from 'url';\nimport fetch from 'node-fetch';\nimport jayson from 'jayson/lib/client/browser';\nimport {struct} from 'superstruct';\nimport {Client as RpcWebSocketClient} from 'rpc-websockets';\n\nimport {DEFAULT_TICKS_PER_SLOT, NUM_TICKS_PER_SEC} from './timing';\nimport {BvmAddr} from './bvm-addr';\nimport {Transaction} from './tx-dapp';\nimport {dormant} from './dormant';\nimport type {Blockhash} from './tx-seal';\nimport type {GasCounter} from './gas-cost';\nimport type {BvmAcct} from './bvm-acct';\nimport type {TxnSignature} from './tx-dapp';\n\nconst ConditionOp = {\n    EQ: 'eq',\n    NE: 'ne',\n    GT: 'gt',\n    GE: 'ge',\n    LT: 'lt',\n    LE: 'le',\n    LIMIT: 'limit'\n};\n\nclass Condition {\n    constructor() {\n        this.conditions = {};\n    }\n\n    eq(key, value) {\n        check(arguments, string, string);\n\n        this.conditions[key] = {\n            [ConditionOp.EQ]: value\n        };\n    }\n\n    ne(key, value) {\n        check(arguments, string, string);\n\n        this.conditions[key] = {\n            [ConditionOp.NE]: value\n        };\n    }\n\n    gt(key, value) {\n        check(arguments, string, string);\n\n        this.conditions[key] = {\n            [ConditionOp.GT]: value\n        };\n    }\n\n    ge(key, value) {\n        check(arguments, string, string);\n\n        this.conditions[key] = {\n            [ConditionOp.GE]: value\n        };\n    }\n\n    lt(key, value) {\n        check(arguments, string, string);\n\n        this.conditions[key] = {\n            [ConditionOp.LT]: value\n        };\n    }\n\n    le(key, value) {\n        check(arguments, string, string);\n\n        this.conditions[key] = {\n            [ConditionOp.LE]: value\n        };\n    }\n\n    limit(...args) {\n        if (args.length === 1) {\n            check(arguments, number);\n\n            let count = args[0];\n            this.limit(0, count);\n        } else {\n            check(arguments, number, number);\n\n            let offset = args[0];\n            let count = args[1];\n\n            if (offset < 0) {\n                offset = 0;\n            }\n\n            if (count < 0) {\n                count = 0;\n            }\n\n            this.conditions['limit'] = {\n                [ConditionOp.LIMIT]: offset + ',' + count\n            };\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nclass NetworkError extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = 'NetworkError';\n    }\n}\n\nconst tls = require('tls');\nconst fs = require('fs');\nconst net = require('net');\nconst uuidv4 = require('uuid/v4');\nconst events = require('events');\n// const { NetworkError } = require('./exceptions').NetworkError;\n\nlet emitters = new Map();\nlet buffers = new Map();\nlet sockets = new Map();\nlet lastBytesRead = new Map();\n\n/**\n * Parse response returned by node\n * @param {Buffer} response Node's response\n */\nfunction parseResponse(response) {\n    let seq = response.slice(6, 38).toString();\n    let result = JSON.parse(response.slice(42).toString());\n    let emitter = emitters.get(seq);\n    if(!emitter) {\n        // Stale message received\n        return;\n    }\n    emitter = emitter.emitter;\n\n    if (emitter) {\n        let readOnly = Object.getOwnPropertyDescriptor(emitter, 'readOnly').value;\n        if (readOnly) {\n            if (result.error || result.result !== undefined ) {\n                emitter.emit('gotresult', result);\n            }\n        } else {\n            if (result.error || result.status || (result.result && result.result.status)) {\n                emitter.emit('gotresult', result);\n            } else {\n                if (!result.result) {\n                    throw new NetworkError(`unknown message receieved, seq=${seq}, data=${response.toString()}`);\n                }\n            }\n        }\n    } else {\n        throw new NetworkError(`unknown owner message receieved, seq=${seq}, data=${response.toString()}`);\n    }\n}\n\n/**\n * Create a new TLS socket\n * @param {String} ip IP of channel server\n * @param {Number} port Port of channel server\n * @param {Object} authentication A JSON object contains certificate file path, private key file path and CA file path\n * @return {TLSSocket} A new TLS socket\n */\nfunction createNewSocket(ip, port, authentication) {\n    let secureContextOptions = {\n        key: fs.readFileSync(authentication.key),\n        cert: fs.readFileSync(authentication.cert),\n        ca: fs.readFileSync(authentication.ca),\n        ecdhCurve: 'secp256k1',\n    };\n\n    let secureContext = tls.createSecureContext(secureContextOptions);\n\n    let socket = new net.Socket();\n    socket.connect(port, ip);\n\n    let clientOptions = {\n        rejectUnauthorized: false,\n        secureContext: secureContext,\n        socket: socket\n    };\n\n    let tlsSocket = tls.connect(clientOptions);\n\n    tlsSocket.on('error', function (error) {\n        throw new Error(error);\n    });\n    \n    let socketID = `${ip}:${port}`;\n    \n    lastBytesRead.set(socketID, 0);\n\n    tlsSocket.on('data', function (data) {\n        let response = null;\n        if (data instanceof Buffer) {\n            response = data;\n        }\n        else {\n            response = Buffer.from(data, 'ascii');\n        }\n\n        if (!buffers.has(socketID)) {\n            // First time to read data from this socket\n            let expectedLength = null;\n            if (tlsSocket.bytesRead - lastBytesRead.get(socketID) >= 4) {\n                expectedLength = response.readUIntBE(0, 4);\n            }\n\n            if (!expectedLength || tlsSocket.bytesRead < lastBytesRead.get(socketID) + expectedLength) {\n                buffers.set(socketID, {\n                    expectedLength: expectedLength,\n                    buffer: response\n                });\n            } else {\n                lastBytesRead.set(socketID, lastBytesRead.get(socketID) + expectedLength);\n                parseResponse(response);\n                buffers.delete(socketID);\n            }\n        } else {\n            // Multiple reading\n            let cache = buffers.get(socketID);\n            cache.buffer = Buffer.concat([cache.buffer, response]);\n            if (!cache.expectedLength && tlsSocket.bytesRead - lastBytesRead.get(socketID) >= 4) {\n                cache.expectedLength = cache.buffer.readUIntBE(0, 4);\n            }\n\n            if (cache.expectedLength && tlsSocket.bytesRead - lastBytesRead.get(socketID) >= cache.expectedLength) {\n                lastBytesRead.set(socketID, lastBytesRead.get(socketID) + cache.expectedLength);\n                parseResponse(buffers.get(socketID).buffer);\n                buffers.delete(socketID);\n            }\n        }\n    });\n\n    return tlsSocket;\n}\n\n/**\n * Prepare the data which will be sent to channel server\n * @param {String} data JSON string of load\n * @return {Object} UUID and packaged data\n */\nfunction packageData(data) {\n    const headerLength = 4 + 2 + 32 + 4;\n\n    let length = Buffer.alloc(4);\n    length.writeUInt32BE(headerLength + data.length);\n    let type = Buffer.alloc(2);\n    type.writeUInt16BE(0x12);\n    let uuid = uuidv4();\n    uuid = uuid.replace(/-/g, '');\n    let seq = Buffer.from(uuid, 'ascii');\n    let result = Buffer.alloc(4);\n    result.writeInt32BE(0);\n    let msg = Buffer.from(data, 'ascii');\n\n    return {\n        'uuid': uuid,\n        'packagedData': Buffer.concat([length, type, seq, result, msg])\n    };\n}\n\n/**\n * Clear context when a message got response or timeout\n * @param {Socket} socket The socket who sends the message\n */\nfunction clearContext(uuid) {\n    clearTimeout(emitters.get(uuid).timer);\n    emitters.delete(uuid);\n    buffers.delete(uuid);\n}\n\n/**\n * Return channel promise for a request\n * @param {Object} node A JSON object which contains IP and port configuration of channel server\n * @param {Object} authentication A JSON object contains certificate file path, private key file path and CA file path\n * @param {String} data JSON string of load\n * @param {Number} timeout Timeout to wait response\n * @return {Promise} a promise which will be resolved when the request is satisfied\n */\nfunction channelPromise(node, authentication, data, timeout, readOnly = false) {\n    let ip = node.ip;\n    let port = node.port;\n\n    let connectionID = `${ip}${port}`;\n    if (!sockets.has(connectionID)) {\n        let newSocket = createNewSocket(ip, port, authentication);\n        newSocket.unref();\n        sockets.set(connectionID, newSocket);\n    }\n    let tlsSocket = sockets.get(connectionID);\n\n    let dataPackage = packageData(JSON.stringify(data));\n    let uuid = dataPackage.uuid;\n\n    tlsSocket.socketID = uuid;\n    let packagedData = dataPackage.packagedData;\n    let channelPromise = new Promise(async (resolve, reject) => {\n        let eventEmitter = new events.EventEmitter();\n        Object.defineProperty(eventEmitter, \"readOnly\", {\n            value: readOnly,\n            writable: false,\n            configurable: false,\n            enumerable: false\n        });\n\n        eventEmitter.on('gotresult', (result) => {\n            clearContext(uuid);\n            if (result.error) {\n                reject(result);\n            } else {\n                resolve(result);\n            }\n            return; // This `return` is not necessary, but it may can avoid future trap\n        });\n\n        eventEmitter.on('timeout', () => {\n            clearContext(uuid);\n            reject({ 'error': 'timeout' });\n            return; // This `return` is not necessary, but it may can avoid future trap\n        });\n\n        emitters.set(uuid, {\n            emitter: eventEmitter,\n            timer: setTimeout(() => {\n                eventEmitter.emit('timeout');\n            }, timeout)\n        });\n\n        tlsSocket.write(packagedData);\n    });\n    return channelPromise;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\ntype RpcReq = (methodName: string, args: Array<any>) => any;\n\n/**\n * Information describing a cluster node\n *\n * @typedef {Object} NodeInfo\n * @property {string} bvmaddr Identity bvm address of the node\n * @property {string} kingnodeip cluster network address for the node\n * @property {string} txProcessIp transaction process address for the node (null if not available)\n * @property {string|null} rpc JSON RPC network address for the node (null if not available)\n */\ntype NodeInfo = {\n  bvmaddr: string,\n  kingnodeip: string,\n  txProcessIp: string | null,\n  rpc: string | null,\n};\n\n/**\n * Information describing a vote account\n *\n * @typedef {Object} VoteAccountInfo\n * @property {string} voteBvmAddr Bvm Address of the vote account\n * @property {string} nodeBvmAddr Identity Bvm Address of the node voting with this account\n * @property {string} stake The stake, in difs, delegated to this vote account\n * @property {string} commission A 32-bit integer used as a fraction (commission/0xFFFFFFFF) for rewards payout\n */\ntype VoteAccountInfo = {\n  voteBvmAddr: string,\n  nodeBvmAddr: string,\n  stake: number,\n  commission: number,\n};\n\nfunction createRpcReq(url): RpcReq {\n  const server = jayson(async (request, callback) => {\n    const options = {\n      method: 'POST',\n      body: request,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n\n    try {\n      const res = await fetch(url, options);\n      const text = await res.text();\n      callback(null, text);\n    } catch (err) {\n      callback(err);\n    }\n  });\n\n  return (method, args) => {\n    return new Promise((resolve, reject) => {\n      server.request(method, args, (err, response) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(response);\n      });\n    });\n  };\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\nclass ConfigurationError extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = 'ConfigurationError';\n    }\n}\n\nclass TransactionError extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = 'TransactionError';\n    }\n}\n\nclass PrecompiledError extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = 'PrecompiledError';\n    }\n}\n\nclass CompileError extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = 'CompileError';\n    }\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Expected JSON RPC response for the \"fetchAccountBalance\" message\n */\nconst FetchBalanceRpcResult = struct({\n  jsonrpc: struct.literal('2.0'),\n  id: 'string',\n  error: 'any?',\n  result: 'number?',\n});\n\nconst FetchReputationRpcResult = struct({\n  jsonrpc: struct.literal('2.0'),\n  id: 'string',\n  error: 'any?',\n  result: 'number?',\n});\n\n\n/**\n * @private\n */\nfunction jsonRpcResult(resultDescription: any) {\n  const jsonRpcVersion = struct.literal('2.0');\n  return struct.union([\n    struct({\n      jsonrpc: jsonRpcVersion,\n      id: 'string',\n      error: 'any',\n    }),\n    struct({\n      jsonrpc: jsonRpcVersion,\n      id: 'string',\n      error: 'null?',\n      result: resultDescription,\n    }),\n  ]);\n}\n\n/**\n * @private\n */\nconst AccountDetailResult = struct({\n  executable: 'boolean',\n  owner: 'array',\n  difs: 'number',\n  reputations: 'number',\n  data: 'array',\n});\n\n/**\n * Expected JSON RPC response for the \"fetchAccountDetail\" message\n */\nconst fetchAccountDetailRpcResult = jsonRpcResult(AccountDetailResult);\n\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */\nconst AccountNoticeResult = struct({\n  subscription: 'number',\n  result: AccountDetailResult,\n});\n\n/**\n * @private\n */\nconst ControllerAccountDetailResult = struct(['string', AccountDetailResult]);\n\n/***\n * Expected JSON RPC response for the \"controllerNotification\" message\n */\nconst ControllerAccountNoticeResult = struct({\n  subscription: 'number',\n  result: ControllerAccountDetailResult,\n});\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// const fs = require('fs');\nconst path = require('path');\nconst childProcess = require('child_process');\n// const assert = require('assert');\n// const events = require('events');\nconst abi = require('ethjs-abi');\n\nfunction selectNode(nodes) {\n    return nodes[Math.floor(Math.random() * nodes.length)];\n};\n\n\nfunction checkContractLength(bin) {\n    if (bin.length && bin.length <= 0x40000) {\n        return;\n    }\n    throw new CompileError(`contract bin size overflow, limit=0x40000(256K), size=${bin.length}`);\n}\n\nfunction checkContractError(errors) {\n    // Standard error types of solcjs\n    var solcErrors = [\n        'JSONError',\n        'IOError',\n        'ParserError',\n        'DocstringParsingError',\n        'SyntaxError',\n        'DeclarationError',\n        'TypeError',\n        'UnimplementedFeatureError',\n        'InternalCompilerError',\n        'Exception',\n        'CompilerError',\n        'FatalError'\n    ];\n\n    if (!errors) {\n        return;\n    } else {\n        let errorMsgs = [];\n        for (let error of errors) {\n            let [lineNo, level, msg] = error.split(': ');\n            if (solcErrors.includes(level)) {\n                errorMsgs.push(error);\n            }\n        }\n\n        if(errorMsgs.length !== 0) {\n            throw new CompileError(errorMsgs);\n        }\n        return;\n    }\n}\n\nfunction compileWithSolcJS(contractPath, outputDir) {\n    let contractName = path.basename(contractPath, '.sol');\n\n    let contractContent = fs.readFileSync(contractPath).toString();\n    let verReg = /pragma\\s+solidity\\s+\\^(.*)\\s*;/;\n    let ver = verReg.exec(contractContent)[1] || null;\n\n    let readCallback = (importContractName) => {\n        let importContractPath = path.join(path.dirname(contractPath), importContractName);\n        return { contents: fs.readFileSync(importContractPath).toString() };\n    };\n    let writeToFile = (abi, bin) => {\n        checkContractLength(bin);\n\n        if (typeof abi !== 'string') {\n            abi = JSON.stringify(abi);\n        }\n\n        if (typeof bin !== 'string') {\n            bin = JSON.stringify(bin);\n        }\n\n        let abiFileName = contractName + '.abi';\n        let binFileName = contractName + '.bin';\n\n        fs.writeFileSync(path.join(outputDir, abiFileName), abi);\n        fs.writeFileSync(path.join(outputDir, binFileName), bin);\n    };\n\n    let solc = null;\n    let output = null;\n    if (ver && ver.startsWith('0.5')) {\n        solc = require('./solc-0.5');\n        let input = {\n            language: \"Solidity\",\n            sources: {\n                [contractName]: {\n                    content: contractContent\n                }\n            },\n            settings: {\n                outputSelection: {\n                    '*': {\n                        '*': ['abi', 'evm.bytecode']\n                    }\n                }\n            }\n        };\n        output = JSON.parse(solc.compile(JSON.stringify(input), readCallback));\n        checkContractError(output.errors);\n\n        let abi = output.contracts[contractName][contractName].abi;\n        let bin = output.contracts[contractName][contractName].evm.bytecode.object;\n        writeToFile(abi, bin);\n    } else {\n        solc = require('./solc-0.4');\n        let input = {\n            sources: {\n                [contractName]: contractContent\n            }\n        };\n\n        output = solc.compile(input, 1, readCallback);\n        checkContractError(output.errors);\n\n        let abi = output.contracts[`${contractName}:${contractName}`].interface;\n        let bin = output.contracts[`${contractName}:${contractName}`].bytecode;\n        writeToFile(abi, bin);\n    }\n\n    return Promise.resolve();\n}\n\nfunction compileWithBin(outputDir, contractPath, solc) {\n    let execEmitter = new events.EventEmitter();\n    let execPromise = new Promise((resolve, reject) => {\n        execEmitter.on('done', () => {\n            resolve();\n        });\n        execEmitter.on('error', (stdout, stderr) => {\n            console.error(chalk.red(`Compiling error: ${stdout}\\n${stderr}`));\n            reject();\n        });\n    });\n\n    let cmd = `${solc} --overwrite --abi --bin -o ${outputDir} ${contractPath}`;\n    childProcess.exec(\n        cmd,\n        (error, stdout, stderr) => {\n            if (!error) {\n                execEmitter.emit('done');\n            }\n            else {\n                execEmitter.emit('error', stdout, stderr);\n            }\n        });\n\n    return execPromise.then(result => {\n        let contractName = path.basename(contractPath, '.sol');\n        let bin = fs.readFileSync(path.join(outputDir, contractName + '.bin'));\n        checkContractLength(bin);\n        return result;\n    });\n}\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Expected JSON RPC response for the \"confmTxn\" message\n */\nconst ConfmTxnRpcResult = jsonRpcResult('boolean');\n\n/**\n * Expected JSON RPC response for the \"fetchRoundLeader\" message\n */\nconst FetchRoundLeader = jsonRpcResult('string');\n\n/**\n * Expected JSON RPC response for the \"fetchClusterNodes\" message\n */\nconst GetClusterNodes = jsonRpcResult(\n  struct.list([\n    struct({\n      bvmaddr: 'string',\n      kingnodeip: 'string',\n      txProcessIp: struct.union(['null', 'string']),\n      rpc: struct.union(['null', 'string']),\n    }),\n  ]),\n);\n/**\n * @ignore\n */\nconst GetClusterNodes_tmp = jsonRpcResult(\n  struct.list([\n    struct({\n      id: 'string',\n      kingnodeip: 'string',\n      txProcessIp: struct.union(['null', 'string']),\n      rpc: struct.union(['null', 'string']),\n    }),\n  ]),\n);\n\n/**\n * Expected JSON RPC response for the \"getEpochVoteAccounts\" message\n */\nconst GetEpochVoteAccounts = jsonRpcResult(\n  struct.list([\n    struct({\n      voteBvmAddr: 'string',\n      nodeBvmAddr: 'string',\n      stake: 'number',\n      commission: 'number',\n    }),\n  ]),\n);\n\n/**\n * Expected JSON RPC response for the \"fetchSignatureState\" message\n */\nconst FetchSignatureStateRpcResult = jsonRpcResult(\n  struct.union([\n    'null',\n    struct.union([struct({Ok: 'null'}), struct({Err: 'object'})]),\n  ]),\n);\n\n/**\n * Expected JSON RPC response for the \"fetchTxnAmount\" message\n */\nconst FetchTxnAmountRpcResult = jsonRpcResult('number');\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////\nclass StatusCode {\n    static getStatusMessage(status) {\n        let message = '';\n        switch (status) {\n            case this.Success:\n                message = 'success';\n                break;\n            case this.Unknown:\n                message = 'unknown';\n                break;\n            case this.BadRLP:\n                message = 'bad RLP';\n                break;\n            case this.InvalidFormat:\n                message = 'invalid format';\n                break;\n            case this.OutOfGasIntrinsic:\n                message = 'out of gas intrinsic';\n                break;\n            case this.InvalidSignature:\n                message = 'invalid signature';\n                break;\n            case this.InvalidNonce:\n                message = 'invalid nonce';\n                break;\n            case this.NotEnoughCash:\n                message = 'not enough cash';\n                break;\n            case this.OutOfGasBase:\n                message = 'out of gas base';\n                break;\n            case this.BlockGasLimitReached:\n                message = 'block gas limit reached';\n                break;\n            case this.BadInstruction:\n                message = 'bad instruction';\n                break;\n            case this.BadJumpDestination:\n                message = 'bad jump destination';\n                break;\n            case this.OutOfGas:\n                message = 'out of gas';\n                break;\n            case this.OutOfStack:\n                message = 'out of stack';\n                break;\n            case this.StackUnderflow:\n                message = 'stack underflow';\n                break;\n            case this.NonceCheckFail:\n                message = 'nonce check fail';\n                break;\n            case this.BlockLimitCheckFail:\n                message = 'block limit check fail';\n                break;\n            case this.FilterCheckFail:\n                message = 'filter check fail';\n                break;\n            case this.NoDeployPermission:\n                message = 'no deploy permission';\n                break;\n            case this.NoCallPermission:\n                message = 'no call permission';\n                break;\n            case this.NoTxPermission:\n                message = 'no tx permission';\n                break;\n            case this.PrecompiledError:\n                message = 'precompiled error';\n                break;\n            case this.RevertInstruction:\n                message = 'revert instruction';\n                break;\n            case this.InvalidZeroSignatureFormat:\n                message = 'invalid zero signature format';\n                break;\n            case this.AddressAlreadyUsed:\n                message = 'address already used';\n                break;\n            case this.PermissionDenied:\n                message = 'permission denied';\n                break;\n            case this.CallAddressError:\n                message = 'call address error';\n                break;\n            default:\n                message = `unknown status code:${status}`;\n                break;\n        }\n\n        return message;\n    }\n}\n\nStatusCode.Success = '0x0';\nStatusCode.Unknown = '0x1';\nStatusCode.BadRLP = '0x2';\nStatusCode.InvalidFormat = '0x3';\nStatusCode.OutOfGasIntrinsic = '0x4';\nStatusCode.InvalidSignature = '0x5';\nStatusCode.InvalidNonce = '0x6';\nStatusCode.NotEnoughCash = '0x7';\nStatusCode.OutOfGasBase = '0x8';\nStatusCode.BlockGasLimitReached = '0x9';\nStatusCode.BadInstruction = '0xa';\nStatusCode.BadJumpDestination = '0xb';\nStatusCode.OutOfGas = '0xc';\nStatusCode.OutOfStack = '0xd';\nStatusCode.StackUnderflow = '0xe';\nStatusCode.NonceCheckFail = '0xf';\nStatusCode.BlockLimitCheckFail = '0x10';\nStatusCode.FilterCheckFail = '0x11';\nStatusCode.NoDeployPermission = '0x12';\nStatusCode.NoCallPermission = '0x13';\nStatusCode.NoTxPermission = '0x14';\nStatusCode.PrecompiledError = '0x15';\nStatusCode.RevertInstruction = '0x16';\nStatusCode.InvalidZeroSignatureFormat = '0x17';\nStatusCode.AddressAlreadyUsed = '0x18';\nStatusCode.PermissionDenied = '0x19';\nStatusCode.CallAddressError = '0x1a';\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Expected JSON RPC response for the \"getTotalSupply\" message\n */\nconst GetTotalSupplyRpcResult = jsonRpcResult('number');\n\n/**\n * Expected JSON RPC response for the \"fetchRecentBlockhash\" message\n */\nconst FetchRecentBlockhash = jsonRpcResult([\n  'string',\n  struct({\n    difsPerSignature: 'number',\n    maxDifsPerSignature: 'number',\n    minDifsPerSignature: 'number',\n    targetDifsPerSignature: 'number',\n    targetSignaturesPerSlot: 'number',\n  }),\n]);\n/**\n * @ignore\n */\nconst GetRecentBlockhash_015 = jsonRpcResult([\n  'string',\n  struct({\n    difsPerSignature: 'number',\n  }),\n]);\n\n/**\n * Expected JSON RPC response for the \"reqDrone\" message\n */\nconst ReqDroneRpcResult = jsonRpcResult('string');\n\n/**\n * Expected JSON RPC response for the \"reqReputation\" message\n */\nconst ReqReputationRpcResult = jsonRpcResult('string');\n\n/**\n * Expected JSON RPC response for the \"sendTxn\" message\n */\nconst SendTxnRpcResult = jsonRpcResult('string');\n\n/**\n * Information describing an account\n *\n * @typedef {Object} AccountDetail\n * @property {number} difs Number of difs assigned to the account\n * @property {BvmAddr} owner Identifier of the controller that owns the account\n * @property {?Buffer} data Optional data assigned to the account\n * @property {boolean} executable `true` if this account's data contains a loaded controller\n */\ntype AccountDetail = {\n  executable: boolean,\n  owner: BvmAddr,\n  difs: number,\n  reputations: number,\n  data: Buffer,\n};\n\n/**\n * BvmAcct information identified by pubkey\n *\n * @typedef {Object} KeyedAccountDetail\n * @property {BvmAddr} accountId\n * @property {AccountDetail} fetchAccountDetail\n */\ntype KeyedAccountDetail = {\n  accountId: BvmAddr,\n  fetchAccountDetail: AccountDetail,\n};\n\n/**\n * Callback function for account change notifications\n */\nexport type AccountChangeCallback = (fetchAccountDetail: AccountDetail) => void;\n\n/**\n * @private\n */\ntype AccountSubscriptionDetail = {\n  pubKey: string, // BvmAddr of the account as a base 58 string\n  callback: AccountChangeCallback,\n  subscriptionId: null | number, // null when there's no current server subscription id\n};\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\nconst secp256k1 = require('secp256k1');\n// const cryptoJSSha3 = require('crypto-js/sha3');\nconst keccak = require('keccak');\n// const assert = require('assert');\nconst rlp = require('rlp');\nconst coder = require('web3-eth-abi');\nconst ethjsUtil = require('ethjs-util');\nconst encryptType = 0;\n\n/**\n * Convert data to Buffer\n * @param {any} data data to be transformed to buffer\n * @return {Buffer} transformation result\n */\nfunction toBuffer(data) {\n    if (!Buffer.isBuffer(data)) {\n        if (Array.isArray(data)) {\n            data = Buffer.from(data);\n        } else if (typeof data === 'string') {\n            if (ethjsUtil.isHexPrefixed(data)) {\n                data = Buffer.from(ethjsUtil.padToEven(ethjsUtil.stripHexPrefix(data)), 'hex');\n            } else {\n                data = Buffer.from(data, 'hex');\n            }\n        } else if (Number.isInteger(data)) {\n            data = ethjsUtil.intToBuffer(data);\n        } else if (data === null || data === undefined) {\n            data = Buffer.allocUnsafe(0);\n        } else if (data.toArray) {\n            data = Buffer.from(data.toArray());\n        } else {\n            throw new Error('invalid type');\n        }\n    }\n    return data;\n}\n\n/**\n * Calculate hash of data\n * @param {any} data data\n * @param {int} bits length of hash\n * @return {Buffer} hash of data\n */\nfunction sha3(data, bits) {\n    if (encryptType === 0) {\n        data = toBuffer(data);\n        if (!bits) {\n            bits = 256;\n        }\n        let digestData = keccak('keccak' + bits).update(data).digest();\n        return digestData;\n    } else {\n        throw new Error('Unsupported type of encryption');\n    }\n}\n\n/**\n * Calculate bvm address from private key\n * @param {Buffer} privateKey A private key must be 256 bits wide\n * @return {Buffer} bvm address\n */\nfunction privateKeyToPublicKey(privateKey) {\n    if (encryptType === 0) {\n        privateKey = toBuffer(privateKey);\n        let publicKey = secp256k1.publicKeyCreate(privateKey, false).slice(1);\n        return publicKey;\n    } else {\n        throw new Error('Unsupported type of encryption');\n    }\n}\n\n/**\n * Calculate address from bvm address\n * @param {Buffer} publicKey bvm address\n * @param {bool} sanitize whether to sanitize publicKey\n * @return {Buffer} address\n */\nfunction publicKeyToAddress(publicKey, sanitize = false) {\n    if (encryptType === 0) {\n        if (sanitize && (publicKey.length !== 64)) {\n            publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\n        }\n        assert(publicKey.length === 64);\n    }\n    // Only take the lower 160bits of the hash as address\n    return sha3(publicKey).slice(-20);\n}\n\n/**\n * Calculate address from private key\n * @param {Buffer} privateKey private key\n * @return {Buffer} address\n */\nfunction privateKeyToAddress(privateKey) {\n    return publicKeyToAddress(privateKeyToPublicKey(privateKey));\n}\n\n/**\n * Allocate a zero-filled buffer\n * @param {Number} length the length of buffer\n * @return {Buffer} buffer\n */\nfunction zeros(length) {\n    return Buffer.allocUnsafe(length).fill(0);\n}\n\nfunction setLength(msg, length, right) {\n    let buf = zeros(length);\n    msg = toBuffer(msg);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    } else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n}\n\n/**\n * Recover bvm address from (v, r, s)\n * @param {String} msgHash message hash\n * @param {String} v v\n * @param {String} r r\n * @param {String} s s\n * @return {String} bvm address recovered from (v, r, s)\n */\nfunction ecrecover(msgHash, v, r, s) {\n    let signature = Buffer.concat([setLength(r, 32), setLength(s, 32)], 64);\n    let recovery = v - 27;\n    if (recovery !== 0 && recovery !== 1) {\n        throw new Error('Invalid signature v value');\n    }\n    let senderPubickKey = secp256k1.recover(msgHash, signature, recovery);\n    return secp256k1.publicKeyConvert(senderPubickKey, false).slice(1);\n}\n\n/**\n * Create sign data\n * @param {String} msgHash message hash\n * @param {String} privateKey private key\n * @return {Object} returns (v, r, s) for secp256k1\n */\nfunction ecsign(msgHash, privateKey) {\n    let ret = {};\n    if (encryptType === 0) {\n        let sig = secp256k1.sign(msgHash, privateKey);\n        ret.r = sig.signature.slice(0, 32);\n        ret.s = sig.signature.slice(32, 64);\n        ret.v = sig.recovery + 27;\n    } else {\n        throw new Error('Unsupported type of encryption');\n    }\n    return ret;\n}\n\n/**\n * Calcuate hash of RLP data\n * @param {rlp} data RLP data\n * @return {String} the hash of data\n */\nfunction rlphash(data) {\n    return sha3(rlp.encode(data));\n}\n\n/**\n * encode params\n * @param {Array} types types\n * @param {Array} params params\n * @return {Buffer} params' code\n */\nfunction encodeParams(types, params) {\n    let ret = coder.encodeParameters(types, params);\n    return ret;\n}\n\n/**\n * decode params\n * @param {Array} types types\n * @param {Buffer} bytes params' code\n * @return {Array} params\n */\nfunction decodeParams(types, bytes) {\n    let ret = coder.decodeParameters(types, bytes);\n    return ret;\n}\n\n/**\n * encode function name\n * @param {String} fcn function name\n * @return {Buffer} function name's code\n */\nfunction encodeFunctionName(fcn) {\n    let digest = null;\n    if (encryptType === 1) {\n        digest = sha3(fcn, 256).toString('hex');\n    } else {\n    //     digest = cryptoJSSha3(fcn, {\n    //         outputLength: 256\n    //     }).toString();\n    }\n    let ret = '0x' + digest.slice(0, 8);\n    return ret;\n}\n\n/**\n * encode transaction data\n * @param {String} fcn function name\n * @param {Array} types types\n * @param {Array} params params\n * @return {Buffer} tx data's code\n */\nfunction encodeTxData(fcn, types, params) {\n    let txDataCode = encodeFunctionName(fcn);\n    let paramsCode = encodeParams(types, params);\n    txDataCode += ethjsUtil.stripHexPrefix(paramsCode);\n    return txDataCode;\n}\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Callback function for controller account change notifications\n */\nexport type ControllerAccountChangeCallback = (\n  keyedAccountDetail: KeyedAccountDetail,\n) => void;\n\n/**\n * @private\n */\ntype ControllerAccountSubscriptionDetail = {\n  controllerId: string, // BvmAddr of the controller as a base 58 string\n  callback: ControllerAccountChangeCallback,\n  subscriptionId: null | number, // null when there's no current server subscription id\n};\n\n/**\n * Signature status: Success\n *\n * @typedef {Object} SignaturePass\n */\nexport type SignaturePass = {|\n  Ok: null,\n|};\n\n/**\n * Signature status: TxnErr\n *\n * @typedef {Object} TxnErr\n */\nexport type TxnErr = {|\n  Err: Object,\n|};\n\n/**\n * @ignore\n */\ntype BlockhashAndGasCounter = [Blockhash, GasCounter]; // This type exists to workaround an esdoc parse error\n\n/**\n * A connection to a fullnode JSON RPC endpoint\n */\nexport class Connection {\n  _rpcReq: RpcReq;\n  _rpcWebSock: RpcWebSocketClient;\n  _rpcWebSockConnected: boolean = false;\n\n  _blockhashInfo: {\n    recentPackagehash: Blockhash | null,\n    seconds: number,\n    transactionSignatures: Array<string>,\n  };\n  _disableBlockhashCaching: boolean = false;\n  _accountChangeSubscriptions: {[number]: AccountSubscriptionDetail} = {};\n  _accountChangeSubscriptionCounter: number = 0;\n  _controllerAccountChangeSubscriptions: {\n    [number]: ControllerAccountSubscriptionDetail,\n  } = {};\n  _controllerAccountChangeSubscriptionCounter: number = 0;\n\n  /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   */\n  constructor(endpoint: string) {\n    let url = urlParse(endpoint);\n\n    this._rpcReq = createRpcReq(url.href);\n    this._blockhashInfo = {\n      recentPackagehash: null,\n      seconds: -1,\n      transactionSignatures: [],\n    };\n\n    url.protocol = url.protocol === 'https:' ? 'wss:' : 'ws:';\n    url.host = '';\n    url.port = String(Number(url.port) + 1);\n    if (url.port === '1') {\n      url.port = url.protocol === 'wss:' ? '8901' : '8900';\n    }\n    this._rpcWebSock = new RpcWebSocketClient(urlFormat(url), {\n      autoconnect: false,\n      max_reconnects: Infinity,\n    });\n    this._rpcWebSock.on('open', this._wsOnOpen.bind(this));\n    this._rpcWebSock.on('error', this._wsOnErr.bind(this));\n    this._rpcWebSock.on('close', this._wsOnClose.bind(this));\n    this._rpcWebSock.on(\n      'accountNotification',\n      this._wsOnAccountNotice.bind(this),\n    );\n    this._rpcWebSock.on(\n      'controllerNotification',\n      this._wsOnProgramAccountNotification.bind(this),\n    );\n  }\n\n  /**\n   * Fetch the balance for the specified bvm address\n   */\n  async fetchAccountBalance(pubKey: BvmAddr): Promise<number> {\n    const unsafeRes = await this._rpcReq('getDif', [\n      pubKey.converseToBase58(),\n    ]);\n    const res = FetchBalanceRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  async fetchAccountReputation(pubKey: BvmAddr): Promise<number> {\n    const unsafeRes = await this._rpcReq('getReputation', [\n      pubKey.converseToBase58(),\n    ]);\n    const res = FetchReputationRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Fetch all the account info for the specified bvm address\n   */\n  async fetchAccountDetail(pubKey: BvmAddr): Promise<AccountDetail> {\n    const unsafeRes = await this._rpcReq('getAccountInfo', [\n      pubKey.converseToBase58(),\n    ]);\n    const res = fetchAccountDetailRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n\n    const {result} = res;\n    assert(typeof result !== 'undefined');\n\n    return {\n      executable: result.executable,\n      owner: new BvmAddr(result.owner),\n      difs: result.difs,\n      reputations: result.reputations,\n      data: Buffer.from(result.data),\n    };\n  }\n\n  /**\n   * Confirm the transaction identified by the specified signature\n   */\n  async confmTxn(signature: TxnSignature): Promise<boolean> {\n    const unsafeRes = await this._rpcReq('confirmTxn', [signature]);\n    const res = ConfmTxnRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Return the list of nodes that are currently participating in the cluster\n   */\n  async fetchClusterNodes(): Promise<Array<NodeInfo>> {\n    const unsafeRes = await this._rpcReq('getClusterNodes', []);\n\n    try {\n      const res_tmp = GetClusterNodes_tmp(unsafeRes);\n      if (res_tmp.error) {\n        console.log('no', res_tmp.error);\n        throw new Error(res_tmp.error.message);\n      }\n      return res_tmp.result.map(node => {\n        node.bvmaddr = node.id;\n        node.id = undefined;\n        return node;\n      });\n    } catch (e) {\n      // Not legacy format\n    }\n    // End Legacy v0.15 response\n\n    const res = GetClusterNodes(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Return the list of nodes that are currently participating in the cluster\n   */\n  async getEpochVoteAccounts(): Promise<Array<VoteAccountInfo>> {\n    const unsafeRes = await this._rpcReq('getEpochVoteAccounts', []);\n    const res = GetEpochVoteAccounts(unsafeRes);\n    //const res = unsafeRes;\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Fetch the current slot leader of the cluster\n   */\n  async fetchRoundLeader(): Promise<string> {\n    const unsafeRes = await this._rpcReq('getRoundLeader', []);\n    const res = FetchRoundLeader(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Fetch the current transaction count of the cluster\n   */\n  async fetchSignatureState(\n    signature: TxnSignature,\n  ): Promise<SignaturePass | TxnErr | null> {\n    const unsafeRes = await this._rpcReq('getSignatureState', [signature]);\n    const res = FetchSignatureStateRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Fetch the current transaction count of the cluster\n   */\n  async fetchTxnAmount(): Promise<number> {\n    const unsafeRes = await this._rpcReq('getTxnCnt', []);\n    const res = FetchTxnAmountRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return Number(res.result);\n  }\n\n  /**\n   * Fetch the current total currency supply of the cluster\n   */\n  async getTotalSupply(): Promise<number> {\n    const unsafeRes = await this._rpcReq('getTotalSupply', []);\n    const res = GetTotalSupplyRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return Number(res.result);\n  }\n\n  /**\n   * Fetch a recent blockhash from the cluster\n   */\n  async fetchRecentBlockhash(): Promise<BlockhashAndGasCounter> {\n    const unsafeRes = await this._rpcReq('getLatestTransactionSeal', []);\n\n    try {\n      const res_tmp = GetRecentBlockhash_015(unsafeRes);\n      if (res_tmp.error) {\n        throw new Error(res_tmp.error.message);\n      }\n      const [blockhash, gasCounter] = res_tmp.result;\n      gasCounter.targetSignaturesPerSlot = 42;\n      gasCounter.targetDifsPerSignature =\n        gasCounter.difsPerSignature;\n\n      return [blockhash, gasCounter];\n    } catch (e) {\n      // Not legacy format\n    }\n    // End Legacy v0.15 response\n\n    const res = FetchRecentBlockhash(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Request an allocation of difs to the specified account\n   */\n  async reqDrone(\n    to: BvmAddr,\n    amount: number,\n  ): Promise<TxnSignature> {\n    const unsafeRes = await this._rpcReq('requestDif', [\n      to.converseToBase58(),\n      amount,\n    ]);\n    const res = ReqDroneRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n    /**\n   * Request an allocation of reputations to the specified account\n   */\n  async reqReputation(\n    to: BvmAddr,\n    amount: number,\n  ): Promise<TxnSignature> {\n    const unsafeRes = await this._rpcReq('requestReputation', [\n      to.converseToBase58(),\n      amount,\n    ]);\n    const res = ReqReputationRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Sign and send a transaction\n   */\n  async sendTxn(\n    transaction: Transaction,\n    ...signers: Array<BvmAcct>\n  ): Promise<TxnSignature> {\n    for (;;) {\n      // Attempt to use a recent blockhash for up to 30 seconds\n      const seconds = new Date().getSeconds();\n      if (\n        this._blockhashInfo.recentPackagehash != null &&\n        this._blockhashInfo.seconds < seconds + 30\n      ) {\n        transaction.recentPackagehash = this._blockhashInfo.recentPackagehash;\n        transaction.signTx(...signers);\n        if (!transaction.signature) {\n          throw new Error('!signature'); // should never happen\n        }\n\n        // If the signature of this transaction has not been seen before with the\n        // current recentPackagehash, all done.\n        const signature = transaction.signature.toString();\n        if (!this._blockhashInfo.transactionSignatures.includes(signature)) {\n          this._blockhashInfo.transactionSignatures.push(signature);\n          if (this._disableBlockhashCaching) {\n            this._blockhashInfo.seconds = -1;\n          }\n          break;\n        }\n      }\n\n      // Fetch a new blockhash\n      let attempts = 0;\n      const startTime = Date.now();\n      for (;;) {\n        const [\n          recentPackagehash,\n          //gasCounter,\n        ] = await this.fetchRecentBlockhash();\n\n        if (this._blockhashInfo.recentPackagehash != recentPackagehash) {\n          this._blockhashInfo = {\n            recentPackagehash,\n            seconds: new Date().getSeconds(),\n            transactionSignatures: [],\n          };\n          break;\n        }\n        if (attempts === 50) {\n          throw new Error(\n            `Unable to obtain a new blockhash after ${Date.now() -\n              startTime}ms`,\n          );\n        }\n\n        // dormant for approximately half a slot\n        await dormant((500 * DEFAULT_TICKS_PER_SLOT) / NUM_TICKS_PER_SEC);\n\n        ++attempts;\n      }\n    }\n\n    const wireTransaction = transaction.serialize();\n    return await this.sendNativeTxn(wireTransaction);\n  }\n\n  /**\n   * @private\n   */\n  async fullnodeExit(): Promise<boolean> {\n    const unsafeRes = await this._rpcReq('fullnodeQuit', []);\n    const res = jsonRpcResult('boolean')(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Send a transaction that has already been signed and serialized into the\n   * wire format\n   */\n  async sendNativeTxn(\n    rawTransaction: Buffer,\n  ): Promise<TxnSignature> {\n    const unsafeRes = await this._rpcReq('sendTxn', [\n      [...rawTransaction],\n    ]);\n    const res = SendTxnRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    assert(res.result);\n    return res.result;\n  }\n\n  /**\n   * @private\n   */\n  _wsOnOpen() {\n    this._rpcWebSockConnected = true;\n    this._updateSubscriptions();\n  }\n\n  /**\n   * @private\n   */\n  _wsOnErr(err: Error) {\n    console.log('ws error:', err.message);\n  }\n\n  /**\n   * @private\n   */\n  _wsOnClose(code: number, message: string) {\n    // 1000 means _rpcWebSock.close() was called explicitly\n    if (code !== 1000) {\n      console.log('ws close:', code, message);\n    }\n    this._rpcWebSockConnected = false;\n  }\n\n  /**\n   * @private\n   */\n  async _updateSubscriptions() {\n    const accountKeys = Object.keys(this._accountChangeSubscriptions).map(\n      Number,\n    );\n    const programKeys = Object.keys(\n      this._controllerAccountChangeSubscriptions,\n    ).map(Number);\n    if (accountKeys.length === 0 && programKeys.length === 0) {\n      this._rpcWebSock.close();\n      return;\n    }\n\n    if (!this._rpcWebSockConnected) {\n      for (let id of accountKeys) {\n        this._accountChangeSubscriptions[id].subscriptionId = null;\n      }\n      for (let id of programKeys) {\n        this._controllerAccountChangeSubscriptions[id].subscriptionId = null;\n      }\n      this._rpcWebSock.connect();\n      return;\n    }\n\n    for (let id of accountKeys) {\n      const {subscriptionId, pubKey} = this._accountChangeSubscriptions[id];\n      if (subscriptionId === null) {\n        try {\n          this._accountChangeSubscriptions[\n            id\n          ].subscriptionId = await this._rpcWebSock.call('accountSubscribe', [\n            pubKey,\n          ]);\n        } catch (err) {\n          console.log(\n            `accountSubscribe error for ${pubKey}: ${err.message}`,\n          );\n        }\n      }\n    }\n    for (let id of programKeys) {\n      const {\n        subscriptionId,\n        controllerId,\n      } = this._controllerAccountChangeSubscriptions[id];\n      if (subscriptionId === null) {\n        try {\n          this._controllerAccountChangeSubscriptions[\n            id\n          ].subscriptionId = await this._rpcWebSock.call('programSubscribe', [\n            controllerId,\n          ]);\n        } catch (err) {\n          console.log(\n            `programSubscribe error for ${controllerId}: ${err.message}`,\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  _wsOnAccountNotice(notification: Object) {\n    const res = AccountNoticeResult(notification);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n\n    const keys = Object.keys(this._accountChangeSubscriptions).map(Number);\n    for (let id of keys) {\n      const sub = this._accountChangeSubscriptions[id];\n      if (sub.subscriptionId === res.subscription) {\n        const {result} = res;\n        assert(typeof result !== 'undefined');\n\n        sub.callback({\n          executable: result.executable,\n          owner: new BvmAddr(result.owner),\n          difs: result.difs,\n          reputations: result.reputations,\n          data: Buffer.from(result.data),\n        });\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Register a callback to be invoked whenever the specified account changes\n   *\n   * @param publickey Bvm Address of the account to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @return subscription id\n   */\n  onAccountChange(\n    pubKey: BvmAddr,\n    callback: AccountChangeCallback,\n  ): number {\n    const id = ++this._accountChangeSubscriptionCounter;\n    this._accountChangeSubscriptions[id] = {\n      pubKey: pubKey.converseToBase58(),\n      callback,\n      subscriptionId: null,\n    };\n    this._updateSubscriptions();\n    return id;\n  }\n\n  /**\n   * Deregister an account notification callback\n   *\n   * @param id subscription id to deregister\n   */\n  async removeListenerOfAccountChange(id: number): Promise<void> {\n    if (this._accountChangeSubscriptions[id]) {\n      const {subscriptionId} = this._accountChangeSubscriptions[id];\n      delete this._accountChangeSubscriptions[id];\n      if (subscriptionId !== null) {\n        try {\n          await this._rpcWebSock.call('accountUnsubscribe', [subscriptionId]);\n        } catch (err) {\n          console.log('accountUnsubscribe error:', err.message);\n        }\n      }\n      this._updateSubscriptions();\n    } else {\n      throw new Error(`Unknown account change id: ${id}`);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _wsOnProgramAccountNotification(notification: Object) {\n    const res = ControllerAccountNoticeResult(notification);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n\n    const keys = Object.keys(this._controllerAccountChangeSubscriptions).map(\n      Number,\n    );\n    for (let id of keys) {\n      const sub = this._controllerAccountChangeSubscriptions[id];\n      if (sub.subscriptionId === res.subscription) {\n        const {result} = res;\n        assert(typeof result !== 'undefined');\n\n        sub.callback({\n          accountId: result[0],\n          fetchAccountDetail: {\n            executable: result[1].executable,\n            owner: new BvmAddr(result[1].owner),\n            difs: result[1].difs,\n            reputations: result[1].reputations,\n            data: Buffer.from(result[1].data),\n          },\n        });\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Register a callback to be invoked whenever accounts owned by the\n   * specified controller change\n   *\n   * @param controllerId Bvm Address of the controller to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @return subscription id\n   */\n  onControllerAccountChange(\n    controllerId: BvmAddr,\n    callback: ControllerAccountChangeCallback,\n  ): number {\n    const id = ++this._controllerAccountChangeSubscriptionCounter;\n    this._controllerAccountChangeSubscriptions[id] = {\n      controllerId: controllerId.converseToBase58(),\n      callback,\n      subscriptionId: null,\n    };\n    this._updateSubscriptions();\n    return id;\n  }\n\n  /**\n   * Deregister an account notification callback\n   *\n   * @param id subscription id to deregister\n   */\n  async removeControllerAccountChangeListener(id: number): Promise<void> {\n    if (this._controllerAccountChangeSubscriptions[id]) {\n      const {subscriptionId} = this._controllerAccountChangeSubscriptions[id];\n      delete this._controllerAccountChangeSubscriptions[id];\n      if (subscriptionId !== null) {\n        try {\n          await this._rpcWebSock.call('programUnsubscribe', [subscriptionId]);\n        } catch (err) {\n          console.log('programUnsubscribe error:', err.message);\n        }\n      }\n      this._updateSubscriptions();\n    } else {\n      throw new Error(`Unknown account change id: ${id}`);\n    }\n  }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// let utils = require('./utils');\n// const encryptType = 2;\n// const ethjsUtil = require('ethereumjs-util');\nconst BN = ethjsUtil.BN;\n\n/**\n * Constructor of transaction\n * @param {data} data transaction data\n */\n// function Transaction(data) {\n//     data = data || {};\n//     let fields = null;\n\n//     if (encryptType === 1) {\n//         fields = [{\n//             name: 'randomid',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'gasPrice',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'gasLimit',\n//             alias: 'gas',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'blockLimit',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'to',\n//             allowZero: true,\n//             length: 20,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'value',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'data',\n//             alias: 'input',\n//             allowZero: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'pub',\n//             length: 64,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'r',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 's',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }];\n//     } else {\n//         fields = [{\n//             name: 'randomid',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'gasPrice',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'gasLimit',\n//             alias: 'gas',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'blockLimit',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'to',\n//             allowZero: true,\n//             length: 20,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'value',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'data',\n//             alias: 'input',\n//             allowZero: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'chainId',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'groupId',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'extraData',\n//             allowZero: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'v',\n//             length: 1,\n//             default: Buffer.from([0x1c])\n//         }, {\n//             name: 'r',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 's',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }];\n//     }\n\n//     ethjsUtil.defineProperties(this, fields, data);\n\n//     /*\n//     Object.defineProperty(this, 'from', {\n//         enumerable: true,\n//         configurable: true,\n//         get: this.getSenderAddress.bind(this)\n//     });\n//     */\n\n//     let sigV = ethjsUtil.bufferToInt(this.v);\n//     let chainId = Math.floor((sigV - 35) / 2);\n//     if (chainId < 0) {\n//         chainId = 0;\n//     }\n\n//     this._chainId = chainId || data.chainId || 0;\n//     this._homestead = true;\n// }\n\n/**\n * If the tx's `to` is to the creation address\n * @return {Boolean} returns `true` if tx is to to the creation address, otherwise returns `false`\n */\nfunction toCreationAddress() {\n    return this.to.toString('hex') === '';\n}\n\n/**\n * Computes a sha3-256 hash of the serialized tx\n * @param {Boolean} [includeSignature=true] whether or not to inculde the signature\n * @return {Buffer} a sha3-256 hash of the serialized tx\n */\nfunction hash(includeSignature) {\n    if (includeSignature === undefined) {\n        includeSignature = true;\n    }\n    // backup original signature\n    const rawCopy = this.raw.slice(0);\n\n    // generate rlp params for hash\n    let txRawForHash = includeSignature ? this.raw : this.raw.slice(0, this.raw.length - 3);\n    //var txRawForHash = includeSignature ? this.raw : this.raw.slice(0, 7)\n\n    // restore original signature\n    this.raw = rawCopy.slice();\n\n    // create hash\n    return rlphash(txRawForHash);\n}\n\n/**\n * returns the chain ID\n * @return {Number} chain ID\n */\nfunction getChainId() {\n    return this._chainId;\n}\n\n/**\n * returns the sender's address\n * @return {Buffer} sender's address\n */\nfunction getSenderAddress() {\n    if (this._from) {\n        return this._from;\n    }\n    const pubkey = this.getSenderPublicKey();\n    this._from = ethjsUtil.publicToAddress(pubkey);\n    return this._from;\n}\n\n/**\n * returns the bvm address of the sender\n * @return {Buffer} the bvm address of the sender\n */\nfunction getSenderPublicKey() {\n    if (!this._senderPubKey || !this._senderPubKey.length) {\n        if (!this.verifySignature()) {\n            throw new Error('Invalid Signature');\n        }\n    }\n    return this._senderPubKey;\n}\n\n/**\n * Determines if the signature is valid\n * @return {Boolean} whether the signature is valid\n */\nfunction verifySignature() {\n    let SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);\n    const msgHash = this.hash(false);\n    // All transaction signatures whose s-value is greater than secp256k1n/2 are considered invalid.\n    if (this._homestead && new BN(this.s).cmp(SECP256K1_N_DIV_2) === 1) {\n        return false;\n    }\n\n    try {\n        let v = ethjsUtil.bufferToInt(this.v);\n        this._senderPubKey = ecrecover(msgHash, v, this.r, this.s);\n    } catch (e) {\n        console.error(e.stack);\n        return false;\n    }\n\n    return !!this._senderPubKey;\n}\n\n/**\n * sign a transaction with a given private key\n * @param {Buffer} privateKey private key\n */\nfunction sign(privateKey) {\n    const msgHash = this.hash(false);\n    const sig = ecsign(msgHash, privateKey);\n    Object.assign(this, sig);\n}\n\n/**\n * the up front amount that an account must have for this transaction to be valid\n * @return {BN} up front amount\n */\nfunction getUpfrontCost() {\n    return new BN(this.gasLimit)\n        .imul(new BN(this.gasPrice))\n        .iadd(new BN(this.value));\n}\n\n/**\n * validates the signature and checks to see if it has enough gas\n * @param {Boolean} [stringError=false] whether to return a string with a dscription of why the validation failed or return a Bloolean\n * @return {Boolean|String} validation result\n */\nfunction validate(stringError) {\n    const errors = [];\n    if (!this.verifySignature()) {\n        errors.push('Invalid Signature');\n    }\n\n    if (this.getBaseFee().cmp(new BN(this.gasLimit)) > 0) {\n        errors.push([`gas limit is to low. Need at least ${this.getBaseFee()}`]);\n    }\n\n    if (stringError === undefined || stringError === false) {\n        return errors.length === 0;\n    } else {\n        return errors.join(' ');\n    }\n}\n////////////////////////////////////////////////////////////////////////////////////////////////////////////","// @flow\n\n\n\nvar util = require('util');\nvar _ = require('underscore');\nvar _str = require('underscore.string');\n\n// var RpcCall = require('../rpc-call').RpcCall;\nimport RpcCall from './rpc-call';\nimport { stat } from 'fs';\n\nvar _ = require('underscore');\nvar _str = require('underscore.string');\nvar Socket = require('net').Socket;\nvar format = require('util').format;\n\nimport invariant from 'assert';\n\nimport {Connection} from './netutility';\nimport {Transaction} from './tx-dapp';\nimport {dormant} from './dormant';\nimport type {BvmAcct} from './bvm-acct';\nimport type {TxnSignature} from './tx-dapp';\nimport {DEFAULT_TICKS_PER_SLOT, NUM_TICKS_PER_SEC} from './timing';\n\nvar PREFIX = '[XWB]';\nvar RPC_VERSION = '1.108';\n\nvar NUL = '\\u0000';\nvar SOH = '\\u0001';\nvar EOT = '\\u0004';\nvar ENQ = '\\u0005';\n\nvar CIPHER_PAD = [\n    'wkEo-ZJt!dG)49K{nX1BS$vH<&:Myf*>Ae0jQW=;|#PsO`\\'%+rmb[gpqN,l6/hFC@DcUa ]z~R}\"V\\\\iIxu?872.(TYL5_3',\n    'rKv`R;M/9BqAF%&tSs#Vh)dO1DZP> *fX\\'u[.4lY=-mg_ci802N7LTG<]!CWo:3?{+,5Q}(@jaExn$~p\\\\IyHwzU\"|k6Jeb',\n    '\\\\pV(ZJk\"WQmCn!Y,y@1d+~8s?[lNMxgHEt=uw|X:qSLjAI*}6zoF{T3#;ca)/h5%`P4$r]G\\'9e2if_>UDKb7<v0&- RBO.',\n    'depjt3g4W)qD0V~NJar\\\\B \"?OYhcu[<Ms%Z`RIL_6:]AX-zG.#}$@vk7/5x&*m;(yb2Fn+l\\'PwUof1K{9,|EQi>H=CT8S!',\n    'NZW:1}K$byP;jk)7\\'`x90B|cq@iSsEnu,(l-hf.&Y_?J#R]+voQXU8mrV[!p4tg~OMez CAaGFD6H53%L/dT2<*>\"{\\\\wI=',\n    'vCiJ<oZ9|phXVNn)m K`t/SI%]A5qOWe\\\\&?;jT~M!fz1l>[D_0xR32c*4.P\"G{r7}E8wUgyudF+6-:B=$(sY,LkbHa#\\'@Q',\n    'hvMX,\\'4Ty;[a8/{6l~F_V\"}qLI\\\\!@x(D7bRmUH]W15J%N0BYPkrs&9:$)Zj>u|zwQ=ieC-oGA.#?tfdcO3gp`S+En K2*<',\n    'jd!W5[];4\\'<C$/&x|rZ(k{>?ghBzIFN}fAK\"#`p_TqtD*1E37XGVs@0nmSe+Y6Qyo-aUu%i8c=H2vJ\\\\) R:MLb.9,wlO~P',\n    '2ThtjEM+!=xXb)7,ZV{*ci3\"8@_l-HS69L>]\\\\AUF/Q%:qD?1~m(yvO0e\\'<#o$p4dnIzKP|`NrkaGg.ufCRB[; sJYwW}5&',\n    'vB\\\\5/zl-9y:Pj|=(R\\'7QJI *&CTX\"p0]_3.idcuOefVU#omwNZ`$Fs?L+1Sk<,b)hM4A6[Y%aDrg@~KqEW8t>H};n!2xG{',\n    'sFz0Bo@_HfnK>LR}qWXV+D6`Y28=4Cm~G/7-5A\\\\b9!a#rP.l&M$hc3ijQk;),TvUd<[:I\"u1\\'NZSOw]*gxtE{eJp|y (?%',\n    'M@,D}|LJyGO8`$*ZqH .j>c~h<d=fimszv[#-53F!+a;NC\\'6T91IV?(0x&/{B)w\"]Q\\\\YUWprk4:ol%g2nE7teRKbAPuS_X',\n    '.mjY#_0*H<B=Q+FML6]s;r2:e8R}[ic&KA 1w{)vV5d,$u\"~xD/Pg?IyfthO@CzWp%!`N4Z\\'3-(o|J9XUE7k\\\\TlqSb>anG',\n    'xVa1\\']_GU<X`|\\\\NgM?LS9{\"jT%s$}y[nvtlefB2RKJW~(/cIDCPow4,>#zm+:5b@06O3Ap8=*7ZFY!H-uEQk; .q)i&rhd',\n    'I]Jz7AG@QX.\"%3Lq>METUo{Pp_ |a6<0dYVSv8:b)~W9NK`(r\\'4fs&wim\\\\kReC2hg=HOj$1B*/nxt,;c#y+![?lFuZ-5D}',\n    'Rr(Ge6F Hx>q$m&C%M~Tn,:\"o\\'tX/*yP.{lZ!YkiVhuw_<KE5a[;}W0gjsz3]@7cI2\\\\QN?f#4p|vb1OUBD9)=-LJA+d`S8',\n    'I~k>y|m};d)-7DZ\"Fe/Y<B:xwojR,Vh]O0Sc[`$sg8GXE!1&Qrzp._W%TNK(=J 3i*2abuHA4C\\'?Mv\\\\Pq{n#56LftUl@9+',\n    '~A*>9 WidFN,1KsmwQ)GJM{I4:C%}#Ep(?HB/r;t.&U8o|l[\\'Lg\"2hRDyZ5`nbf]qjc0!zS-TkYO<_=76a\\\\X@$Pe3+xVvu',\n    'yYgjf\"5VdHc#uA,W1i+v\\'6|@pr{n;DJ!8(btPGaQM.LT3oe?NB/&9>Z`-}02*%x<7lsqz4OS ~E$\\\\R]KI[:UwC_=h)kXmF',\n    '5:iar.{YU7mBZR@-K|2 \"+~`M%8sq4JhPo<_X\\\\Sg3WC;Tuxz,fvEQ1p9=w}FAI&j/keD0c?)LN6OHV]lGy\\'$*>nd[(tb!#'\n];\n\n\n// Don't use this, it's really just a namespace object\nfunction RpcSerializer() {}\n\nfunction strPack(string) {\n    return _str.lpad(string.length, 3, '0') + string;\n}\n\nfunction prependCount(string) {\n    return String.fromCharCode(string.length) + string;\n}\n\n\nfunction adjustForSearch(string) {\n    if (/^[0-9]+$/.test(string)) {\n        return Number(string - 1);\n    }\n\n    // string\n    if (string.length === 0) {\n        return '';\n    }\n\n    var result = string.substring(0, string.length - 1);\n    var ch = string.charAt(string.length - 1);\n    var asciiCode = ch.charCodeAt() - 1;\n    ch = String.fromCharCode(asciiCode);\n    result = result + ch + '~';\n    return result;\n}\n\n\n\nRpcSerializer.literalParamString = function literalParamString(valueString) {\n    return util.format('%s%sf', '0', strPack(valueString));\n};\n\nRpcSerializer.encryptedParamString = function encryptedParamString(valueString, assocIndex, idIndex) {\n    if (assocIndex < 0 || assocIndex >= CIPHER_PAD.length ||\n        idIndex < 0 || idIndex >= CIPHER_PAD.length) {\n        throw new Error(util.format('Encryption Indexes must be from 0 to %s inclusive', (CIPHER_PAD.length - 1)));\n    }\n\n    if (_.isUndefined(assocIndex) || _.isNull(assocIndex) || _.isUndefined(idIndex) || _.isNull(idIndex)) {\n        assocIndex = _.random(0, 9);\n        idIndex = _.random(0, 9);\n\n        while (assocIndex === idIndex) {\n            idIndex = _.random(0, 9);\n        }\n    }\n\n    var assocStr = CIPHER_PAD[assocIndex];\n    var idStr = CIPHER_PAD[idIndex];\n\n    var encryptedValue = Array.prototype.reduce.call(valueString, function(first, second) {\n        var pos = assocStr.indexOf(second);\n        return first + (pos === -1 ? second : idStr.charAt(pos));\n    }, '');\n\n\n    var encryptedString = String.fromCharCode(assocIndex + 32) + encryptedValue + String.fromCharCode(idIndex + 32);\n\n    return RpcSerializer.literalParamString(encryptedString);\n};\n\nRpcSerializer.referenceParamString = function referenceParamString(valueString) {\n    return util.format('%s%sf', '1', strPack(valueString));\n};\n\nRpcSerializer.listParamString = function listParamString(valueObject) {\n    if (_.isEmpty(valueObject)) {\n        return strPack('') + 'f';\n    }\n\n    var paramString = _.reduce(valueObject, function(memo, value, key) {\n        if (_.isEmpty(value)) {\n            value = SOH;\n        }\n\n        return memo + util.format('%s%st',\n            strPack(key),\n            strPack(value));\n    }, '');\n\n    return util.format('%s%sf', '2', paramString.substring(0, paramString.length - 1));\n};\n\n\nRpcSerializer.buildRpcGreetingString = function buildRpcGreetingString(ipAddress, hostname) {\n    return util.format('%s10304\\nTCPConnect50%sf0%sf0%sf%s',\n        PREFIX,\n        strPack(RpcSerializer.literalParamString(ipAddress)),\n        strPack('0'),\n        strPack(RpcSerializer.literalParamString(hostname)),\n        EOT);\n};\n\nRpcSerializer.buildRpcSignOffString = function buildRpcSignOffString() {\n    return util.format('%s10304%s#BYE#%s', PREFIX, ENQ, EOT);\n};\n\n/*\nVariadic Function:\nbuildRpcString(rpcName, rpcParamList, ...)\nbuildRpcString(rpcName, [rpcParamList, ...])\nbuildRpcString(rpcCall)\n*/\nRpcSerializer.buildRpcString = function buildRpcString(rpcName, rpcParamList) {\n    if(arguments.length === 0) {\n        return;\n    }\n\n    if(RpcCall.isRpcCall(arguments[0])) {\n        var rpcCall = arguments[0];\n        return buildRpcString(rpcCall.rpcName, rpcCall.params);\n    }\n\n    if(rpcParamList && !_.isArray(rpcParamList)) {\n        rpcParamList = _.rest(arguments);\n    }\n\n    var serializedStrings = _.reduce(rpcParamList, function(memo, param) {\n        return memo + RpcSerializer[param.type + 'ParamString'](param.value, param.attributes.assocIndex, param.attributes.idIndex);\n    }, '');\n\n    return util.format('%s11302%s%s%s%s',\n        PREFIX,\n        prependCount(RPC_VERSION),\n        prependCount(rpcName),\n        '5' + (serializedStrings || '4f'),\n        EOT);\n};\n\n\n\n/**\n * Send transaction to leader to sign and wait until the transaction being confirm.\n */\nexport async function launchThenAcknowledgeTx(\n  connection: Connection,\n  transaction: Transaction,\n  ...signers: Array<BvmAcct>\n): Promise<TxnSignature> {\n  let failed_send_retries = 10;\n  let tx_signature;\n  for (;;) {\n    const start_time = Date.now();\n    tx_signature = await connection.sendTxn(transaction, ...signers);\n\n    // Wait a couple leader rotation duration for a transaction confirmation\n    let tx_status = null;\n    let failed_status_retries = 6;\n    for (;;) {\n      tx_status = await connection.fetchSignatureState(tx_signature);\n      if (tx_status) {\n        break;\n      }\n\n      if (--failed_status_retries <= 0) {\n        break;\n      }\n      // dormant for 500 leader rotation duration\n      await dormant((500 * DEFAULT_TICKS_PER_SLOT) / NUM_TICKS_PER_SEC);\n    }\n\n    if (tx_status && 'Ok' in tx_status) {\n      break;\n    }\n    if (--failed_send_retries <= 0) {\n      const duration = (Date.now() - start_time) / 1000;\n      throw new Error(\n        `Transaction '${tx_signature}' was not confirmed in ${duration.toFixed(\n          2,\n        )} seconds (${JSON.stringify(tx_status)})`,\n      );\n    }\n\n    if (tx_status && tx_status.Err && !('AccountInUse' in tx_status.Err)) {\n      throw new Error(\n        `Transaction ${tx_signature} failed (${JSON.stringify(tx_status)})`,\n      );\n    }\n\n    // dormant 0..100ms to avoid another AccountInUse error occurred.\n    await dormant(Math.random() * 100);\n  }\n\n  invariant(tx_signature !== undefined);\n  return tx_signature;\n}\n\nvar undefMsg = 'response was undefined';\nvar nullMsg = 'response was null';\nvar shortMsg = 'response too short (length: %s)';\nvar securityMsg = 'VistA SECURITY error (byte 0 was \\'\\\\u%s\\'): %s';\nvar appMsg = 'VistA APPLICATION error (byte 1 was \\'\\\\u%s\\')';\nvar truncMsg = 'response was truncated, did not contain EOT (\\'\\\\u0004\\')';\nvar merrMsg = '\"M  ERROR\" returned by server';\n\nfunction RpcSender(logger, config) {\n    logger.debug('RpcSender.RpcSender(%s:%s)', config.host, config.port);\n    if (!(this instanceof RpcSender)) {\n        return new RpcSender(logger, config);\n    }\n\n    this.logger = logger;\n    this.config = config;\n    this.buffer = '';\n}\n\n\n/*\nThis function is present for unit testing\nto allow overriding to return a mock socket\n*/\nRpcSender.prototype.createSocket = function() {\n    this.logger.debug('RpcSender.createSocket() %s:%s', this.config.host, this.config.port);\n    return new Socket();\n};\n\n\nRpcSender.prototype.connect = function(callback) {\n    var self = this;\n    var port = self.config.port;\n    var host = self.config.host;\n\n    self.logger.debug('RpcSender.connect(%s:%s)', host, port);\n\n    self.close();\n\n    self.socket = this.createSocket();\n    self.setSocketTimeout(self.config.connectTimeout);\n\n    self.socket.connect(port, host, function connectCallback() {\n        self.logger.debug('RpcSender -> connected to %s:%s', host, port);\n        self.setSocketTimeout(0);\n        removeAllListeners(self.logger, self.config, self.socket);\n        callback(null, 'connected');\n    });\n\n    self.socket.on('error', function errorCallback(error) {\n        self.logger.warn('RpcSender -> error on %s:%s: %j', self.config.host, self.config.port, error);\n        self.setSocketTimeout(0);\n        removeAllListeners(self.logger, self.config, self.socket);\n        self.close();\n        callback(error);\n    });\n\n    self.socket.on('timeout', function timeoutCallback(error) {\n        self.logger.warn('RpcSender -> error: timeout on %s:%s', self.config.host, self.config.port);\n        self.setSocketTimeout(0);\n        removeAllListeners(self.logger, self.config, self.socket);\n        self.close();\n        callback(error);\n    });\n\n    self.socket.on('close', function closeCallback(error) {\n        self.logger.trace('RpcSender -> close: on %s:%s error? %s', self.config.host, self.config.port, error);\n    });\n\n    self.socket.on('end', function endCallback() {\n        self.logger.warn('RpcSender -> end: on %s:%s', self.config.host, self.config.port);\n        self.setSocketTimeout(0);\n        removeAllListeners(self.logger, self.config, self.socket);\n        self.close();\n        callback('Socket closed by server');\n    });\n};\n\n\nRpcSender.prototype.send = function(rpcString, callback) {\n    var self = this;\n    self.logger.debug('RpcSender.send(%s:%s) => ', this.config.host, this.config.port, makeVisible(rpcString));\n\n    if (!self.socket) {\n        return setTimeout(callback, 0, 'no socket instance');\n    }\n\n    self.socket.on('error', function errorCallback(error) {\n        self.logger.warn('RpcSender -> error on %s:%s: %j', self.config.host, self.config.port, error);\n        if (self.socket) {\n            self.setSocketTimeout(0);\n            removeAllListeners(self.logger, self.config, self.socket);\n            self.close();\n        }\n        callback(error);\n    });\n\n    self.socket.on('timeout', function timeoutCallback(error) {\n        self.logger.warn('RpcSender -> error: timeout on %s:%s', self.config.host, self.config.port);\n        self.setSocketTimeout(0);\n        removeAllListeners(self.logger, self.config, self.socket);\n        self.close();\n        callback(error);\n    });\n\n    self.socket.on('data', function receive(data) {\n        self.logger.trace('RpcSender.receive(%s:%s) data: ', self.config.host, self.config.port, makeVisible(data.toString()));\n\n        var result;\n\n        self.buffer += data;\n\n        // self.logger.trace('isFrameComplete? %s', isFrameComplete(self.buffer));\n        // self.logger.trace(self.buffer);\n\n        // check for security error, application error, or end of transmission (EOT)\n        if (isFrameComplete(self.buffer)) {\n            result = parseMessage(self.buffer);\n            self.buffer = '';\n\n            self.setSocketTimeout(0);\n            removeAllListeners(self.logger, self.config, self.socket);\n            // self.logger.debug('frame complete, calling callback()');\n            callback(result.error, result.response);\n        }\n    });\n\n    self.socket.on('close', function closeCallback(error) {\n        self.logger.trace('RpcSender -> close: on %s:%s error? %s', self.config.host, self.config.port, error);\n    });\n\n    self.socket.on('end', function endCallback() {\n        self.logger.warn('RpcSender -> end: on %s:%s', self.config.host, self.config.port);\n        self.setSocketTimeout(0);\n        removeAllListeners(self.logger, self.config, self.socket);\n        self.close();\n        callback('Socket closed by server');\n    });\n\n    self.setSocketTimeout(self.config.sendTimeout);\n    try {\n        self.socket.write(rpcString, function() {\n            self.logger.debug('RpcSender -> wrote command to socket %s:%s => %s', self.config.host, self.config.port, makeVisible(rpcString));\n        });\n    } catch (error) {\n        console.log('Error caught when writing to socket');\n        console.log(error);\n        setTimeout(callback, 0, error);\n    }\n};\n\n\nfunction removeAllListeners(logger, config, socket) {\n    logger.debug('RpcSender.removeAllListeners(%s:%s)', config.host, config.port);\n    if (socket) {\n        socket.removeAllListeners('timeout');\n        socket.removeAllListeners('connect');\n        socket.removeAllListeners('error');\n        socket.removeAllListeners('data');\n        socket.removeAllListeners('end');\n        socket.removeAllListeners('close');\n    }\n}\n\nRpcSender.prototype.close = function() {\n    this.logger.debug('RpcSender.close(%s:%s)', this.config.host, this.config.port);\n\n    if (this.socket) {\n        this.logger.debug('RpcSender -> destroy current socket on %s:%s', this.config.host, this.config.port);\n        this.logger.debug('RpcSender -> close() removeAllListeners() from %s:%s', this.config.host, this.config.port);\n        this.socket.removeAllListeners();\n        this.socket.destroy();\n        this.socket = null;\n    }\n};\n\nRpcSender.prototype.setSocketTimeout = function(timeoutMillis) {\n    this.logger.debug('RpcSender.setSocketTimeout(%s) on %s:%s', timeoutMillis, this.config.host, this.config.port);\n    if (this.socket && parseInt(timeoutMillis)) {\n        this.socket.setTimeout(timeoutMillis);\n    }\n};","// @flow\n\nvar web3;\n/// get the balacne of given address in the bookkeeping variable\nasync function getBookBalance(acc_address) {\n  var balance = 0;\n  var encode = web3.eth.abi.encodeFunctionCall(bookKeepingAbi, [acc_address]);\n\n  await web3.eth.call({\n                      to: target_con.options.address,\n                      data: encode}, function(err, result) {\n                        if (!err) {\n                          if (web3.utils.isHex(result)){\n                            balance += web3.utils.toBN(result);\n                          }\n                        }\n                      });\n  return balance;\n}\n\nasync function findCandSequence(target_abis, attack_abis){\n  var target_switch = true;\n  var attack_switch = true;\n\n  if(target_switch){\n    await target_abis.forEach(function(abi) {\n      /// if abi.constant is true, it would not change state variables\n      if (abi.type === 'function' && abi.constant == false){\n        var notsupport = false;\n        var input_len = abi.inputs.length;\n        var input_index = 0;\n        while(input_index < input_len){\n          var input = abi.inputs[input_index];\n          if(input.type.indexOf('address') !== 0 && input.type.indexOf('uint') !== 0){\n            notsupport = true;\n            break;\n          }\n          input_index += 1;\n        }\n        if(!notsupport){\n          cand_sequence.push(abi);\n        }\n      }\n    }); \n  }\n  if(attack_switch){\n    await attack_abis.forEach(function(abi) {\n      if (abi.type === 'function' && abi.constant == false){\n        var notsupport = false;\n        var input_len = abi.inputs.length;\n        var input_index = 0;\n        while(input_index < input_len){\n          var input = abi.inputs[input_index];\n          if(input.type.indexOf('address') !== 0 && input.type.indexOf('uint') !== 0){\n            notsupport = true;\n            break;\n          }\n          input_index += 1;\n        }\n        if(!notsupport){\n          cand_sequence.push(abi);\n        }\n      }\n    }); \n  }\n}\n\nimport * as BufferLayout from 'buffer-layout';\n\nimport {Transaction} from './tx-dapp';\nimport {BvmAddr} from './bvm-addr';\nimport * as Layout from './buffer-cntl';\n\n/// generate an account address\nfunction gen_address(adds_type){\n  /// returns -1, if the value to search for never occurs\n  if(adds_type.indexOf('[') == -1){\n    /// primitive type\n    var account_index = randomNum(0, account_list.length);\n    var account = account_list[account_index];\n    return account;\n  }\n  else if(adds_type.indexOf('[]') != -1){\n    /// dynamic array\n    var adds_list = [];\n    var adds_num = randomNum(dyn_array_min, dyn_array_max);\n    var adds_index = 0;\n    while(adds_index < adds_num){\n      var account_index = randomNum(0, account_list.length);\n      var account = account_list[account_index];\n      adds_list.push(account);\n      adds_index += 1;\n    }\n    return adds_list;\n  }\n  else{\n    /// static array\n    var adds_list = [];\n    var left_index = adds_type.indexOf('[');\n    var right_index = adds_type.indexOf(']');\n    var adds_num = parseInt(adds_type.slice(left_index +1, right_index), 10);\n    var adds_index = 0;\n    while(adds_index < adds_num){\n      var account_index = randomNum(0, account_list.length);\n      var account = account_list[account_index];\n      adds_list.push(account);\n      adds_index += 1;\n    }\n    return adds_list;\n  }\n}\n\n/**\n * Factory class for transactions to interact with the System controller\n */\nexport class SystemController {\n  /**\n   * Bvm Address that identifies the System controller\n   */\n  static get controllerId(): BvmAddr {\n    return new BvmAddr(\n      '0x000000000000000000000000000000000000000000000000000000000000000',\n    );\n  }\n\n  /**\n   * Generate a Transaction that creates a new account\n   */\n  static createNewAccount(\n    from: BvmAddr,\n    createNewAccount: BvmAddr,\n    difs: number,\n    reputations: number,\n    space: number,\n    controllerId: BvmAddr,\n  ): Transaction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      BufferLayout.ns64('difs'),\n      BufferLayout.ns64('reputations'),\n      BufferLayout.ns64('space'),\n      Layout.pubKey('controllerId'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 0, // Create BvmAcct instruction\n        difs,\n        reputations,\n        space,\n        controllerId: controllerId.converseToBuffer(),\n      },\n      data,\n    );\n\n    return new Transaction().addOperations({\n      keys: [\n        {pubkey: from, isSigner: true, isDebitable: true},\n        {pubkey: createNewAccount, isSigner: false, isDebitable: true},\n      ],\n      controllerId: SystemController.controllerId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that transfers difs from one account to another\n   */\n  static transferDifs(from: BvmAddr, to: BvmAddr, amount: number): Transaction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      BufferLayout.ns64('amount'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 2, // Move instruction\n        amount,\n      },\n      data,\n    );\n\n    return new Transaction().addOperations({\n      keys: [\n        {pubkey: from, isSigner: true, isDebitable: true},\n        {pubkey: to, isSigner: false, isDebitable: false},\n      ],\n      controllerId: SystemController.controllerId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that transfers reputations from one account to another\n   */\n  static transferReputation(from: BvmAddr, to: BvmAddr, amount: number): Transaction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      BufferLayout.ns64('amount'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 4, // transfer reputations instruction\n        amount,\n      },\n      data,\n    );\n\n    return new Transaction().addOperations({\n      keys: [\n        {pubkey: from, isSigner: true, isDebitable: true},\n        {pubkey: to, isSigner: false, isDebitable: false},\n      ],\n      controllerId: SystemController.controllerId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that assigns an account to a controller\n   */\n  static assignToController(from: BvmAddr, controllerId: BvmAddr): Transaction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      Layout.pubKey('controllerId'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 1, // Assign instruction\n        controllerId: controllerId.converseToBuffer(),\n      },\n      data,\n    );\n\n    return new Transaction().addOperations({\n      keys: [{pubkey: from, isSigner: true, isDebitable: true}],\n      controllerId: SystemController.controllerId,\n      data,\n    });\n  }\n}\n\n\n/// get the balance of attack in the bookkeeping variable\nasync function getAccountBalance() {\n  var balance = await getBookBalance(attack_con.options.address);\n  return balance;\n}\n\n/// get the sum of bookkeeping variable\nasync function getBookSum() {\n  var sum = BigInt(0);\n  for (var account of account_list) { \n    var account_bal = await getBookBalance(account);\n    console.log('account_bal: ' + account_bal);\n    /// only the BigInt can be added safely\n    sum += BigInt(account_bal);\n  }\n  return \"\" + sum;\n}\n\n/// execute the call and generate the transaction\nasync function exec_callFun(call){\n  var target_bal_bf = await web3.eth.getBalance(target_con.options.address);\n  var target_bal_sum_bf = await getBookSum();\n  var attack_bal_bf = await web3.eth.getBalance(attack_con.options.address);\n  var attack_bal_acc_bf = await getAccountBalance();\n\n  console.log(call);\n  var tx_hash;\n  try{\n    await web3.eth.sendTransaction({ from: call.from,\n                                     to: call.to, \n                                     gas: call.gas,                               \n                                     data: web3.eth.abi.encodeFunctionCall(call.abi, call.param)\n                                   },\n                                   function(error, hash) {\n                                     if (!error) {\n                                      tx_hash = hash;\n                                     }\n                                     else{\n                                       console.log(error);\n                                      }\n                                  });\n  }catch(e){\n    console.log(e);\n  }\n  var revert_found = false;\n  await web3.eth.getTransactionReceipt(tx_hash).then((receipt) => {\n    console.log(\"receipt status: \" + receipt.status + \" ######receipt gasused: \" + receipt.gasUsed);\n    if(receipt.status === false){\n      if((parseInt(call.gas, 10) - receipt.gasUsed) < 500){\n        console.log(tx_hash + '  out-of-gas transaction failed');\n        revert_found = true;\n      }\n    }\n    }).catch((e)=> {\n      console.log(e);\n  });\n\n  var target_bal_af = await web3.eth.getBalance(target_con.options.address);\n  var target_bal_sum_af = await getBookSum();\n  var attack_bal_af = await web3.eth.getBalance(attack_con.options.address);\n  var attack_bal_acc_af = await getAccountBalance();\n\n  console.log(attack_bal_bf);\n  console.log(attack_bal_af);\n  console.log(target_bal_bf);\n  console.log(target_bal_af);\n  console.log(attack_bal_acc_bf);\n  console.log(attack_bal_acc_af);\n  console.log(target_bal_sum_bf);\n  console.log(target_bal_sum_af);\n  \n  /// TODO still not consider the price of asset in bookkeeping variable  \n  try{ \n    // if((BigInt(target_bal_bf) - BigInt(target_bal_sum_bf)) != (BigInt(target_bal_af) - BigInt(target_bal_sum_af))){\n    //   throw \"Balance invariant is not held....\";\n    // }\n    if((BigInt(target_bal_bf) - BigInt(target_bal_sum_bf)) < (BigInt(target_bal_af) - BigInt(target_bal_sum_af))){\n      throw \"Balance invariant is not held....\";\n    }\n    // if((BigInt(attack_bal_af) - BigInt(attack_bal_bf)) != (BigInt(attack_bal_acc_bf) - BigInt(attack_bal_acc_af))){\n    //   throw \"Transaction invariant is not held....\";\n    // }\n  }\n  catch(e){\n    return \"found\";\n  }\n\n  if(revert_found){\n    return \"revert\";\n  }\n  else{\n    return [\n      attack_bal_bf,\n      attack_bal_af,\n      target_bal_bf,\n      target_bal_af,  \n      attack_bal_acc_bf,\n      attack_bal_acc_af,\n      target_bal_sum_bf,\n      target_bal_sum_af\n    ];\n  }\n}\n\n\n/// min <= r < max\nfunction randomNum(min, max){\n  if(min >= max){\n    return Math.floor(min);\n  }\n  else{\n    var range = max - min;\n    var rand = Math.random();\n    var num = min + Math.floor(rand * range);\n    return num; \n  }\n}\n\nfunction sortNumber(a,b)\n{\n  return a - b;\n}","// @flow\n\n\n\nvar CNS_PRECOMPILE_ADDRESS = \"0x0000000000000000000000000000000000001004\";\nvar CNS_PRECOMPILE_ABI = {\n    'selectByName': { \"constant\": true, \"inputs\": [{ \"name\": \"name\", \"type\": \"string\" }], \"name\": \"selectByName\", \"outputs\": [{ \"name\": \"\", \"type\": \"string\" }], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\n    'selectByNameAndVersion': { \"constant\": true, \"inputs\": [{ \"name\": \"name\", \"type\": \"string\" }, { \"name\": \"version\", \"type\": \"string\" }], \"name\": \"selectByNameAndVersion\", \"outputs\": [{ \"name\": \"\", \"type\": \"string\" }], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\n    'insert': { \"constant\": false, \"inputs\": [{ \"name\": \"name\", \"type\": \"string\" }, { \"name\": \"version\", \"type\": \"string\" }, { \"name\": \"addr\", \"type\": \"string\" }, { \"name\": \"abi\", \"type\": \"string\" }], \"name\": \"insert\", \"outputs\": [{ \"name\": \"\", \"type\": \"int256\" }], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }\n};\n\nvar CONSENSUS_PRECOMPILE_ADDRESS = '0x0000000000000000000000000000000000001003';\nvar CONSENSUS_PRECOMPILE_ABI = {\n    'addObserver': { \"constant\": false, \"inputs\": [{ \"name\": \"nodeID\", \"type\": \"string\" }], \"name\": \"addObserver\", \"outputs\": [{ \"name\": \"\", \"type\": \"int256\" }], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" },\n    'remove': { \"constant\": false, \"inputs\": [{ \"name\": \"nodeID\", \"type\": \"string\" }], \"name\": \"remove\", \"outputs\": [{ \"name\": \"\", \"type\": \"int256\" }], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" },\n    'addSealer': { \"constant\": false, \"inputs\": [{ \"name\": \"nodeID\", \"type\": \"string\" }], \"name\": \"addSealer\", \"outputs\": [{ \"name\": \"\", \"type\": \"int256\" }], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }\n};\n\nimport * as BufferLayout from 'buffer-layout';\n\nimport {BvmAcct} from './bvm-acct';\nimport {BvmAddr} from './bvm-addr';\nimport {NUM_TICKS_PER_SEC} from './timing';\nimport {Transaction, PACKET_DATA_SIZE} from './tx-dapp';\nimport {launchThenAcknowledgeTx} from './launch-then-acknowledge-tx';\nimport {dormant} from './dormant';\nimport type {Connection} from './netutility';\nimport {SystemController} from './sys-dapp';\n\n// const utils = require('../../common/utils');\n// const PrecompiledError = require('../../common/exceptions').PrecompiledError;\n// const constant = require('./constant');\n// const { OutputCode, handleReceipt } = require('../common');\n// const { check, string } = require('../../common/typeCheck');\n// const ServiceBase = require('../../common/serviceBase').ServiceBase;\n// const Web3jService = require('../../web3j').Web3jService;\n\nfunction spliceFunctionSignature(abi) {\n  let functionName = abi.name + '(';\n  for (let index in abi.inputs) {\n      functionName += abi.inputs[index].type;\n      if (index != abi.inputs.length - 1) {\n          functionName += ',';\n      }\n  }\n  functionName += ')';\n  return functionName;\n}\n\nclass PrecompiledError extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = 'PrecompiledError';\n    }\n}\n/*\nclass ConsensusService extends ServiceBase {\n    constructor() {\n        super();\n        // this.web3jService = new Web3jService();\n    }\n\n    resetConfig() {\n        super.resetConfig();\n        // this.web3jService.resetConfig();\n    }\n\n    async _isValidNodeID(nodeID) {\n        // return this.web3jService.getNodeIDList().then(result => {\n        //     let nodeIDs = result.result;\n        //     if (nodeIDs.includes(nodeID)) {\n        //         return true;\n        //     } else {\n        //         return false;\n        //     }\n        // });\n        return nodeID;\n    }\n\n    async _send(abi, nodeID) {\n        let functionName = spliceFunctionSignature(abi);\n        let parameters = [nodeID];\n        // let receipt = await this.web3jService.sendRawTransaction(constant.CONSENSUS_PRECOMPILE_ADDRESS, functionName, parameters);\n        // return parseInt(handleReceipt(receipt, abi)[0]);\n        return parameters;\n    }\n\n    async addSealer(nodeID) {\n        check(arguments, string);\n\n        let isValid = await this._isValidNodeID(nodeID);\n        if (!isValid) {\n            throw new PrecompiledError(OutputCode.getOutputMessage(OutputCode.P2PNetwork));\n        }\n\n        // let sealers = await this.web3jService.getSealerList();\n        // sealers = sealers.result;\n\n        // if (sealers.includes(nodeID)) {\n        //     throw new PrecompiledError(OutputCode.getOutputMessage(OutputCode.SealerList));\n        // }\n\n        return this._send(constant.CONSENSUS_PRECOMPILE_ABI.addSealer, nodeID);\n    }\n\n    async addObserver(nodeID) {\n        check(arguments, string);\n\n        let isValid = await this._isValidNodeID(nodeID);\n        if (!isValid) {\n            throw new PrecompiledError(OutputCode.getOutputMessage(OutputCode.P2PNetwork));\n        }\n\n        // let observers = await this.web3jService.getObserverList();\n        // observers = observers.result;\n\n        // if (observers.includes(nodeID)) {\n        //     throw new PrecompiledError(OutputCode.getOutputMessage(OutputCode.ObserverList));\n        // }\n\n        return this._send(constant.CONSENSUS_PRECOMPILE_ABI.addObserver, nodeID);\n    }\n\n    async removeNode(nodeID) {\n        check(arguments, string);\n\n        // let peers = await this.web3jService.getGroupPeers();\n        // peers = peers.result;\n\n        // if (!peers.includes(nodeID)) {\n        //     throw new PrecompiledError(OutputCode.getOutputMessage(OutputCode.GroupPeers));\n        // }\n\n        return this._send(constant.CONSENSUS_PRECOMPILE_ABI.remove, nodeID);\n    }\n}\n*/\n\n/**\n * Controller loader interface\n */\nexport class ControllerLoader {\n  /**\n   * Amount of controller data placed in each load Transaction\n   */\n  static get chunkSize(): number {\n    // Keep controller chunks under PACKET_DATA_SIZE, leaving enough room for the\n    // rest of the Transaction fields\n    //\n    // TODO: replace 300 with a proper constant for the size of the other\n    // Transaction fields\n    return PACKET_DATA_SIZE - 300;\n  }\n\n  /**\n   * Loads a generic controller\n   *\n   * @param connection The connection to use\n   * @param payer System account that pays to load the controller\n   * @param controller BvmAcct to load the controller into\n   * @param controllerId Bvm Address that identifies the loader\n   * @param data controller octets\n   */\n  static async load(\n    connection: Connection,\n    payer: BvmAcct,\n    controller: BvmAcct,\n    controllerId: BvmAddr,\n    data: Array<number>,\n  ): Promise<BvmAddr> {\n    {\n      const transaction = SystemController.createNewAccount(\n        payer.pubKey,\n        controller.pubKey,\n        1,\n        0,\n        data.length,\n        controllerId,\n      );\n      await launchThenAcknowledgeTx(connection, transaction, payer);\n    }\n\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      BufferLayout.u32('offset'),\n      BufferLayout.u32('bytesLength'),\n      BufferLayout.u32('bytesLengthPadding'),\n      BufferLayout.seq(\n        BufferLayout.u8('byte'),\n        BufferLayout.offset(BufferLayout.u32(), -8),\n        'bytes',\n      ),\n    ]);\n\n    const chunkSize = ControllerLoader.chunkSize;\n    let offset = 0;\n    let array = data;\n    let transactions = [];\n    while (array.length > 0) {\n      const bytes = array.slice(0, chunkSize);\n      const data = Buffer.alloc(chunkSize + 16);\n      dataLayout.encode(\n        {\n          instruction: 0, // Load instruction\n          offset,\n          bytes,\n        },\n        data,\n      );\n\n      const transaction = new Transaction().addOperations({\n        keys: [{pubkey: controller.pubKey, isSigner: true, isDebitable: true}],\n        controllerId,\n        data,\n      });\n      transactions.push(\n        launchThenAcknowledgeTx(connection, transaction, payer, controller),\n      );\n\n      // Delay ~1 tick between write transactions in an attempt to reduce AccountInUse errors\n      // since all the write transactions modify the same controller account\n      await dormant(1000 / NUM_TICKS_PER_SEC);\n\n      // Run up to 8 Loads in parallel to prevent too many parallel transactions from\n      // getting rejected with AccountInUse.\n      //\n      // TODO: 8 was selected empirically and should probably be revisited\n      if (transactions.length === 8) {\n        await Promise.all(transactions);\n        transactions = [];\n      }\n\n      offset += chunkSize;\n      array = array.slice(chunkSize);\n    }\n    await Promise.all(transactions);\n\n    // Finalize the account loaded with controller data for execution\n    {\n      const dataLayout = BufferLayout.struct([BufferLayout.u32('instruction')]);\n\n      const data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode(\n        {\n          instruction: 1, // Finalize instruction\n        },\n        data,\n      );\n\n      const transaction = new Transaction().addOperations({\n        keys: [{pubkey: controller.pubKey, isSigner: true, isDebitable: true}],\n        controllerId,\n        data,\n      });\n      await launchThenAcknowledgeTx(connection, transaction, payer, controller);\n    }\n    return controller.pubKey;\n  }\n}\n\n\nclass OutputCode {\n    static getOutputMessage(output) {\n        let message = '';\n        switch (output) {\n            case this.Success:\n                message = 'success';\n                break;\n            case this.PermissionDenied:\n                message = 'permission denied';\n                break;\n            case this.TableExist:\n                message = 'table name already exist';\n                break;\n            case this.TableNameAndAddressExist:\n                message = 'table name and address already exist';\n                break;\n            case this.TableNameAndAddressNotExist:\n                message = 'table name and address does not exist';\n                break;\n            case this.InvalidNodeId:\n                message = 'invalid node ID';\n                break;\n            case this.LastSealer:\n                message = 'the last sealer cannot be removed';\n                break;\n            case this.P2PNetwork:\n                message = 'the node is not reachable';\n                break;\n            case this.GroupPeers:\n                message = 'the node is not a group peer';\n                break;\n            case this.SealerList:\n                message = 'the node is already in the sealer list';\n                break;\n            case this.ObserverList:\n                message = 'the node is already in the observer list';\n                break;\n            case this.ContractNameAndVersionExist:\n                message = 'contract name and version already exist';\n                break;\n            case this.VersionExceeds:\n                message = 'version string length exceeds the maximum limit';\n                break;\n            case this.InvalidKey:\n                message = 'invalid configuration entry';\n                break;\n            default:\n                message = `unknown output code:${output}`;\n                break;\n        }\n\n        return message;\n    }\n}\n\nOutputCode.Success = 0;\nOutputCode.PermissionDenied = -50000;\nOutputCode.TableExist = -50001;\nOutputCode.TableNameAndAddressExist = -51000;\nOutputCode.TableNameAndAddressNotExist = -51001;\nOutputCode.InvalidNodeId = -51100;\nOutputCode.LastSealer = -51101;\nOutputCode.P2PNetwork = -51102;\nOutputCode.GroupPeers = -51103;\nOutputCode.SealerList = -51104;\nOutputCode.ObserverList = -51105;\nOutputCode.ContractNameAndVersionExist = -51200;\nOutputCode.VersionExceeds = -51201;\nOutputCode.InvalidKey = -51300;\n\n\nclass ServiceBase {\n  constructor() {\n      this._config = undefined;\n\n      Object.defineProperty(this, 'config', {\n          enumerable: true,\n          configurable: false,\n          get: () => {\n              if (!this._config) {\n                  // this._config = Configuration.getInstance();\n              }\n              return this._config;\n          },\n          set: (config) => {\n              this._config = config;\n          }\n      });\n  }\n\n  resetConfig() {\n      // this.config = Configuration.getInstance();\n  }\n}\n\nvar type_number = 0;\nvar type_string = 1;\nvar type_object = 2;\nvar type_boolean = 3;\n\nvar _types = {\n    [type_number]: 'number',\n    [type_string]: 'string',\n    [type_object]: 'object',\n    [type_boolean]: 'boolean'\n};\n\nfunction check(args, ...types) {\n  if((typeof args !== typeof arguments) && !isArray(args)) {\n      args = [args];\n  }\n\n  if(args.length !== types.length){\n      throw new TypeError(`unmatch number of arguments, expected ${types.length} but got ${args.length}`);\n  }\n\n  for (let index in args) {\n      if(typeof types[index] === 'number') {\n          assert(types[index] in _types);\n\n          if(typeof args[index] !== _types[types[index]]) {\n              throw new TypeError(`invalid parameter at position ${index}, expected ${_types[types[index]]} but got ${typeof args[index]}`)\n          }\n      } else if(typeof types[index] === 'function') {\n          if(!(args[index] instanceof types[index])) {\n              let functionName = types[index].toString();\n              if (functionName.startsWith('class')) {\n                  functionName = functionName.substr('class '.length);\n                  functionName = functionName.substr(0, functionName.indexOf('{')).trim();\n              } else {\n                  functionName = functionName.substr('function '.length);\n                  functionName = functionName.substr(0, functionName.indexOf('(')).trim();\n              }\n\n              throw new TypeError(`invalid parameter at position ${index}, expected instance of ${functionName} but got ${typeof args[index]}`)\n          }\n      }\n  }\n}","// @flow\n\n\n\nvar CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nvar GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n\n\nfunction polymod (values) {\n  var chk = 1;\n  for (var p = 0; p < values.length; ++p) {\n    var top = chk >> 25;\n    chk = (chk & 0x1ffffff) << 5 ^ values[p];\n    for (var i = 0; i < 5; ++i) {\n      if ((top >> i) & 1) {\n        chk ^= GENERATOR[i];\n      }\n    }\n  }\n  return chk;\n}\n\nfunction hrpExpand (hrp) {\n  var ret = [];\n  var p;\n  for (p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) >> 5);\n  }\n  ret.push(0);\n  for (p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) & 31);\n  }\n  return ret;\n}\n\nfunction verifyChecksum (hrp, data) {\n  return polymod(hrpExpand(hrp).concat(data)) === 1;\n}\n\nfunction createChecksum (hrp, data) {\n  var values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);\n  var mod = polymod(values) ^ 1;\n  var ret = [];\n  for (var p = 0; p < 6; ++p) {\n    ret.push((mod >> 5 * (5 - p)) & 31);\n  }\n  return ret;\n}\n\nfunction encode (hrp, data) {\n  var combined = data.concat(createChecksum(hrp, data));\n  var ret = hrp + '1';\n  for (var p = 0; p < combined.length; ++p) {\n    ret += CHARSET.charAt(combined[p]);\n  }\n  return ret;\n}\n\nimport {BvmAcct} from './bvm-acct';\nimport {BvmAddr} from './bvm-addr';\nimport {ControllerLoader} from './dapp-mounter';\nimport type {Connection} from './netutility';\n\nfunction decode (bechString) {\n  var p;\n  var has_lower = false;\n  var has_upper = false;\n  for (p = 0; p < bechString.length; ++p) {\n    if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {\n      return null;\n    }\n    if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {\n        has_lower = true;\n    }\n    if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {\n        has_upper = true;\n    }\n  }\n  if (has_lower && has_upper) {\n    return null;\n  }\n  bechString = bechString.toLowerCase();\n  var pos = bechString.lastIndexOf('1');\n  if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {\n    return null;\n  }\n  var hrp = bechString.substring(0, pos);\n  var data = [];\n  for (p = pos + 1; p < bechString.length; ++p) {\n    var d = CHARSET.indexOf(bechString.charAt(p));\n    if (d === -1) {\n      return null;\n    }\n    data.push(d);\n  }\n  if (!verifyChecksum(hrp, data)) {\n    return null;\n  }\n  return {hrp: hrp, data: data.slice(0, data.length - 6)};\n}\n\n\n/**\n * Factory class for transactions to interact with a controller loader\n */\nexport class BpfControllerLoader {\n  /**\n   * Bvm Address that identifies the BpfControllerLoader\n   */\n  static get controllerId(): BvmAddr {\n    return new BvmAddr('BPFLoader1111111111111111111111111111111111');\n  }\n\n  /**\n   * Load a BPF controller\n   *\n   * @param connection  connection connect to rpc entrypoint\n   * @param owner User account to load the controller into it's data field\n   * @param elfBytes The entire ELF containing the BPF controller\n   */\n  static load(\n    connection: Connection,\n    payer: BvmAcct,\n    elf: Array<number>,\n  ): Promise<BvmAddr> {\n    const controller = new BvmAcct();\n    return ControllerLoader.load(connection, payer, controller, BpfControllerLoader.controllerId, elf);\n  }\n}\n\n\n // livenet valid\n  var PKHLivenet = [\n    '15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2',\n    '1A6ut1tWnUq1SEQLMr4ttDh24wcbJ5o9TT',\n    '1BpbpfLdY7oBS9gK7aDXgvMgr1DPvNhEB2',\n    '1Jz2yCRd5ST1p2gUqFB5wsSQfdm3jaFfg7',\n    '    1Jz2yCRd5ST1p2gUqFB5wsSQfdm3jaFfg7   \\t\\n'\n  ];\n\n  // livenet p2sh\n  var P2SHLivenet = [\n    '342ftSRCvFHfCeFFBuz4xwbeqnDw6BGUey',\n    '33vt8ViH5jsr115AGkW6cEmEz9MpvJSwDk',\n    '37Sp6Rv3y4kVd1nQ1JV5pfqXccHNyZm1x3',\n    '3QjYXhTkvuj8qPaXHTTWb5wjXhdsLAAWVy',\n    '\\t \\n3QjYXhTkvuj8qPaXHTTWb5wjXhdsLAAWVy \\r'\n  ];\n\n  // testnet p2sh\n  var P2SHTestnet = [\n    '2N7FuwuUuoTBrDFdrAZ9KxBmtqMLxce9i1C',\n    '2NEWDzHWwY5ZZp8CQWbB7ouNMLqCia6YRda',\n    '2MxgPqX1iThW3oZVk9KoFcE5M4JpiETssVN',\n    '2NB72XtkjpnATMggui83aEtPawyyKvnbX2o'\n  ];\n\n  //livenet bad checksums\n  var badChecksums = [\n    '15vkcKf7gB23wLAnZLmbVuMiiVDc3nq4a2',\n    '1A6ut1tWnUq1SEQLMr4ttDh24wcbj4w2TT',\n    '1BpbpfLdY7oBS9gK7aDXgvMgr1DpvNH3B2',\n    '1Jz2yCRd5ST1p2gUqFB5wsSQfdmEJaffg7'\n  ];\n\n  //livenet non-base58\n  var nonBase58 = [\n    '15vkcKf7g#23wLAnZLmb$uMiiVDc3nq4a2',\n    '1A601ttWnUq1SEQLMr4ttDh24wcbj4w2TT',\n    '1BpbpfLdY7oBS9gK7aIXgvMgr1DpvNH3B2',\n    '1Jz2yCRdOST1p2gUqFB5wsSQfdmEJaffg7'\n  ];\n\n  //testnet valid\n  var PKHTestnet = [\n    'n28S35tqEMbt6vNad7A5K3mZ7vdn8dZ86X',\n    'n45x3R2w2jaSC62BMa9MeJCd3TXxgvDEmm',\n    'mursDVxqNQmmwWHACpM9VHwVVSfTddGsEM',\n    'mtX8nPZZdJ8d3QNLRJ1oJTiEi26Sj6LQXS'\n  ];\n\nvar xprivkey = 'xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi';\nvar xpubkey = 'xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8NqtwybGhePY2gZ29ESFjqJoCu1Rupje8YtGqsefD265TMg7usUDFdp6W1EGMcet8';\nvar xpubkeyTestnet = 'tpubD6NzVbkrYhZ4WZaiWHz59q5EQ61bd6dUYfU4ggRWAtNAyyYRNWT6ktJ7UHJEXURvTfTfskFQmK7Ff4FRkiRN5wQH8nkGAb6aKB4Yyeqsw5m';\nvar json = '{\"network\":\"livenet\",\"depth\":0,\"fingerPrint\":876747070,\"parentFingerPrint\":0,\"childIndex\":0,\"chainCode\":\"873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508\",\"publicKey\":\"0339a36013301597daef41fbe593a02cc513d0b55527ec2df1050e2e8ff49c85c2\",\"checksum\":-1421395167,\"xpubkey\":\"xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8NqtwybGhePY2gZ29ESFjqJoCu1Rupje8YtGqsefD265TMg7usUDFdp6W1EGMcet8\"}';\nvar derived_0_1_200000 = 'xpub6BqyndF6rkBNTV6LXwiY8Pco8aqctqq7tGEUdA8fmGDTnDJphn2fmxr3eM8Lm3m8TrNUsLbEjHvpa3adBU18YpEx4tp2Zp6nqax3mQkudhX';","var _ = require('lodash');\n\n/**\n * Determines whether a string contains only hexadecimal values\n *\n * @name JSUtil.isHexa\n * @param {string} value\n * @return {boolean} true if the string is the hexa representation of a number\n */\nvar isHexa = function isHexa(value) {\n  if (!_.isString(value)) {\n    return false;\n  }\n  return /^[0-9a-fA-F]+$/.test(value);\n};\n\n/**\n * @namespace JSUtil\n */\nexport class JS {\n  /**\n   * Test if an argument is a valid JSON object. If it is, returns a truthy\n   * value (the json object decoded), so no double JSON.parse call is necessary\n   *\n   * @param {string} arg\n   * @return {Object|boolean} false if the argument is not a JSON string.\n   */\n  isValidJSON(arg) {\n    var parsed;\n    if (!_.isString(arg)) {\n      return false;\n    }\n    try {\n      parsed = JSON.parse(arg);\n    } catch (e) {\n      return false;\n    }\n    if (typeof(parsed) === 'object') {\n      return true;\n    }\n    return false;\n  }\n//   isHexa: isHexa,\n//   isHexaString: isHexa,\n\n  /**\n   * Clone an array\n   */\n  cloneArray(array) {\n    return [].concat(array);\n  }\n\n  /**\n   * Define immutable properties on a target object\n   *\n   * @param {Object} target - An object to be extended\n   * @param {Object} values - An object of properties\n   * @return {Object} The target object\n   */\n  defineImmutable(target, values) {\n    Object.keys(values).forEach(function(key){\n      Object.defineProperty(target, key, {\n        configurable: false,\n        enumerable: true,\n        value: values[key]\n      });\n    });\n    return target;\n  }\n  /**\n   * Checks that a value is a natural number, a positive integer or zero.\n   *\n   * @param {*} value\n   * @return {Boolean}\n   */\n  isNaturalNumber(value) {\n    return typeof value === 'number' &&\n      isFinite(value) &&\n      Math.floor(value) === value &&\n      value >= 0;\n  }\n}","var _ = require('lodash');\n\nexport class PreCondition {\n  checkState(condition, message) {\n    if (!condition) {\n      throw new Error(\n        `InvalidState`,\n      );\n    }\n  }\n  checkArgument(condition, argumentName, message, docsPath) {\n    if (!condition) {\n      throw new Error(\n        `InvalidArgument`,\n      );\n    }\n  }\n  checkArgumentType(argument, type, argumentName) {\n    argumentName = argumentName || '(unknown name)';\n    if (_.isString(type)) {\n      if (type === 'Buffer') {\n        var BufferUtil = require('./buffer');\n        if (!BufferUtil.isBuffer(argument)) {\n          throw new Error(\n            `InvalidArgumentType`,\n          );\n        }\n      } else if (typeof argument !== type) {\n          throw new Error(\n            `InvalidArgumentType`,\n          );\n      }\n    } else {\n      if (!(argument instanceof type)) {\n        // throw new errors.InvalidArgumentType(argument, type.name, argumentName);\n          throw new Error(\n            `InvalidArgumentType`,\n          );\n      }\n    }\n  }\n}","// @flow\n\nfunction uintOrNaN (v) {\n    if (typeof v !== 'number') return NaN\n    if (!isFinite(v)) return NaN\n    if (Math.floor(v) !== v) return NaN\n    if (v < 0) return NaN\n    return v\n}\n\nfunction blackjack (utxos, outputs) {\n    if (!isFinite(uintOrNaN(outputs.targetValue))) return []\n\n    var inAccum = 0\n    var inputs = []\n    var targetValue = outputs.targetValue;\n\n    for (var i = 0; i < utxos.length; ++i) {\n        var input = utxos[i]\n\n        inAccum += uintOrNaN(input.balance)\n        inputs.push(input)\n\n        if (inAccum >= targetValue)\n            return inputs;\n    }\n\n    return []\n}\n\nfunction utxoScore (x) {\n    return x.balance\n}\n\nfunction numberWithCommas(x) {\n    var number = x.toString();\n    var beforePeriod = number.slice(0, number.indexOf(\".\"));\n    var afterPeriod = number.slice(number.indexOf(\".\"), number.length);\n    var numberWithComma = beforePeriod.replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n\n    return numberWithComma + afterPeriod;\n}\n\nfunction showSnackBar(msg) {\n    var $snackbar = $('#snackbar');\n    if ($snackbar.length === 0) {\n        $('body').append('<div id=\"snackbar\"></div>');\n        $snackbar = $('#snackbar');\n    }\n\n    $snackbar.text(msg);\n    $snackbar.addClass(\"show\");\n    setTimeout(function(){\n        $snackbar.removeClass(\"show\");\n    }, 3000);\n}\n\nfunction changeDateFormatKr(date) {\n    var year = date.getFullYear();\n    var month = (1 + date.getMonth());\n    month = month >= 10 ? month : '0' + month;\n    var day = date.getDate();\n    day = day >= 10 ? day : '0' + day;\n\n    var hh = date.getHours();\n    hh = hh >= 10 ? hh : '0' + hh;\n    var mm = date.getMinutes();\n    mm = mm >= 10 ? mm : '0' + mm;\n\n    return  year + '.' + month + '.' + day + \" \" + hh + \":\" + mm;\n}\n\nfunction filterNumberOnly(input) {\n    return (input != null ? input.replace(/[^0-9.]/gi, '') : input);\n}\n\nimport * as BufferLayout from 'buffer-layout';\n\nimport {Transaction} from './tx-dapp';\nimport {BvmAddr} from './bvm-addr';\nimport {SystemController} from './sys-dapp';\nimport JS from './js';\nimport PreCondition from './preconditions';\n\nfunction toDisplayAmount(number) {\n    if (typeof number !== 'number') {\n        number = Number(number);\n    }\n\n    number = number.toFixed(8);\n    number = number.replace(/(0+$)/, \"\");\n\n    if (number.indexOf(\".\") === (number.length - 1)) {\n        number = number.substr(0, number.length - 1)\n    }\n\n    return number;\n}\n\n/**\n * Matched a condiction which created by executing a transaction generated by sealWithSignature()\n * \n * @typedef {Object} SignatureCond\n * @property {string} type string type for 'signature'\n * @property {BvmAddr} from Bvm Address for whom signed the transaction\n */\nexport type SignatureCond = {\n  type: 'signature',\n  from: BvmAddr,\n};\n\n/**\n * Matched a condiction which created by executing a transaction generated by sealWithDatetime()\n\n * @typedef {Object} TimestampCond\n * @property {string} type string type 'timestamp'\n * @property {BvmAddr} from Bvm Address from which `sealWithDatetime()` will be accepted from\n * @property {Date} when The timestamp that will be trigger\n */\nexport type TimestampCond = {\n  type: 'timestamp',\n  from: BvmAddr,\n  when: Date,\n};\n\n/**\n * Payment consist of payment's amount and payee's bvm address\n * \n * @typedef {Object} Payment\n * @property {number} amount Amount of difs\n * @property {BvmAddr} to Bvm Address of the payee\n */\nexport type Payment = {\n  amount: number,\n  to: BvmAddr,\n};\n\n/**\n * Condition to release a payment\n * \n * @typedef {SignatureCond|TimestampCond} BudgetCond\n */\nexport type BudgetCond = SignatureCond | TimestampCond;\n\n/**\n *  Serialie a Payment into buffer to transport on the network.\n * \n * @private\n */\nfunction serializePayment(payment: Payment): Buffer {\n  const toData = payment.to.converseToBuffer();\n  const data = Buffer.alloc(8 + toData.length);\n  data.writeUInt32LE(payment.amount, 0);\n  toData.copy(data, 8);\n  return data;\n}\n\n/**\n *  Serialize  a Datetime into buffer to transport on the network.\n * \n * @private\n */\nfunction serializeTime(when: Date): Buffer {\n  const data = Buffer.alloc(8 + 20);\n  data.writeUInt32LE(20, 0); // size of timestamp as u64\n\n  function iso(date) {\n    function pad(number) {\n      if (number < 10) {\n        return '0' + number;\n      }\n      return number;\n    }\n\n    return (\n      date.getUTCFullYear() +\n      '-' +\n      pad(date.getUTCMonth() + 1) +\n      '-' +\n      pad(date.getUTCDate()) +\n      'T' +\n      pad(date.getUTCHours()) +\n      ':' +\n      pad(date.getUTCMinutes()) +\n      ':' +\n      pad(date.getUTCSeconds()) +\n      'Z'\n    );\n  }\n  data.write(iso(when), 8);\n  return data;\n}\n\n/**\n * Serialize a BudgetCond into buffer to transport on the network.\n * \n * @private\n */\nfunction serializeCond(condition: BudgetCond) {\n  switch (condition.type) {\n    case 'timestamp': {\n      const date = serializeTime(condition.when);\n      const from = condition.from.converseToBuffer();\n\n      const data = Buffer.alloc(4 + date.length + from.length);\n      data.writeUInt32LE(0, 0); // Condition enum = Timestamp\n      date.copy(data, 4);\n      from.copy(data, 4 + date.length);\n      return data;\n    }\n    case 'signature': {\n      const from = condition.from.converseToBuffer();\n      const data = Buffer.alloc(4 + from.length);\n      data.writeUInt32LE(1, 0); // Condition enum = Signature\n      from.copy(data, 4);\n      return data;\n    }\n    default:\n      throw new Error(`Unknown condition type: ${condition.type}`);\n  }\n}\n\n/**\n * Factory class for transactions to interact with the Budget controller\n */\nexport class BudgetController {\n  /**\n   * Bvm Address that identifies the Budget controller\n   */\n  static get controllerId(): BvmAddr {\n    return new BvmAddr('Budget1111111111111111111111111111111111111');\n  }\n\n  /**\n   * The amount of space this controller requires\n   */\n  static get size(): number {\n    return 128;\n  }\n\n  /**\n   * Creates a timestamp condition\n   */\n  static datetimeCond(from: BvmAddr, when: Date): TimestampCond {\n    return {\n      type: 'timestamp',\n      from,\n      when,\n    };\n  }\n\n  /**\n   * Creates a signature condition\n   */\n  static signatureCond(from: BvmAddr): SignatureCond {\n    return {\n      type: 'signature',\n      from,\n    };\n  }\n\n  /**\n   * Generates a transaction that transfers difs once any of the conditions are met\n   */\n  static pay(\n    from: BvmAddr,\n    controller: BvmAddr,\n    to: BvmAddr,\n    amount: number,\n    ...conditions: Array<BudgetCond>\n  ): Transaction {\n    const data = Buffer.alloc(1024);\n    let pos = 0;\n    data.writeUInt32LE(0, pos); // NewBudget instruction\n    pos += 4;\n\n    switch (conditions.length) {\n      case 0: {\n        data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay\n        pos += 4;\n\n        {\n          const payment = serializePayment({amount, to});\n          payment.copy(data, pos);\n          pos += payment.length;\n        }\n        const trimmedData = data.slice(0, pos);\n\n        const transaction = SystemController.createNewAccount(\n          from,\n          controller,\n          amount,\n          amount,\n          trimmedData.length,\n          this.controllerId,\n        );\n\n        return transaction.addOperations({\n          keys: [\n            {pubkey: to, isSigner: false, isDebitable: false},\n            {pubkey: controller, isSigner: false, isDebitable: true},\n          ],\n          controllerId: this.controllerId,\n          data: trimmedData,\n        });\n      }\n      case 1: {\n        data.writeUInt32LE(1, pos); // BudgetExpr enum = After\n        pos += 4;\n        {\n          const condition = conditions[0];\n\n          const conditionData = serializeCond(condition);\n          conditionData.copy(data, pos);\n          pos += conditionData.length;\n\n          data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay\n          pos += 4;\n\n          const paymentData = serializePayment({amount, to});\n          paymentData.copy(data, pos);\n          pos += paymentData.length;\n        }\n        const trimmedData = data.slice(0, pos);\n\n        const transaction = SystemController.createNewAccount(\n          from,\n          controller,\n          amount,\n          amount,\n          trimmedData.length,\n          this.controllerId,\n        );\n\n        return transaction.addOperations({\n          keys: [{pubkey: controller, isSigner: false, isDebitable: true}],\n          controllerId: this.controllerId,\n          data: trimmedData,\n        });\n      }\n\n      case 2: {\n        data.writeUInt32LE(2, pos); // BudgetExpr enum = Or\n        pos += 4;\n\n        for (let condition of conditions) {\n          const conditionData = serializeCond(condition);\n          conditionData.copy(data, pos);\n          pos += conditionData.length;\n\n          data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay\n          pos += 4;\n\n          const paymentData = serializePayment({amount, to});\n          paymentData.copy(data, pos);\n          pos += paymentData.length;\n        }\n        const trimmedData = data.slice(0, pos);\n\n        const transaction = SystemController.createNewAccount(\n          from,\n          controller,\n          amount,\n          amount,\n          trimmedData.length,\n          this.controllerId,\n        );\n\n        return transaction.addOperations({\n          keys: [{pubkey: controller, isSigner: false, isDebitable: true}],\n          controllerId: this.controllerId,\n          data: trimmedData,\n        });\n      }\n\n      default:\n        throw new Error(\n          `A maximum of two conditions are support: ${\n            conditions.length\n          } provided`,\n        );\n    }\n  }\n\n  /**\n   * Generates a transaction that transfers difs once both conditions are met\n   */\n  static payOnAll(\n    from: BvmAddr,\n    controller: BvmAddr,\n    to: BvmAddr,\n    amount: number,\n    condition1: BudgetCond,\n    condition2: BudgetCond,\n  ): Transaction {\n    const data = Buffer.alloc(1024);\n    let pos = 0;\n    data.writeUInt32LE(0, pos); // NewBudget instruction\n    pos += 4;\n\n    data.writeUInt32LE(3, pos); // BudgetExpr enum = And\n    pos += 4;\n\n    for (let condition of [condition1, condition2]) {\n      const conditionData = serializeCond(condition);\n      conditionData.copy(data, pos);\n      pos += conditionData.length;\n    }\n\n    data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay\n    pos += 4;\n\n    const paymentData = serializePayment({amount, to});\n    paymentData.copy(data, pos);\n    pos += paymentData.length;\n\n    const trimmedData = data.slice(0, pos);\n\n    const transaction = SystemController.createNewAccount(\n      from,\n      controller,\n      amount,\n      amount,\n      trimmedData.length,\n      this.controllerId,\n    );\n\n    return transaction.addOperations({\n      keys: [{pubkey: controller, isSigner: false, isDebitable: true}],\n      controllerId: this.controllerId,\n      data: trimmedData,\n    });\n  }\n\n  /**\n   * Generates a transaction that applies a timestamp, which could enable a\n   * pending payment to proceed.\n   */\n  static sealWithDatetime(\n    from: BvmAddr,\n    controller: BvmAddr,\n    to: BvmAddr,\n    when: Date,\n  ): Transaction {\n    const whenData = serializeTime(when);\n    const data = Buffer.alloc(4 + whenData.length);\n\n    data.writeUInt32LE(1, 0); // ApplyTimestamp instruction\n    whenData.copy(data, 4);\n\n    return new Transaction().addOperations({\n      keys: [\n        {pubkey: from, isSigner: true, isDebitable: true},\n        {pubkey: controller, isSigner: false, isDebitable: true},\n        {pubkey: to, isSigner: false, isDebitable: false},\n      ],\n      controllerId: this.controllerId,\n      data,\n    });\n  }\n\n  /**\n   * Generates a transaction that applies a signature, which could enable a\n   * pending payment to proceed.\n   */\n  static sealWithSignature(\n    from: BvmAddr,\n    controller: BvmAddr,\n    to: BvmAddr,\n  ): Transaction {\n    const dataLayout = BufferLayout.struct([BufferLayout.u32('instruction')]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 2, // ApplySignature instruction\n      },\n      data,\n    );\n\n    return new Transaction().addOperations({\n      keys: [\n        {pubkey: from, isSigner: true, isDebitable: true},\n        {pubkey: controller, isSigner: false, isDebitable: true},\n        {pubkey: to, isSigner: false, isDebitable: false},\n      ],\n      controllerId: this.controllerId,\n      data,\n    });\n  }\n}\n\n\nfunction getPath(internal_path, external_path) {\n  var bip_path = 0x8000002c;\n  var coin_path = 0x800000c8;\n  var account_path = 0x80000000;\n\n  return bip_path + '/' + coin_path + '/' + account_path + '/' + internal_path + '/' + external_path;\n}\n\nfunction getPathFromAddress(wallet, address) {\n  for (var idx in wallet.internal_addresses) {\n      if (address === wallet.internal_addresses[idx].address) {\n          return this.getPath(1, idx);\n      }\n  }\n\n  for(idx in wallet.external_addresses) {\n      if (address === wallet.external_addresses[idx].address) {\n          return this.getPath(0, idx);\n      }\n  }\n\n  return '';\n}\n\n\nvar buffer = require('buffer');\nvar assert = require('assert');\n\n// var js = require('./js');\n// var $ = require('./preconditions');\n\n\n\nfunction equals(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  var length = a.length;\n  for (var i = 0; i < length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n  * Fill a buffer with a value.\n  *\n  * @param {Buffer} buffer\n  * @param {number} value\n  * @return {Buffer}\n  */\n// function fill(buffer, value) {\n//   PreCondition.checkArgumentType(buffer, 'Buffer', 'buffer');\n//   PreCondition.checkArgumentType(value, 'number', 'value');\n//   var length = buffer.length;\n//   for (var i = 0; i < length; i++) {\n//     buffer[i] = value;\n//   }\n//   return buffer;\n// }\n\n\nconst buffer_1 = require(\"buffer\");\nclass BufferUtil {\n    static fromHex(source) {\n        const data = source.match(/.{1,2}/g).map(x => parseInt(x, 16));\n        return new Uint8Array(data);\n    }\n    static fromBase64(source) {\n        return Uint8Array.from(buffer_1.Buffer.from(source, 'base64'));\n    }\n    static fromString(source) {\n        const buffer = new ArrayBuffer(source.length);\n        const view = new DataView(buffer);\n        for (let i = 0; i < source.length; i++) {\n            view.setUint8(i, source.charCodeAt(i));\n        }\n        return new Uint8Array(buffer);\n    }\n    static toString(source) {\n        const data = [];\n        source.forEach(x => {\n            data.push(String.fromCharCode(x));\n        });\n        return data.join('');\n    }\n    static toHex(sources) {\n        const data = [];\n        sources.forEach(x => {\n            data.push(x.toString(16).padStart(2, '0'));\n        });\n        return data.join('');\n    }\n    static toBase64(sources) {\n        return buffer_1.Buffer.from(sources).toString('base64');\n    }\n    static concat(a, b) {\n        const c = new Uint8Array(a.length + b.length);\n        c.set(a);\n        c.set(b, a.length);\n        return c;\n    }\n}\n\n\nfunction binarySearch(sortedArray, item) {\n  let lowIdx = 0;\n  let highIdx = sortedArray.length - 1;\n  while (lowIdx <= highIdx) {\n      const midIdx = Math.floor((lowIdx + highIdx) / 2);\n      if (sortedArray[midIdx] === item) {\n          return midIdx;\n      }\n      else if (sortedArray[midIdx] < item) {\n          lowIdx = midIdx + 1;\n      }\n      else {\n          highIdx = midIdx - 1;\n      }\n  }\n  return null;\n}","// @flow\n\n\n////////////////////////////////////////////////////////////////////////////////////\n// const request = require(\"request\");\nconst path = require('path');\n\nconst Web3 = require('web3');\n//const AbiCoder = require('web3-eth-abi');\n\nconst Promise = require(\"bluebird\");\n// const truffle_contract = require('truffle-contract');\nconst assert = require('assert');\n// const tracer = require('../EVM2Code');\nconst fs = require('fs');\nconst locks = require('locks');\n// mutex\nconst mutex = locks.createMutex();\nconst async = require('async');\n\nconst g_cwd = \"connection/ethereum\";\nvar g_data_feedback = false;\n\n/// the file that used to keep exploit script\nconst g_exploit_path = \"./exploit.txt\";\n\n/// json file\nlet g_target_artifact;\nlet g_attack_artifact;\n// truffle-contract abstractions\nlet g_targetContract;\nlet g_attackContract;\n\n// web3 abstractions\nlet web3;\nlet Provider;\nlet g_account_list = [];\n/// the bookkeeping variable abi\nlet g_bookKeepingAbi;\n\nlet g_attackStmt_set;\nlet g_targetStmt_set;\n// tracer abstractions at instruction level\nlet g_attackIns_map;\nlet g_targetIns_map;\n// static dependency\nlet g_staticDep_attack;\nlet g_staticDep_target;\n\n/// the gas amount\nconst gasMax = 8000000000;\n/// dynamci array\nconst dyn_array_min = 1;\nconst dyn_array_max = 5;\n/// the maximum length of seed_callSequence\nconst sequence_maxLen = 4;\n\n/// the call sequence to be executed\nlet g_callSequen_list = [];\n/// another new call seqeunce\nlet g_callSequen_start = false;\n\n/// the current executed call, don't initialized because it is assigned again\n/// we will mutate the inputs of this call function \nlet g_lastCall_exec;\n/// the current index in g_callSequen_cur, it corresponds to \"g_lastCall_exec\"\nlet g_callIndex_cur = 0;\n/// the executed call sequence\nlet g_callSequen_cur = [];\n/// the trace of a transaction\nlet g_trans_stmt_trace = [];\n/// the trace of a call sequence\nlet g_sequen_stmt_trace = [];\n/// the key is i^th call in sequence, the value is read/write variable\nlet g_stmt_read_map = new Map();\nlet g_stmt_write_map = new Map();\n/// the set of dynamic dependencies in a call sequence\nlet g_sequen_depen_set = new Set();\n/// the set of all dynamic dependencies in this contract until now\nlet g_contra_depen_set = new Set();\n\n/// the hash of previous transactions\nlet g_pre_txHash_set = new Set();\nlet g_startTime, g_endTime;\nlet g_timeDiff;\n\n/// the current call that is executed\nlet g_callFun_cur;\n/// the candidate abi that can be used to start transaction\nlet g_cand_sequence = [];\nlet g_fuzzing_finish = false;\n\n/// the account pools\nlet g_from_account;\n/// the send and call statements\nlet g_send_call_set;\n/// whether it has static control dependencies or write variable\nlet g_send_call_found;\n\nlet  g_fuzz_start_time = 0;\nconst FUZZ_TIME_SCALE = 10 * 60 * 1000;\n\nfunction unlockAccount(){\n  /// it is initialized by the blockchain, \n  /// for example, /home/hjwang/Tools/SCFuzzer/test_geth/data/keystore\n  var g_from_account;\n  web3.eth.getAccounts().then(e => {\n    g_from_account = e[0];\n    g_account_list.push(e[0]);\n    console.log(\"Account[0]: \" + g_from_account);\n  }).then(() => {\n    /// unlock initial user, which is also miner account\n    web3.eth.personal.unlockAccount(g_from_account, \"123456\", 200 * 60 * 60)\n      .then(() => {\n        console.log('Account unlocked!');\n      })\n      .catch(() => {\n        console.log('Account unlock failed!');\n      });\n  }).catch(() => {\n    console.log('Cannot read account info!');\n  });\n}\n\nimport {BvmAcct} from './bvm-acct';\nimport {BvmAddr} from './bvm-addr';\nimport {ControllerLoader} from './dapp-mounter';\nimport type {Connection} from './netutility';\n\nfunction setProvider(httpRpcAddr){\n  Provider = new Web3.providers.HttpProvider(httpRpcAddr);\n  web3 = new Web3(new Web3.providers.HttpProvider(httpRpcAddr));\n  assert(web3);\n}\n\nfunction test_deployed(artifact_path){\n  let artifact = require(path.relative(g_cwd, artifact_path));\n  let network_id = Object.keys(artifact[\"networks\"])[0];\n  return network_id!=undefined;\n}\n\n////////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Factory class for transactions to interact with a controller loader\n */\nexport class NativeControllerLoader {\n  /**\n   * Bvm Address that identifies the NativeControllerLoader\n   */\n  static get controllerId(): BvmAddr {\n    return new BvmAddr('NativeLoader1111111111111111111111111111111');\n  }\n\n  /**\n   * Loads a native controller\n   *\n   * @param connection The connection to use\n   * @param payer System account that pays to load the controller\n   * @param controllerName Name of the native controller\n   */\n  static load(\n    connection: Connection,\n    payer: BvmAcct,\n    controllerName: string,\n  ): Promise<BvmAddr> {\n    const bytes = [...Buffer.from(controllerName)];\n    const controller = new BvmAcct();\n    return ControllerLoader.load(\n      connection,\n      payer,\n      controller,\n      NativeControllerLoader.controllerId,\n      bytes,\n    );\n  }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////\nasync function get_instance(artifact_path){\n  // console.log(artifact_path);\n  let artifact = require(path.relative(g_cwd, artifact_path));\n  //let network_id = Object.keys(artifact[\"networks\"])[0];\n  // let conf = {\n  //   contract_name:artifact[\"contractName\"],\n  //   abi:  artifact[\"abi\"],                     // Array; required.  Application binary interface.\n  //   unlinked_binary: artifact[\"bytecode\"],       // String; optional. Binary without resolve library links.\n  //   address: artifact[\"networks\"][network_id][\"address\"],               // String; optional. Deployed address of contract.\n  //   network_id: parseInt(network_id),            // String; optional. ID of network being saved within abstraction.\n  //   default_network: parseInt(network_id)       // String; optional. ID of default network this abstraction should use.\n  // };\n  //console.log(artifact);\n  let MyContract = truffle_contract(artifact);\n  //console.log(MyContract);\n  MyContract.setProvider(Provider);\n  let instance = await MyContract.deployed();\n  //console.log(\"instance: \" + instance);\n  return instance;\n}\n\n/// load some static information for the dynamic analysis. e.g., fuzzing\nasync function load(targetPath, attackPath, targetSolPath, attackSolPath){\n  g_attackContract = await get_instance(attackPath);\n  g_targetContract = await get_instance(targetPath);\n  g_attack_artifact = require(path.relative(g_cwd, attackPath));\n  g_target_artifact = require(path.relative(g_cwd, targetPath));\n  \n  /// add the attack contract address\n  g_account_list.push(g_attackContract.address);\n  /// find bookkeeping variable\n  g_bookKeepingAbi = await findBookKeepingAbi(g_targetContract.abi);\n  /// all the possible abi, then we use to synthesize the call sequence\n  g_cand_sequence = [];\n  await findCandSequence(g_targetContract.abi, g_attackContract.abi);\n\n  /// the set of statements, which may be used for computing experimental results\n  g_attackStmt_set = await buildStmtSet(g_attack_artifact.sourcePath,\n                                               g_attack_artifact.deployedSourceMap,\n                                               g_attack_artifact.source);\n  g_targetStmt_set = await buildStmtSet(g_target_artifact.sourcePath,\n                                               g_target_artifact.deployedSourceMap,\n                                               g_target_artifact.source);     \n  \n  /// the map that the instruction corresponds to the statement \n  /// the form: [ '239JUMPI', 'Attack_SimpleDAO0.sol:1' ]\n  /// where 239 is the offset, JUMPI is the instruction\n  g_attackIns_map = await buildInsMap(g_attack_artifact.sourcePath,\n                                             g_attack_artifact.deployedBytecode,\n                                             g_attack_artifact.deployedSourceMap,\n                                             g_attack_artifact.source);\n  g_targetIns_map = await buildInsMap(g_target_artifact.sourcePath,\n                                             g_target_artifact.deployedBytecode,\n                                             g_target_artifact.deployedSourceMap,\n                                             g_target_artifact.source);\n\n  /// the static dependencies\n  /// The form:\n  // { Read: { 'SimpleDAO.sol:17': [ 'credit' ] },\n  //  Write: { 'SimpleDAO.sol:8': [ 'owner' ] },\n  //  CDepen: { 'SimpleDAO.sol:21': [ 'SimpleDAO.sol:22' ] } }\n  // console.log(\"arriving here\");\n  g_staticDep_attack = await buildStaticDep(attackSolPath);\n  g_staticDep_target = await buildStaticDep(targetSolPath);\n\n  g_send_call_set = await buildMoneySet(targetSolPath);\n  g_send_call_found = await buildRelevantDepen(g_staticDep_target, g_send_call_set);\n  console.log(g_send_call_found);\n\n  // /// clear the exploit script\n  // if(fs.existsSync(g_exploit_path)){\n  //   fs.unlinkSync(g_exploit_path);\n  // }\n\n  return {\n   accounts: g_account_list,\n   attack_adds: g_attackContract.address,\n   target_adds: g_targetContract.address,\n   attack_abi: g_attackContract.abi,\n   target_abi: g_targetContract.abi\n  };\n}\n\nfunction buildRelevantDepen(staticDep_target, send_call_set){\n  var send_call_found = build_relevant_depen(staticDep_target, send_call_set);\n  return send_call_found;\n} \n\nconst  build_relevant_depen = (staticDep_target, send_call_set) => {\n  var send_call_found = new Set();\n\n  // var write_target_map = staticDep_target[\"Write\"];\n  // var cd_target_map = staticDep_target[\"CDepen\"];\n\n  // for(var step of send_call_set){\n  //   if(!write_target_map.hasOwnProperty(step) && !cd_target_map.hasOwnProperty(step)){\n  //     send_call_found.add(step);\n  //   }\n  // }\n\n  return send_call_found; \n}\n\nfunction buildMoneySet(targetSolPath){\n  var send_call_set = build_sendCall_set(targetSolPath);\n  return send_call_set;\n}\n\nfunction buildStaticDep(fileName){\n  var execSync = require('child_process').execSync;\n  var cmdStr = \"python3 ./connection/buildDepen.py \" + fileName;\n  var output = execSync(cmdStr);\n  var staticDep = JSON.parse(output);\n  return staticDep;\n}\n\n\n/// the seed for dynamic fuzzing\nasync function seed() {\n  if (g_targetContract === undefined) {\n    throw \"Target contract is not deployed!\";\n  }\n  if (g_attackContract === undefined) {\n    throw \"Attack contract is not deployed!\";\n  }\n  // we only generate a call sequence\n  let callFun_list;\n  if(g_data_feedback){\n    callFun_list = await seed_callSequence();\n  }\n  else{\n    callFun_list = await seed_callSequence_withoutData();\n  }\n  // Execute the seed call sequence\n  mutex.lock(async function() {\n    try{\n      /// the call sequence to be executed\n      g_callSequen_list.push(callFun_list);\n      g_callSequen_start = true;\n      await exec_sequence_call();\n    }\n    catch (e) {\n      console.log(e);\n    }\n    finally{\n      mutex.unlock();\n    }\n  });\n\n  let execResult_list = \"successful!\";\n  return {\n    callFuns: callFun_list,\n    execResults: execResult_list\n  };\n}\n\n/// it will be executed after each transaction is executed\nasync function fuzz(txHash, ins_trace) {\n  const getTransaction = Promise.promisify(web3.eth.getTransaction);\n\n  if (g_attackContract === undefined) {\n    throw \"Attack contract is not loaded!\";\n  }\n  if (g_targetContract === undefined) {\n    throw \"Target contract is not loaded!\";\n  }\n\n  mutex.lock(async function() {\n    /// different transaction hash code, it is a string\n    if(!g_pre_txHash_set.has(txHash)){\n      /// store current txHash as previous txHash\n      g_pre_txHash_set.add(txHash);\n      try{\n        /// this is used to get the input of transaction \n        // let transObj = await getTransaction(txHash);\n        // console.log(\"receive: \"+ transObj.input);\n     \n        /// when attack_target == 0, it is on attack contract\n        /// when attack_target == 1, it is on target contract\n        var attack_target = 0;\n        /// ins_trace is the instrcution trace\n        /// g_stmt_trace is list of line nunmber trace\n        if(g_callFun_cur.to == g_targetContract.address){\n          attack_target = 1;\n        }\n        g_trans_stmt_trace = await buildTraceMap(ins_trace,\n                                                        g_attackIns_map,\n                                                        g_targetIns_map,\n                                                        attack_target);\n\n        // for(var stmt_trace of g_trans_stmt_trace){\n        //   if(g_send_call_found.has(stmt_trace)){\n        //     console.log(Date.now() - g_fuzz_start_time);\n        //     g_fuzzing_finish = true;\n        //     return \"Oracles are violated!\";\n        //   }\n        // }\n        /// the read/write variable in this transaction\n        /// we use it to switch the order of sequence\n        var WR_set = await buildWRSet(g_trans_stmt_trace,\n                                             g_staticDep_attack,\n                                             g_staticDep_target);\n        g_stmt_write_map[g_callIndex_cur -1] = WR_set[0];\n        g_stmt_read_map[g_callIndex_cur -1] = WR_set[1];\n\n        /// concate the transaction tract into sequence trace\n        g_sequen_stmt_trace = g_sequen_stmt_trace.concat(g_trans_stmt_trace);\n        /// the dynamic dependencies in the g_stmt_trace\n        g_sequen_depen_set = await buildDynDep(g_sequen_stmt_trace,\n                                                      g_staticDep_attack,\n                                                      g_staticDep_target);\n\n\n\n        /// before executing next transaction, we first mutate the just executed transaction\n        if(g_data_feedback){\n          await determine_funMutation();\n          await determine_sequenMutation();\n        }\n        else{\n          await determine_funMutation_withoutData();\n        }\n\n        /// execute a function call\n        await exec_sequence_call();\n      }\n      catch (e) {\n        console.log(e);\n      }\n      finally{\n        mutex.unlock();\n      }\n    }\n  });     \n}\n\nfunction buildDynDep(trace, staticDep_attack, staticDep_target){\n  var dynamicDep = buildDynamicDep(trace, staticDep_attack, staticDep_target);\n  return dynamicDep;\n}\n\nconst buildDynamicDep = (trace, staticDep_attack, staticDep_target) => {\n  var dynamicDep = new Set();\n  return dynamicDep;\n}\n\nconst byteToTrace = (ins_list, byteToSrc_attack, byteToSrc_target, attack_target) => {\n  var trace_list = [];\n  return trace_list;\n}\n\nfunction buildWRSet(stmt_trace, staticDep_attack, staticDep_target){\n  var WR_set = trace_WR(stmt_trace, staticDep_attack, staticDep_target);\n  return WR_set;\n}\n\nconst trace_WR = (stmt_trace, staticDep_attack, staticDep_target) => {\n  var stmt_write_set = new Set();\n  var stmt_read_set = new Set();\n  return [stmt_write_set, stmt_read_set];\n}\n\n\nfunction buildTraceMap(ins_list, byteToSrc_attack, byteToSrc_target, attack_target) {\n  var trace_list = byteToTrace(ins_list, byteToSrc_attack, byteToSrc_target, attack_target);\n  return trace_list;\n}\n\nconst json_parse = (fileName, srcmap, srccode) =>{\n  /// the window system may use '\\r\\n' as newline, but getLineFromPos would take them as two lines\n  // srccode = srccode.split('\\r\\n').join('\\n');\n  // srccode = srccode.split('\\n\\r').join('\\n');\n  // /// truncate the prefix of the path\n  // fileName = fileName.slice(fileName.lastIndexOf('/') +1);\n  // /// the first \"\" is set undefined (map ([s, l, f, j])), l,f,j does not exist.\n  // const src_number = srcmap\n  //       .split(\";\")\n  //       .map(l => l.split(\":\"))\n  //       .map(([s, l, f, j]) => ({ s: s === \"\" ? undefined : s, l, f, j }))\n  //       .reduce(\n  //         ([last, ...list], {s, l, f, j }) => [\n  //           {\n  //             s: parseInt(s || last.s, 10),\n  //             l: parseInt(l || last.l, 10),\n  //             f: parseInt(f || last.f, 10),\n  //             j: j || last.j\n  //           },\n  //           last,\n  //           ...list\n  //         ],\n  //         [{}]\n  //       )\n  //       .reverse()\n  //       .slice(1)\n  //       .map(\n  //         ({ s, l, f, j }) => `${fileName}:${getLineFromPos(srccode, s)}`\n  //       );\n  // // writeSrcIndex_list(src_number);\n  // return src_number;\n}\n\nconst stmtCollection = (src_number) =>{\n  var stmt_set = new Set();\n\tsrc_number.forEach(function(value, key, map){\n\t\tstmt_set.add(value);\n\t});\n\treturn stmt_set;\n}\n\n\nconst build_sendCall_set = (targetSolPath) => {\n  var send_call_set = new Set();\n  // var srccode = fs.readFileSync(targetSolPath, \"utf-8\"); \n  // srccode = srccode.split('\\r\\n').join('\\n');\n  // srccode = srccode.split('\\n\\r').join('\\n');\n  // var code_list = srccode.split('\\n');\n  // var lineNum = 1;\n  // for (var line of code_list){\n  //   if(line.indexOf(\"send(\") != -1 || line.indexOf(\"send (\") != -1 || line.indexOf(\"call.value\") != -1){\n  //     var content =  targetSolPath + \":\" + lineNum;\n  //     var lastIndex = content.lastIndexOf(\"/\");\n  //     content = content.slice(lastIndex +1);\n  //     send_call_set.add(content);\n  //   }\n  //   lineNum++;\n  // }\n  return send_call_set;\n}\n\n/// each byte to the source code\nconst byteToInstIndex = (src_number, binary) => {\n  const byteToSrc = new Map();\n  /// \"0x\" is removed from binary\n  // let byteIndex = 0;\n  // let instIndex = 0;\n  // /// for the binary code\n  // const binmap = Buffer.from(binary.substring(2), \"hex\");\n  // while (byteIndex < binmap.length) {\n  //   const length = instructionLength(binmap[byteIndex]);\n  //   if(opCodeToString[binmap[byteIndex]] != undefined && src_number[instIndex] != undefined){\n  //     var key = byteIndex + opCodeToString[binmap[byteIndex]];\n  //     var value = src_number[instIndex];\n  //     byteToSrc[key] = value;\n  //   }\n  //   byteIndex += length;\n  //   instIndex += 1;\n  // }\n  // writeByteIndex_list(byteToSrc);\n  return byteToSrc;\n}\n\nfunction  buildInsMap(fileName, binary, srcmap, srccode) {\n  var src_number = json_parse(fileName, srcmap, srccode);\n  /// compute each instruction to its line number\n  var byteToSrc = byteToInstIndex(src_number, binary);\n  /// compute multiple instructions to their line number\n  /// we do not use multiple instructions to the line number again, \n  /// because it is difficult to recognize the seperator instruction, specially not executed completely due to gas limit\n  // var mulToSrc = mulbytesToSrcCode(byteToSrc);\n  // return mulToSrc; \n  return byteToSrc\n}\n\n\nfunction buildStmtSet(fileName, srcmap, srccode) {\n    var src_number = json_parse(fileName, srcmap, srccode);\n    var stmt_set = stmtCollection(src_number);\n    return stmt_set; \n  }\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////////","/**\n * @flow\n */\n\n\n\n////////////////////////////////////////////////////////////////////////////////////////////\n\n/// conver scientific number to string\nfunction uintToString(num){\n  var num_str = \"\" + num;\n  /// scientific number\n  var index = num_str.indexOf(\"+\");\n  if(index != -1){\n    var result = num_str[0];\n    var power_len = parseInt(num_str.slice(index +1), 10);\n    var power_index = 0;\n    while(power_index < power_len){\n      /// num_str[index-1:] is 'e+...'\n      if((power_index +2) < (index -1)){\n        result += num_str[power_index +2];\n      }\n      else{\n        result += '0';\n      }\n      power_index += 1;\n    }\n    return result;\n  }\n  else{\n    return num_str;\n  }\n}\n\n/// modify the 'input_orig_list' at 'input_index' with 'unum_diff' \nfunction modify_uint(input_orig_list, input_index, unum_diff){\n  var input_orig = input_orig_list[input_index];\n  if (typeof input_orig === 'string' || input_orig instanceof String){\n    /// it is primitive, e.g., uint\n    var input_orig_int = parseInt(input_orig, 10);\n    if(typeof unum_diff === \"number\" || unum_diff instanceof Number){\n      /// modify with the instant value\n      var input_modify = input_orig_int + unum_diff;\n      if(input_modify !== input_orig_int){\n        if(input_modify >= 1){\n          var modify_str = uintToString(input_modify)\n          return modify_str;\n        }\n        else{\n          return undefined;\n        }        \n      }\n      else{\n        return undefined;\n      }\n    }\n    else if(typeof unum_diff === 'string' || unum_diff instanceof String){\n      /// modify with 'xxx' times\n      var unum_diff_int = parseFloat(unum_diff, 10);\n      var input_modify = input_orig_int * unum_diff;\n      if(input_modify !== input_orig_int){\n        var modify_int =  Math.round(input_modify)\n        if(modify_int >= 1){\n          var modify_str = uintToString(Math.round(input_modify));\n          return modify_str;   \n        }\n        else{\n          return undefined;\n        }\n      }\n      else{\n        return undefined;\n      }\n    }\n  }\n  else if (input_orig instanceof Array){\n    /// generate a copy to mutate, otherwise the original input will be modified\n    input_orig = input_orig.slice()\n    /// select an element to mutate\n    var index = randomNum(0, input_orig.length);\n    var input_orig_int = parseInt(input_orig[index], 10);\n    if(typeof unum_diff === \"number\" || unum_diff instanceof Number){\n      var input_modify = input_orig_int + unum_diff;\n      if(input_modify !== input_orig_int){\n        if(input_modify >= 1){\n          var modify_str = uintToString(input_modify);\n          input_orig[index] = modify_str;\n        }\n        else{\n          return undefined;\n        }   \n        return input_orig;     \n      }\n      else{\n        return undefined;\n      }\n    }\n    else if(typeof unum_diff === 'string' || unum_diff instanceof String){\n      var unum_diff_int = parseFloat(unum_diff, 10);\n      var input_modify = input_orig_int * unum_diff;\n      if(input_modify !== input_orig_int){\n        var modify_int =  Math.round(input_modify)\n        if(modify_int >= 1){\n          var modify_str = uintToString(Math.round(input_modify));\n          input_orig[index] = modify_str;   \n        }\n        else{\n          input_orig[index] = '1';\n        }\n        return input_orig;         \n      }\n      else{\n        return undefined;\n      }\n    }\n  }\n  else{\n    /// no change, it needs to proceed further\n    return undefined;\n  }\n}\n\nasync function modify_callInput_uint(call, unum_diff) {\n  var param_list_set = new Set();\n  var input_type_list = call.abi.inputs;\n  var input_orig_list = call.param;\n  var param_i = 0;\n  var param_len = input_type_list.length;\n  /// for each element in input_orig_list to mutate\n  while(param_i < param_len){\n    /// the generated parameters\n    var param_list = [];\n    var modify_found = false;\n    var param_j = 0;\n    while(param_j < param_len){\n      /// we only consider the element that larger than param_i\n      if(modify_found == false && param_j >= param_i){\n        var input_type = input_type_list[param_j];\n        if(input_type.type.indexOf('uint') == 0){\n          var uint_param = modify_uint(input_orig_list, param_j, unum_diff);\n          if(uint_param !== undefined){\n            param_list.push(uint_param);\n            modify_found = true;\n          }\n          /// param_i can be speed up\n          param_i = param_j +1;\n        }\n        else{\n          /// it is not unit type\n          param_list.push(input_orig_list[param_j]);\n        }\n      }\n      else{\n        param_list.push(input_orig_list[param_j]);\n      }\n      param_j += 1;\n    } \n    /// has modified the element \n    if(modify_found){\n      param_list_set.add(param_list);\n    }\n    else{\n      /// there is no candidation for modification\n      break;\n    }\n  }\n  /// if there is no modification, param_list_set is empty\n  return param_list_set;\n}\n////////////////////////////////////////////////////////////////////////////////////////////\n\n\nimport assert from 'assert';\nimport BN from 'bn.js';\nimport * as BufferLayout from 'buffer-layout';\n\nimport * as Layout from './buffer-cntl';\nimport {BvmAcct} from './bvm-acct';\nimport {BvmAddr} from './bvm-addr';\nimport {SystemController} from './sys-dapp';\nimport {Transaction, TxOperation} from './tx-dapp';\nimport type {TxnSignature} from './tx-dapp';\nimport {launchThenAcknowledgeTx} from './launch-then-acknowledge-tx';\nimport type {Connection} from './netutility';\n\n/**\n * Some amount of assets\n */\nexport class AssetCount extends BN {\n  /**\n   * Convert to Buffer representation\n   */\n  convertToBuffer(): Buffer {\n    const zero_pad_array = super.toArray().reverse();\n    const new_buffer = Buffer.from(zero_pad_array);\n    if (new_buffer.length === 8) {\n      return new_buffer;\n    }\n    assert(new_buffer.length < 8, 'AssetCount beyond limitation');\n\n    const zeroPad = Buffer.alloc(8);\n    new_buffer.copy(zeroPad);\n    return zeroPad;\n  }\n\n  /**\n   * Construct a AssetCount from Buffer representation\n   */\n  static createFromBuffer(buffer: Buffer): AssetCount {\n    assert(buffer.length === 8, `Invalid buffer length: ${buffer.length}`);\n    return new BN(\n      [...buffer]\n        .reverse()\n        .map(i => `00${i.toString(16)}`.slice(-2))\n        .join(''),\n      16,\n    );\n  }\n}\n\n/**\n * Information about a asset\n */\ntype AssetDetail = {|\n  /**\n   * Total supply of assets\n   */\n  totalSupply: AssetCount,\n\n  /**\n   * Number of base 10 digits to the right of the decimal place\n   */\n  decimalsPosition: number,\n\n  /**\n   * Descriptive name of this asset\n   */\n  name: string,\n\n  /**\n   * Symbol for this asset\n   */\n  symbol: string,\n|};\n\n/**\n * @private\n */\nconst AssetDetailLayout = BufferLayout.struct([\n  Layout.uint64('totalSupply'),\n  BufferLayout.u8('decimalsPosition'),\n  Layout.rustString('name'),\n  Layout.rustString('symbol'),\n]);\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////\nasync function modify_callInput_uint_meaningful(call, unum_diff) {\n  /// the generated parameters\n  var param_list = [];\n  var input_type_list = call.abi.inputs;\n  var input_orig_list = call.param;\n  var param_i = 0;\n  var param_len = input_type_list.length;\n  var modify_found = false;\n  /// for each element in input_orig_list to mutate\n  while(param_i < param_len){\n    var input_type = input_type_list[param_i];\n    if(input_type.type.indexOf('address') == 0){\n      var adds_param = gen_address(input_type.type);\n      if(adds_param != input_orig_list[param_i]){\n        param_list.push(adds_param);\n        modify_found = true;\n      }\n      else{\n        param_list.push(input_orig_list[param_i]);\n      }\n    }\n    else if(input_type.type.indexOf('uint') == 0){\n      var uint_param = modify_uint(input_orig_list, param_i, unum_diff);\n      if(uint_param !== undefined){\n        if(uint_param == 'NaN'){\n          console.log('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa');\n        }\n        param_list.push(uint_param);\n        modify_found = true;\n      }\n      else{\n        param_list.push(input_orig_list[param_i]);\n      }\n    }\n    else{\n      param_list.push(input_orig_list[param_i]);\n    }\n    param_i += 1;\n  }\n  if(modify_found){\n    return [true, param_list];\n  }\n  else{\n    return [false, undefined];\n  }\n}\n\nasync function modify_callGas_meaningful(call, gas_diff) {\n  var times = parseFloat(gas_diff, 10);\n  var gas = Math.ceil(parseInt(call.gas, 10) * times);\n  if(gas < gasMax){\n    return [true, gas];\n  }\n  else{\n    return false;\n  }\n}\n\n\nasync function gen_callGas(gas_min, gas_max){\n  var gas_int = randomNum(gas_min, gas_max);\n  var gas_limit = uintToString(gas_int);\n  return gas_limit;\n}\n\n/// generate a call function based on the abi\nasync function gen_callFun(abi) {\n  var parameters = await gen_callInput(abi, 0, undefined);\n  var gasLimit = await gen_callGas(gasMin, gasMax);\n  var callFun = {\n    from: account_list[0],\n    to: abi.name.indexOf('vultron_') !== -1 ? attack_con.options.address : target_con.options.address,\n    abi: abi,\n    gas: gasLimit,\n    param: parameters\n  }\n  return callFun;\n}\n\n\nasync function modify_callFun_gas(call, gas_min, gas_max){\n  var gasLimit = await gen_callGas(gas_min, gas_max);\n  var callFun = {\n    from: call.from,\n    to: call.to,\n    abi: call.abi,\n    gas: gasLimit,\n    param: call.param.slice()\n  }\n  return callFun;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Information about a asset account\n */\ntype AssetAccountDetail = {|\n  /**\n   * The kind of asset this account holds\n   */\n  publickeyOfAsset: BvmAddr,\n\n  /**\n   * Owner of this account\n   */\n  publickeyOfOwner: BvmAddr,\n\n  /**\n   * Amount of assets this account holds\n   */\n  amountOfAsset: AssetCount,\n\n  /**\n   * The source account for the assets.\n   *\n   * If `source` is null, the source is this account.\n   * If `source` is not null, the `amount` of assets in this account represent\n   * an allowance of assets that may be transferred from the source account\n   */\n  publickeyOfSourceAccount: null | BvmAddr,\n\n  /**\n   * New amount of assets this delegate account was authorized to spend\n   * If `source` is null, originalAmount is zero\n   */\n  originalAmountOfAsset: AssetCount,\n|};\n\n/**\n * @private\n */\nconst TokenAccountDetailLayout = BufferLayout.struct([\n  Layout.pubKey('publickeyOfAsset'),\n  Layout.pubKey('publickeyOfOwner'),\n  Layout.uint64('amountOfAsset'),\n  BufferLayout.u8('sourceOption'),\n  Layout.pubKey('publickeyOfSourceAccount'),\n  Layout.uint64('originalAmountOfAsset'),\n]);\n\ntype AssetAndPubKey = [Token, BvmAddr]; // This type exists to workaround an esdoc parse error\n\n/**\n * The built-in asset controller\n */\nexport const SYSTEM_TOKEN_CONTROLLER_ID = new BvmAddr(\n  'Token11111111111111111111111111111111111111',\n  // 'BRC42TKNAAA60000000000000006',\n);\n\n/**\n * An ERC20-like Token\n */\nexport class Asset {\n  /**\n   * @private\n   */\n  connection: Connection;\n\n  /**\n   * The bvm address identifying this asset\n   */\n  assetId: BvmAddr;\n\n  /**\n   * Controller Identifier for the Token controller\n   */\n  controllerId: BvmAddr;\n\n  /**\n   * Create a Token object attached to the specific asset\n   *\n   * @param connection The connection to use\n   * @param assetId Bvm Address of the asset\n   * @param controllerId Optional asset controllerId, uses the system controllerId by default\n   */\n  constructor(\n    connection: Connection,\n    assetId: BvmAddr,\n    controllerId: BvmAddr = SYSTEM_TOKEN_CONTROLLER_ID,\n  ) {\n    Object.assign(this, {connection, assetId, controllerId});\n  }\n\n  /**\n   * Create a new Asset\n   *\n   * @param connection The connection to use\n   * @param ownerOfAsset User account that will own the returned Asset BvmAcct\n   * @param totalSupply Total supply of the new asset\n   * @param assetName Descriptive name of this asset\n   * @param assetSymbol Symbol for this asset\n   * @param assetDecimals Location of the decimal place\n   * @param controllerId Optional asset controllerId, uses the system controllerId by default\n   * @return Token object for the newly minted asset, Bvm Address of the Asset BvmAcct holding the total supply of new assets\n   */\n  static async createNewAsset(\n    connection: Connection,\n    ownerOfAsset: BvmAcct,\n    totalSupply: AssetCount,\n    assetName: string,\n    assetSymbol: string,\n    assetDecimals: number,\n    controllerId: BvmAddr = SYSTEM_TOKEN_CONTROLLER_ID,\n  ): Promise<AssetAndPubKey> {\n    const assetAccount = new BvmAcct();\n    const asset = new Asset(connection, assetAccount.pubKey, controllerId);\n    const publickeyOfStoreAssetAccount = await asset.createNewAssetAccount(ownerOfAsset, null);\n    let transaction;\n\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      Layout.uint64('totalSupply'),\n      BufferLayout.u8('assetDecimals'),\n      Layout.rustString('assetName'),\n      Layout.rustString('assetSymbol'),\n    ]);\n\n    let data = Buffer.alloc(1024);\n    {\n      const encodeLength = dataLayout.encode(\n        {\n          instruction: 0, // NewToken instruction\n          totalSupply: totalSupply.convertToBuffer(),\n          assetDecimals,\n          assetName,\n          assetSymbol,\n        },\n        data,\n      );\n      data = data.slice(0, encodeLength);\n    }\n\n\n    // Allocate memory for the assetAccount account\n    transaction = SystemController.createNewAccount(\n      ownerOfAsset.pubKey,\n      assetAccount.pubKey,\n      1,\n      0,\n      1 + data.length,\n      controllerId,\n    );\n    await launchThenAcknowledgeTx(connection, transaction, ownerOfAsset);\n\n    transaction = new Transaction().addOperations({\n      keys: [\n        {pubkey: assetAccount.pubKey, isSigner: true, isDebitable: false},\n        {pubkey: publickeyOfStoreAssetAccount, isSigner: false, isDebitable: true},\n      ],\n      controllerId,\n      data,\n    });\n\n    await launchThenAcknowledgeTx(\n      connection,\n      transaction,\n      ownerOfAsset,\n      assetAccount,\n    );\n\n    return [asset, publickeyOfStoreAssetAccount];\n  }\n\n  /**\n   * Create a new and empty asset account.\n   *\n   * This account may then be used as a `transferAsset()` or `authorize()` destination\n   *\n   * @param ownerAccount User account that will own the new asset account\n   * @param bvmAddrOfSourceAccount If not null, create a delegate account that when authorized\n   *               may transfer assets from this `source` account\n   * @return Bvm Address of the new empty asset account\n   */\n  async createNewAssetAccount(\n    ownerAccount: BvmAcct,\n    bvmAddrOfSourceAccount: null | BvmAddr = null,\n  ): Promise<BvmAddr> {\n    const assetAccount = new BvmAcct();\n    let transaction;\n    const dataLayout = BufferLayout.struct([BufferLayout.u32('instruction')]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 1, // NewTokenAccount instruction\n      },\n      data,\n    );\n    // Allocate memory for the asset\n    transaction = SystemController.createNewAccount(\n      ownerAccount.pubKey,\n      assetAccount.pubKey,\n      1,\n      0,\n      1 + TokenAccountDetailLayout.span,\n      this.controllerId,\n    );\n    await launchThenAcknowledgeTx(this.connection, transaction, ownerAccount);\n    // Initialize the asset account\n    const keys = [\n      {pubkey: assetAccount.pubKey, isSigner: true, isDebitable: true},\n      {pubkey: ownerAccount.pubKey, isSigner: false, isDebitable: false},\n      {pubkey: this.assetId, isSigner: false, isDebitable: false},\n    ];\n    if (bvmAddrOfSourceAccount) {\n      keys.push({pubkey: bvmAddrOfSourceAccount, isSigner: false, isDebitable: false});\n    }\n    transaction = new Transaction().addOperations({\n      keys,\n      controllerId: this.controllerId,\n      data,\n    });\n    await launchThenAcknowledgeTx(\n      this.connection,\n      transaction,\n      ownerAccount,\n      assetAccount,\n    );\n    return assetAccount.pubKey;\n  }\n\n  /**\n   * Retrieve asset information\n   */\n  async fetchAssetDetail(): Promise<AssetDetail> {\n    const fetchAccountDetail = await this.connection.fetchAccountDetail(this.assetId);\n    if (!fetchAccountDetail.owner.checkIfEquals(this.controllerId)) {\n      throw new Error(\n        `Invalid asset owner: ${JSON.stringify(fetchAccountDetail.owner)}`,\n      );\n    }\n\n    const data = Buffer.from(fetchAccountDetail.data);\n\n    if (data.readUInt8(0) !== 1) {\n      throw new Error(`Invalid asset data`);\n    }\n    const fetchTokenDetail = AssetDetailLayout.decode(data, 1);\n    fetchTokenDetail.totalSupply = AssetCount.createFromBuffer(fetchTokenDetail.totalSupply);\n    return fetchTokenDetail;\n  }\n\n  /**\n   * Retrieve account information\n   *\n   * @param account Bvm Address of the asset account\n   */\n  async fetchAccountDetail(account: BvmAddr): Promise<AssetAccountDetail> {\n    const fetchAccountDetail = await this.connection.fetchAccountDetail(account);\n    if (!fetchAccountDetail.owner.checkIfEquals(this.controllerId)) {\n      throw new Error(`Invalid asset account owner`);\n    }\n\n    const data = Buffer.from(fetchAccountDetail.data);\n    if (data.readUInt8(0) !== 2) {\n      throw new Error(`Invalid asset account data`);\n    }\n    const tokenAccountInfo = TokenAccountDetailLayout.decode(data, 1);\n\n    tokenAccountInfo.publickeyOfAsset = new BvmAddr(tokenAccountInfo.publickeyOfAsset);\n    tokenAccountInfo.publickeyOfOwner = new BvmAddr(tokenAccountInfo.publickeyOfOwner);\n    tokenAccountInfo.amountOfAsset = AssetCount.createFromBuffer(tokenAccountInfo.amountOfAsset);\n    if (tokenAccountInfo.sourceOption === 0) {\n      tokenAccountInfo.publickeyOfSourceAccount = null;\n      tokenAccountInfo.originalAmountOfAsset = new AssetCount();\n    } else {\n      tokenAccountInfo.publickeyOfSourceAccount = new BvmAddr(tokenAccountInfo.publickeyOfSourceAccount);\n      tokenAccountInfo.originalAmountOfAsset = AssetCount.createFromBuffer(\n        tokenAccountInfo.originalAmountOfAsset,\n      );\n    }\n\n    if (!tokenAccountInfo.publickeyOfAsset.checkIfEquals(this.assetId)) {\n      throw new Error(\n        `Invalid asset account bvmaddr: ${JSON.stringify(\n          tokenAccountInfo.publickeyOfAsset,\n        )} !== ${JSON.stringify(this.assetId)}`,\n      );\n    }\n    return tokenAccountInfo;\n  }\n\n  /**\n   * Transfer assets to another account\n   *\n   * @param owner Owner of the source asset account\n   * @param source Source asset account\n   * @param destination Destination asset account\n   * @param amount Number of assets to transfer\n   */\n  async transferAsset(\n    owner: BvmAcct,\n    source: BvmAddr,\n    destination: BvmAddr,\n    amount: number | AssetCount,\n  ): Promise<?TxnSignature> {\n    return await launchThenAcknowledgeTx(\n      this.connection,\n      new Transaction().addOperations(\n        await this.transferOperation(\n          owner.pubKey,\n          source,\n          destination,\n          amount,\n        ),\n      ),\n      owner,\n    );\n  }\n\n  /**\n   * Grant a third-party permission to transfer up the specified number of assets from an account\n   *\n   * @param ownerAccount Owner of the source asset account\n   * @param publickeyOfAssetAccount Bvm Address of the asset account\n   * @param publickeyOfDelegateAccount Token account authorized to perform a transfer assets from the source account\n   * @param amountAsset Maximum number of assets the delegate may transfer\n   */\n  async authorize(\n    ownerAccount: BvmAcct,\n    publickeyOfAssetAccount: BvmAddr,\n    publickeyOfDelegateAccount: BvmAddr,\n    amountAsset: number | AssetCount,\n  ): Promise<void> {\n    await launchThenAcknowledgeTx(\n      this.connection,\n      new Transaction().addOperations(\n        this.approveOperation(ownerAccount.pubKey, publickeyOfAssetAccount, publickeyOfDelegateAccount, amountAsset),\n      ),\n      ownerAccount,\n    );\n  }\n\n  /**\n   * Remove approval for the transfer of any remaining assets\n   *\n   * @param ownerAccount Owner of the source asset account\n   * @param publickeyOfAssetAccount Bvm Address of the asset account\n   * @param publickeyOfDelegateAccount Token account to revoke authorization from\n   */\n  unauthorize(\n    ownerAccount: BvmAcct,\n    publickeyOfAssetAccount: BvmAddr,\n    publickeyOfDelegateAccount: BvmAddr,\n  ): Promise<void> {\n    return this.authorize(ownerAccount, publickeyOfAssetAccount, publickeyOfDelegateAccount, 0);\n  }\n\n  /**\n   * Assign a new owner to the account\n   *\n   * @param ownerAccount Owner of the asset account\n   * @param publickeyOfAssetAccount Bvm Address of the asset account\n   * @param publickeyOfNewOwner New owner of the asset account\n   */\n  async setNewOwnerToAssetAccount(\n    ownerAccount: BvmAcct,\n    publickeyOfAssetAccount: BvmAddr,\n    publickeyOfNewOwner: BvmAddr,\n  ): Promise<void> {\n    await launchThenAcknowledgeTx(\n      this.connection,\n      new Transaction().addOperations(\n        this.setOwnerOperation(ownerAccount.pubKey, publickeyOfAssetAccount, publickeyOfNewOwner),\n      ),\n      ownerAccount,\n    );\n  }\n\n  /**\n   * Construct a Transfer instruction\n   *\n   * @param publickeyOfOwnerSourceAccount Owner of the source asset account\n   * @param publickeyOfSourceAccount Source asset account\n   * @param publickeyOfDestinationAccount Destination asset account\n   * @param amount Number of assets to transfer\n   */\n  async transferOperation(\n    publickeyOfOwnerSourceAccount: BvmAddr,\n    publickeyOfSourceAccount: BvmAddr,\n    publickeyOfDestinationAccount: BvmAddr,\n    amountAsset: number | AssetCount,\n  ): Promise<TxOperation> {\n    const fetchAccountDetail = await this.fetchAccountDetail(publickeyOfSourceAccount);\n    if (!publickeyOfOwnerSourceAccount.checkIfEquals(fetchAccountDetail.publickeyOfOwner)) {\n      throw new Error('BvmAcct owner mismatch');\n    }\n\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      Layout.uint64('amountAsset'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 2, // Transfer instruction\n        amountAsset: new AssetCount(amountAsset).convertToBuffer(),\n      },\n      data,\n    );\n\n    const keys = [\n      {pubkey: publickeyOfOwnerSourceAccount, isSigner: true, isDebitable: false},\n      {pubkey: publickeyOfSourceAccount, isSigner: false, isDebitable: true},\n      {pubkey: publickeyOfDestinationAccount, isSigner: false, isDebitable: true},\n    ];\n    if (fetchAccountDetail.publickeyOfSourceAccount) {\n      keys.push({\n        pubkey: fetchAccountDetail.publickeyOfSourceAccount,\n        isSigner: false,\n        isDebitable: true,\n      });\n    }\n    return new TxOperation({\n      keys,\n      controllerId: this.controllerId,\n      data,\n    });\n  }\n\n  /**\n   * Construct an Approve instruction\n   *\n   * @param owner Owner of the source asset account\n   * @param account Bvm Address of the asset account\n   * @param delegate Token account authorized to perform a transfer assets from the source account\n   * @param amount Maximum number of assets the delegate may transfer\n   */\n  approveOperation(\n    owner: BvmAddr,\n    account: BvmAddr,\n    delegate: BvmAddr,\n    amount: number | AssetCount,\n  ): TxOperation {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      Layout.uint64('amount'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 3, // Approve instruction\n        amount: new AssetCount(amount).convertToBuffer(),\n      },\n      data,\n    );\n\n    return new TxOperation({\n      keys: [\n        {pubkey: owner, isSigner: true, isDebitable: false},\n        {pubkey: account, isSigner: false, isDebitable: true},\n        {pubkey: delegate, isSigner: false, isDebitable: true},\n      ],\n      controllerId: this.controllerId,\n      data,\n    });\n  }\n\n  /**\n   * Construct an Revoke instruction\n   *\n   * @param owner Owner of the source asset account\n   * @param account Bvm Address of the asset account\n   * @param delegate Token account authorized to perform a transfer assets from the source account\n   */\n  revokeOperation(\n    owner: BvmAddr,\n    account: BvmAddr,\n    delegate: BvmAddr,\n  ): TxOperation {\n    return this.approveOperation(owner, account, delegate, 0);\n  }\n\n  /**\n   * Construct a SetOwner instruction\n   *\n   * @param owner Owner of the asset account\n   * @param account Bvm Address of the asset account\n   * @param newOwner New owner of the asset account\n   */\n  setOwnerOperation(\n    owner: BvmAddr,\n    account: BvmAddr,\n    newOwner: BvmAddr,\n  ): TxOperation {\n    const dataLayout = BufferLayout.struct([BufferLayout.u32('instruction')]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 4, // SetOwner instruction\n      },\n      data,\n    );\n\n    return new TxOperation({\n      keys: [\n        {pubkey: owner, isSigner: true, isDebitable: false},\n        {pubkey: account, isSigner: false, isDebitable: true},\n        {pubkey: newOwner, isSigner: false, isDebitable: true},\n      ],\n      controllerId: this.controllerId,\n      data,\n    });\n  }\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////\nasync function modify_callFun_uint(call, unum_diff){\n  var callFun_set = new Set();\n  // it returns a set of parameter list, because unum_diff can change many parameters\n  var parameters_set = await modify_callInput_uint(call, unum_diff);\n  for(var parameters of parameters_set){\n    var callFun = {\n      from: call.from,\n      to: call.to,\n      abi: call.abi,\n      gas: call.gas,\n      param: parameters\n    };\n    callFun_set.add(callFun);\n  }\n  return callFun_set;\n}\n\nasync function modify_callFun_uint_meaningful(call, unum_diff){\n  // it returns a set of parameter list, because unum_diff can change many parameters\n  var modify_result = await modify_callInput_uint_meaningful(call, unum_diff);\n  if(modify_result[0]){\n    var callFun = {\n      from: call.from,\n      to: call.to,\n      abi: call.abi,\n      gas: call.gas,\n      param: modify_result[1]\n    };  \n    return [true, callFun];\n  }\n  else{\n    return [false, undefined];\n  }\n}\n\nasync function modify_callFun_gas_meaningful(call, gas_diff){\n  // it returns a set of parameter list, because unum_diff can change many parameters\n  var modify_result = await modify_callGas_meaningful(call, gas_diff);\n  if(modify_result[0]){\n    var callFun = {\n      from: call.from,\n      to: call.to,\n      abi: call.abi,\n      gas: modify_result[1],\n      param: call.param\n    };  \n    return [true, callFun];\n  }\n  else{\n    return false;\n  }\n\n}\n\n/// mutate the gas, and generate a list of callsequence\n/// gas does not need BigInt\nasync function mutate_gas(call, callSequence, index){\n  var gas_sequence_list = [];\n  var gas_diff = parseInt(call.gas, 10) - gasMin;\n  var gas_neighbor_index = 0;\n  var gas_neighbor_len = gas_neighbor.length;\n  while(gas_neighbor_index <= gas_neighbor_len){\n    var gas_min, gas_max;\n    if(gas_neighbor_index == 0){\n      gas_min = gasMin;\n    }\n    else{\n      var times = parseFloat(gas_neighbor[gas_neighbor_index -1], 10);\n      gas_min = Math.ceil(gasMin + gas_diff*times);\n    }\n    if(gas_neighbor_index == gas_neighbor_len){\n      gas_max = gasMax;\n    }\n    else{\n      var times = parseFloat(gas_neighbor[gas_neighbor_index], 10);\n      gas_max = Math.ceil(gasMin + gas_diff*times);\n    }\n    /// generate a new call function\n    var callFun = await modify_callFun_gas(call, gas_min, gas_max);\n    /// clone the call sequence\n    var gas_sequence = callSequence.slice();\n    /// replace the given function\n    gas_sequence[index] = callFun;\n    gas_sequence_list.push(gas_sequence);\n    gas_neighbor_index += 1;\n  }\n  return gas_sequence_list;\n}\n\n/// mutate the uint based on previous balances\n/// 'exec_results' is the result of 'call'\nasync function mutate_balance(call, callSequence, index){\n  var bal_sequence_list = [];\n  var exec_index = 0;\n  var exec_len = exec_results.length;\n  while(exec_index <= exec_len){\n    var unum_min, unum_max;\n    if(exec_index == 0){\n      unum_min = 0;\n    }\n    else{\n      unum_min = parseInt(exec_results[exec_index -1]);\n    }\n    if(exec_index == 8){\n      unum_max = undefined;\n    }\n    else{\n      unum_max = parseInt(exec_results[exec_index]);\n    }      \n    /// generate the new calls and execute them\n    var callFun = await modify_callFun_bal_range(call, unum_min, unum_max);\n    if(callFun !== undefined){\n      /// clone the call sequence\n      var bal_sequence = callSequence.slice();\n      /// replace the given function\n      bal_sequence[index] = callFun;\n      bal_sequence_list.push(bal_sequence);\n    }\n    callFun = await modify_callFun_bal_single(call, unum_max);\n    if(callFun !== undefined){\n      /// clone the call sequence\n      var bal_sequence = callSequence.slice();\n      /// replace the given function\n      bal_sequence[index] = callFun;\n      bal_sequence_list.push(bal_sequence);\n    }\n    exec_index += 1;\n  }\n  return bal_sequence_list;  \n}\n\nasync function mutate_uint(call, callSequence, index){\n  var uint_sequence_list = [];\n  var uint_neighbor_index = 0;\n  var uint_neighbor_len = uint_neighbor.length;\n  while(uint_neighbor_index <= uint_neighbor_len){\n    /// unum_diff is not handled here, because it is relevant to multiple parameters\n    /// generate a new call function\n    var unum_diff = uint_neighbor[uint_neighbor_index];\n    var callFun_set = await modify_callFun_uint(call, unum_diff);\n    for(var callFun of callFun_set){\n      /// clone the call sequence\n      var uint_sequence = callSequence.slice();\n      /// replace the given function\n      uint_sequence[index] = callFun;\n      uint_sequence_list.push(uint_sequence);     \n    }\n    uint_neighbor_index += 1;\n  }\n  return uint_sequence_list;\n}\n//////////////////////////////////////////////////////////////////////////////////////////////","// @flow\n\nimport {Connection} from './netutility';\nimport {dormant} from './dormant';\nimport type {TxnSignature} from './tx-dapp';\nimport {DEFAULT_TICKS_PER_SLOT, NUM_TICKS_PER_SEC} from './timing';\n\n\nconst fs = require('fs');\nvar debug = true;\n\nfunction setDebug(value) { debug = value; }\nfunction getDebug() { return debug; }\nfunction cLog(value) { if (debug) console.log(value); }\nfunction testLog(value) { console.log(value); }\nfunction mkdir(path) {\n  try {\n    fs.mkdirSync(path);\n  } catch(e) {\n    if ( e.code != 'EEXIST' ) throw e;\n  }\n }\n\nfunction rmdir(path) {\n  if( fs.existsSync(path) ) {\n    fs.readdirSync(path).forEach(function(file,index){\n      var curPath = path + \"/\" + file;\n      if(fs.lstatSync(curPath).isDirectory()) { // recurse\n        rmdir(curPath);\n      } else { // delete file\n        fs.unlinkSync(curPath);\n      }\n    });\n    fs.rmdirSync(path);\n  }\n }\n\nfunction fileExists(path)\n {\n    if(fs.existsSync(path))\n\treturn true;\n    return false;\n }\n\nfunction readFile(path, callback, cb) {\n    fs.readFile(path, 'utf8',  (err, data) => { callback (err, data, cb) });\n }\n\nfunction writeFile(path, data) {\n   fs.writeFile(path, data, (err) => { if (err) throw err;});\n }\n\nfunction listFiles(dir, recursive = false) {\n\n    var results = [];\n    fs.readdirSync(dir).forEach(function(file) {\n        file = dir+'/'+file;\n        var stat = fs.statSync(file);\n\n        if (stat && stat.isDirectory() && recursive) {\n            results = results.concat(listFiles(file, recursive))\n        } else results.push(file);\n    });\n\n    return results;\n }\n\nfunction listFolders(dir) {\n\n    var results = [];\n    fs.readdirSync(dir).forEach(function(file) {\n        file = dir+'/'+file;\n        var stat = fs.statSync(file);\n\n        if (stat && stat.isDirectory()) {\n            results.push(file);\n        }\n    });\n\n    return results;\n }\n\n\n\n\n/**\n * send transaction to the network\n * get transaction's status by signature\n */\nexport async function launchThenAcknowledgeNativeTxn(\n  connection: Connection,\n  originalTransaction: Buffer,\n): Promise<TxnSignature> {\n  const start_time = Date.now();\n  let tx_signature = await connection.sendNativeTxn(originalTransaction);\n\n  // Wait up to a couple slots for a confirmation\n  let tx_status = null;\n  let failed_status_retries = 6;\n  for (;;) {\n    tx_status = await connection.fetchSignatureState(tx_signature);\n    if (tx_status) {\n      break;\n    }\n\n    // dormant for 500 leader rotation duration\n    await dormant((500 * DEFAULT_TICKS_PER_SLOT) / NUM_TICKS_PER_SEC);\n\n    if (--failed_status_retries <= 0) {\n      const duration = (Date.now() - start_time) / 1000;\n      throw new Error(\n        `Raw Transaction '${tx_signature}' was not confirmed in ${duration.toFixed(\n          2,\n        )} seconds (${JSON.stringify(tx_status)})`,\n      );\n    }\n  }\n\n  if (tx_status && 'Ok' in tx_status) {\n    return tx_signature;\n  }\n\n  throw new Error(\n    `Raw transaction ${tx_signature} failed (${JSON.stringify(tx_status)})`,\n  );\n}\n\n\nvar lastResponse;\nvar nodes = {};\n\n\nfunction startNode (nodeExec, dataDir, genesisPath, listeningPort, finished) \n{\n  var utils = require('./utils.js');\n  var spawn = require('child_process').spawn\n  var options = [\n    '--private', 'privatechain',\n    '-d', dataDir,\n    '--config', genesisPath,\n    '--ipcpath', dataDir + '/geth.ipc',\n    '--ipc',\n    '--listen', listeningPort,\n    '--test',\n    '-a', '0x1122334455667788991011121314151617181920'\n  ]\n  utils.cLog('starting node')\n  utils.cLog(nodeExec + ' ' + options.join(' '))\n  var node = spawn(nodeExec, options)\n  node.stdout.on('data', (data) => {\n    utils.cLog(`stdout: ${data}`)\n  })\n  node.stderr.on('data', (data) => {\n    utils.cLog(`stderr: ${data}`)\n  })\n  node.on('close', (code) => {\n    utils.cLog(`child process exited with code ${code}`)\n  })\n\n  nodes[dataDir] = node;\n  utils.sleep(14000).then(() => {\n\tutils.cLog(\"Node Started\");\n\tfinished();\n  });\n}\n\nfunction stopNode(dataDir, finished)\n{\n  nodes[dataDir].kill();\n  var utils = require('./utils.js');\n  utils.sleep(1000).then(() => {\n\tfinished();\n  });\n}\n\n\nfunction runScriptOnNode(dataDir, jsScript, args, finished)\n{\n\tvar utils = require('./utils.js');\n\tvar ipcPath = dataDir + '/geth.ipc';\n\n\tvar Web3 = require('web3');\n\tvar web3admin = require('./web3Admin.js');\n\tvar net = require('net');\n\n\tutils.cLog(\"Connecting to node at \" + ipcPath);\n\tvar web3 = new Web3(new Web3.providers.IpcProvider(ipcPath, net));\n\tweb3admin.extend(web3);\n\tglobal.web3 = web3;\n\n\tvar onScriptCallback = function (err, data)\n\t{\n\t\tutils.cLog(data);\n\t\tlastResponse = data;\n\t\tfinished();\n\t}\n\tglobal.callback = onScriptCallback;\n\tglobal.args = args;\n\n\tvar vm = require('vm');\n\tutils.cLog(\"Executing \" + jsScript + \" ...\");\n\tfs.readFile(jsScript, 'utf8', function (err, data)\n\t{\n\t\tif (err)\n\t\t{\n\t\t\tutils.cLog(err);\n\t\t\tfinished();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar script = new vm.Script(data);\n\t\t\tscript.runInThisContext();\n\t\t}\n\t});\n}\n\n\nfunction getLastResponse() \n{\n\treturn lastResponse;\n}\n"," /// @flow\nexport {BvmAcct} from './bvm-acct';\nexport {BpfControllerLoader} from './bvm-dapp-mounter';\nexport {BudgetController} from './bvm-script';\nexport {Connection} from './netutility';\nexport {ControllerLoader} from './dapp-mounter';\nexport {NativeControllerLoader} from './builtin-mounter';\nexport {BvmAddr} from './bvm-addr';\nexport {SystemController} from './sys-dapp';\nexport {Asset, AssetCount} from './asset-dapp';\nexport {Transaction, TxOperation} from './tx-dapp';\nexport {launchThenAcknowledgeTx} from './launch-then-acknowledge-tx';\nexport {\n  launchThenAcknowledgeNativeTxn,\n} from './launch-then-acknowledge-original-tx';\nexport {RpcCall} from './rpc-call';\nexport {RpcParameter} from './rpc-parameter';\nexport {PreCondition} from './preconditions';"],"names":["request","require","AbiCoder","Web3","Promise","truffle_Contract","assert","fs","locks","mutex","createMutex","async","httpRpcAddr","Provider","providers","HttpProvider","web3","g_account_list","eth","accounts","g_from_account","setCharAt","str","index","chr","length","substr","transform","id","newStr","i","charAt","Error","reverse","originalStr","includes","replace","BvmAddr","value","startsWith","_bn","BN","substring","newstr","bs58","decode","byteLength","bvmaddr","eq","encode","converseToBuffer","bign","toArrayLike","Buffer","zeroPad","alloc","copy","converseToBase58","o","BvmAcct","privateKey","_keypair","nacl","sign","keyPair","fromSecretKey","publicKey","secretKey","NUM_TICKS_PER_SEC","DEFAULT_TICKS_PER_SLOT","pubKey","property","BufferLayout","uint64","rustString","rsl","_decode","bind","_encode","buffer","offset","data","chars","toString","from","Object","defineProperty","exports","buffer_1","BufferUtil","source","match","map","x","parseInt","Uint8Array","ArrayBuffer","view","DataView","setUint8","charCodeAt","forEach","push","String","fromCharCode","join","sources","padStart","a","b","c","set","getDecodedArrayLength","bytes","len_to_return","size","elem_of_array","shift","encodeArrayWithInteger","len","new_len","new_elem","CollectionUtil","binarySearch","sortedArray","item","lowIdx","highIdx","midIdx","Math","floor","PACKET_DATA_SIZE","TxOperation","opts","assign","Transaction","signatures","signature","items","operations","concat","recentPackagehash","keys","converseToString","numRequiredSignatures","numCreditOnlySignedAccounts","numCreditOnlyUnsignedAccounts","programIds","instruction","keySignerPair","keyStr","pubkey","isSigner","isDebitable","controllerId","keyCount","shortvec","keyIndicesCount","dataCount","programIdIndex","indexOf","keyIndices","keyObj","dataLength","invariant","keyIndex","instructionCount","instructionBuffer","instructionBufferLength","instructionLayout","slice","signDataLayout","Layout","transaction","key","signData","signTxInPartial","partialSigners","accountOrPublicKey","_fetchSignData","detached","signer","findIndex","sigpair","checkIfEquals","signatureCount","transactionLength","wireTransaction","PUBKEY_LENGTH","SIGNATURE_LENGTH","isCreditDebit","numKeys","byteArray","accountCount","account","programIndex","accountIndexCount","accountIndex","sigPubkeyPair","instructionData","j","some","RpcParameter","type","attributes","_","isUndefined","isNull","list","param","literal","encrypted","assocIndex","idIndex","reference","isRpcParameter","module","RpcCall","rpcName","params","create","arguments","isArray","toArray","args","isEmpty","isRpcCall","processParamList","rest","flattenAndRemoveNullishValues","paramList","filter","flatten","convertedParams","stringParam","isNumber","isString","_flattenAndRemoveNullishValues","_processParamList","dormant","ms","resolve","setTimeout","number_type","string_type","object_type","boolean_type","_types","NetworkError","msg","name","tls","net","uuidv4","events","createRpcReq","url","server","jayson","callback","options","method","body","headers","fetch","res","text","reject","err","response","ConfigurationError","TransactionError","PrecompiledError","CompileError","FetchBalanceRpcResult","struct","jsonrpc","error","result","FetchReputationRpcResult","jsonRpcResult","resultDescription","jsonRpcVersion","union","AccountDetailResult","executable","owner","difs","reputations","fetchAccountDetailRpcResult","AccountNoticeResult","subscription","ControllerAccountDetailResult","ControllerAccountNoticeResult","path","childProcess","abi","ConfmTxnRpcResult","FetchRoundLeader","GetClusterNodes","kingnodeip","txProcessIp","rpc","GetClusterNodes_tmp","GetEpochVoteAccounts","voteBvmAddr","nodeBvmAddr","stake","commission","FetchSignatureStateRpcResult","Ok","Err","FetchTxnAmountRpcResult","GetTotalSupplyRpcResult","FetchRecentBlockhash","difsPerSignature","maxDifsPerSignature","minDifsPerSignature","targetDifsPerSignature","targetSignaturesPerSlot","GetRecentBlockhash_015","ReqDroneRpcResult","ReqReputationRpcResult","SendTxnRpcResult","secp256k1","keccak","rlp","coder","ethjsUtil","Connection","endpoint","urlParse","_rpcReq","href","_blockhashInfo","seconds","transactionSignatures","protocol","host","port","Number","_rpcWebSock","RpcWebSocketClient","urlFormat","autoconnect","max_reconnects","Infinity","on","_wsOnOpen","_wsOnErr","_wsOnClose","_wsOnAccountNotice","_wsOnProgramAccountNotification","unsafeRes","message","res_tmp","console","log","node","undefined","blockhash","gasCounter","to","amount","signers","Date","getSeconds","signTx","_disableBlockhashCaching","attempts","startTime","now","fetchRecentBlockhash","serialize","sendNativeTxn","rawTransaction","_rpcWebSockConnected","_updateSubscriptions","code","accountKeys","_accountChangeSubscriptions","programKeys","_controllerAccountChangeSubscriptions","close","subscriptionId","connect","call","notification","sub","_accountChangeSubscriptionCounter","accountId","fetchAccountDetail","_controllerAccountChangeSubscriptionCounter","util","_str","Socket","format","launchThenAcknowledgeTx","connection","failed_send_retries","start_time","sendTxn","tx_signature","tx_status","failed_status_retries","fetchSignatureState","duration","toFixed","JSON","stringify","random","SystemController","createNewAccount","space","dataLayout","span","addOperations","ControllerLoader","payer","controller","chunkSize","array","transactions","all","type_number","type_string","type_object","type_boolean","BpfControllerLoader","elf","load","PreCondition","condition","argumentName","docsPath","argument","isBuffer","serializePayment","payment","toData","writeUInt32LE","serializeTime","when","iso","date","pad","number","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","write","serializeCond","BudgetController","pos","conditions","trimmedData","conditionData","paymentData","condition1","condition2","whenData","NativeControllerLoader","controllerName","AssetCount","zero_pad_array","new_buffer","AssetDetailLayout","TokenAccountDetailLayout","SYSTEM_TOKEN_CONTROLLER_ID","Asset","assetId","ownerAccount","bvmAddrOfSourceAccount","assetAccount","readUInt8","fetchTokenDetail","totalSupply","createFromBuffer","tokenAccountInfo","publickeyOfAsset","publickeyOfOwner","amountOfAsset","sourceOption","publickeyOfSourceAccount","originalAmountOfAsset","destination","transferOperation","publickeyOfAssetAccount","publickeyOfDelegateAccount","amountAsset","approveOperation","authorize","publickeyOfNewOwner","setOwnerOperation","publickeyOfOwnerSourceAccount","publickeyOfDestinationAccount","convertToBuffer","delegate","newOwner","ownerOfAsset","assetName","assetSymbol","assetDecimals","asset","createNewAssetAccount","publickeyOfStoreAssetAccount","encodeLength","launchThenAcknowledgeNativeTxn","originalTransaction"],"mappings":"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"}
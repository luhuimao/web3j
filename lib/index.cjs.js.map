{"version":3,"file":"index.cjs.js","sources":["../src/bvm-addr.js","../src/bvm-acct.js","../src/timing.js","../src/buffer-cntl.js","../src/util/integer-array-encoding.js","../src/tx-dapp.js","../src/util/dormant.js","../src/netutility.js","../src/rpc-parameter.js","../src/rpc-call.js","../src/util/launch-then-acknowledge-tx.js","../src/sys-dapp.js","../src/dapp-mounter.js","../src/bvm-dapp-mounter.js","../src/js.js","../src/preconditions.js","../src/bvm-script.js","../src/builtin-mounter.js","../src/asset-dapp.js","../src/util/launch-then-acknowledge-original-tx.js","../src/util/testnet.js","../src/index.js"],"sourcesContent":["// @flow\n\nimport BN from 'bn.js';\nimport bs58 from 'bs58';\n\n\nconst request = require(\"request\");\n\n\nconst AbiCoder = require('web3-eth-abi');\n// const abiCoder = new AbiCoder.AbiCoder();\n\nconst Web3 = require('web3');\nconst Promise = require(\"bluebird\");\nconst truffle_Contract = require('truffle-contract');\nconst assert = require('assert');\n// const tracer = require('./EVM2Code');\nconst fs = require('fs');\nconst locks = require('locks');\n// mutex\nconst mutex = locks.createMutex();\nconst async = require('async');\nlet httpRpcAddr = \"http://localhost:8546\"\nlet Provider = new Web3.providers.HttpProvider(httpRpcAddr);\nlet web3  =  new Web3(new Web3.providers.HttpProvider(httpRpcAddr));\nlet g_account_list = web3.eth.accounts;\nlet g_from_account = g_account_list[0];\n  /// unlock initial user, which is also miner account\n// web3.personal.unlockAccount(g_from_account, \"123\", 200 * 60 * 60);\n\n\nasync function get_instance(artifact_path){\n  let artifact = require(artifact_path);\n  let network_id = Object.keys(artifact[\"networks\"])[0];\n  let conf = {\n    contract_name:artifact[\"contractName\"],\n    abi:  artifact[\"abi\"],                     // Array; required.  Application binary interface.\n    unlinked_binary: artifact[\"bytecode\"],       // String; optional. Binary without resolve library links.\n    address: artifact[\"networks\"][network_id][\"address\"],               // String; optional. Deployed address of contract.\n    network_id: parseInt(network_id),            // String; optional. ID of network being saved within abstraction.\n    default_network: parseInt(network_id)       // String; optional. ID of default network this abstraction should use.\n  };\n  // console.log(conf);\n  let MyContract = truffle_Contract(conf);\n  MyContract.setProvider(Provider);\n  let instance = await MyContract.deployed();\n  return instance;\n}\nasync function send(){\n  let private_bank = await get_instance(\"../build/contracts/Private_Bank.json\");\n  await web3.eth.sendTransaction({from:g_from_account,to:private_bank.address,value:10000000000000000000,gas:500000000000});\n}\nasync function test(){\n  let private_bank = await get_instance(\"../build/contracts/Private_Bank.json\");\n  let attack_private_bank = await get_instance(\"../build/contracts/Attack_Private_Bank0.json\");\n  let bal_private = await web3.eth.getBalance(private_bank.address);\n  let bal_attack_private = await web3.eth.getBalance(attack_private_bank.address);\n  console.log(\"Before\");\n  console.log(\"ether of contract:\",bal_private.toString(),bal_attack_private.toString());\n  let book_val = await private_bank.balances(attack_private_bank.address,{from:g_from_account,gas:500000000000});\n  console.log(\"book of contract:\",book_val.toString())\n  await attack_private_bank.vultron_Deposit(10000000000000000000,{from:g_from_account,gas:500000000000});\n \n  book_val = await private_bank.balances(attack_private_bank.address,{from:g_from_account,gas:500000000000});\n  console.log(\"Middle\");\n  console.log(\"book of contract:\",book_val.toString())\n  bal_private = await web3.eth.getBalance(private_bank.address);\n  bal_attack_private = await web3.eth.getBalance(attack_private_bank.address);\n  console.log(\"ether of contract:\",bal_private.toString(),bal_attack_private.toString());\n\n\n  await attack_private_bank.vultron_CashOut(10000000000000000000,{from:g_from_account,gas:50000000000000});\n\n  console.log(\"After\");\n  book_val = await private_bank.balances(attack_private_bank.address,{from:g_from_account,gas:500000000000});\n  console.log(book_val.toString())\n  bal_private = await web3.eth.getBalance(private_bank.address);\n  bal_attack_private = await web3.eth.getBalance(attack_private_bank.address);\n  console.log(\"ether of contract:\",bal_private.toString(),bal_attack_private.toString());\n  book_val = await private_bank.balances(attack_private_bank.address,{from:g_from_account,gas:500000000000});\n  console.log(\"book of contract:\",book_val.toString())\n    \n}\n\n\nfunction setCharAt(str,index,chr) {\n  if(index > str.length-1) return str;\n  return str.substr(0,index) + chr + str.substr(index+1);\n}\n\nfunction transform(id) {\n  var newStr = id;\n  if (typeof id === 'string') {\n      for (var i = 0; i < newStr.length; i++) {\n          // console.log(newStr.charAt(i));\n          \n          if (newStr.charAt(i) === '0') {\n              newStr = setCharAt(newStr, i, 'X2');\n          }\n          else if (newStr.charAt(i) === 'O') {\n              newStr = setCharAt(newStr, i, 'X1');\n          }\n          else if (newStr.charAt(i) === 'I') {\n              newStr = setCharAt(newStr, i, 'X3');\n          }\n          else if (newStr.charAt(i) === 'l') {\n              newStr = setCharAt(newStr, i, 'X4');\n          }\n      }\n  } else {\n      throw new Error(`can't transform a not string type value`);\n  }\n  return newStr;\n}\n\nfunction reverse(id) {\n  var originalStr = id;\n  if (typeof id === 'string') {\n      for (var i = 0; i < originalStr.length; i++) {\n          if (originalStr.includes(\"X2\")) {\n              originalStr = originalStr.replace(/X2/g, \"0\");\n          }\n          else if (originalStr.includes(\"X1\")) {\n              originalStr = originalStr.replace(/X1/g, \"O\");\n          }\n          else if (originalStr.includes(\"X3\")) {\n              originalStr = originalStr.replace(/X3/g, \"I\");\n          }\n          else if (originalStr.includes(\"X4\")) {\n              originalStr = originalStr.replace(/X4/g, \"l\");\n          }\n      }\n  } else {\n      throw new Error(`can't transform a not string type value`);\n  }\n  return originalStr;\n}\n\n/**\n * A public key\n */\nexport class PubKey {\n  _bn: BN;\n\n  /**\n   * Create a new PubKey object\n   */\n  constructor(value: number | string | Buffer | Array<number>) {\n    if (typeof value === 'string') {\n      // hexadecimal number\n      if (value.startsWith('0x')) {\n        this._bn = new BN(value.substring(2), 16);\n      } else {\n        // assume base 58 encoding by default\n        var newstr = transform(value);\n        this._bn = new BN(bs58.decode(newstr));\n      }\n    } else {\n      this._bn = new BN(value);\n    }\n\n    if (this._bn.byteLength() > 32) {\n      throw new Error(`Invalid public key input`);\n    }\n  }\n\n  /**\n   * Checks if the provided object is a PubKey\n   */\n  static isPubKey(o: Object): boolean {\n    return o instanceof PubKey;\n  }\n\n  /**\n   * Checks if two publicKeys are equal\n   */\n  equals(pubKey: PubKey): boolean {\n    return this._bn.eq(pubKey._bn);\n  }\n\n  /**\n   * Return the base-58 representation of the public key\n   */\n  toBase58(): string {\n    return bs58.encode(this.toBuffer());\n  }\n\n  /**\n   * Return the Buffer representation of the public key\n   */\n  toBuffer(): Buffer {\n    const b = this._bn.toArrayLike(Buffer);\n    if (b.length === 32) {\n      return b;\n    }\n\n    const zeroPad = Buffer.alloc(32);\n    b.copy(zeroPad, 32 - b.length);\n    return zeroPad;\n  }\n\n  /**\n   * Returns a string representation of the public key\n   */\n  toString(): string {\n    return reverse(this.toBase58());\n    // return this.toBase58();\n  }\n}\n\n\n// web3 abstractions\n// var web3;\nvar target_con;\nvar attack_con;\nvar account_list;\nvar bookKeepingAbi;\n\n// tracer abstractions at instruction level\nvar targetIns_map;\nvar attackIns_map;\n\n// static dependency\nvar staticDep_target;\nvar staticDep_attack;\n\n/// the gas amount\nconst gasMin = 25000;\nconst gasMax = 8000000000;\n/// dynamci array\nconst dyn_array_min = 1;\nconst dyn_array_max = 10;\n\n/// the maximum length of seed_callSequence\nconst sequence_maxLen = 4;\n/// the maximum number of muated call sequences \nconst mutateSeque_maxLen = 4;\n/// the maximum number of muated operation for each call sequence\nconst mutateOper_maxLen = 3;\n/// the maximum length of changed call sequence\nconst operSeque_maxLen = 3;\n\n/// the set to keep the coverage for guided fuzzing\nvar stmt_trace = [];\nvar seque_stmt_trace = [];\nvar trans_depen_set = new Set();\nvar seque_depen_set = new Set();\nvar contr_depen_set = new Set();\n","// @flow\nimport nacl from 'tweetnacl';\nimport type {KeyPair} from 'tweetnacl';\n\nimport {PubKey} from './bvm-addr';\n\n\n    // static getPayload(cursor) {\n    //   const argType = cursor.read32();\n    //   if (argType === transaction_pb_1.TransactionArgument.ArgType.U64) {\n    //       const data = cursor.read64();\n    //       return TransactionArgumentLCS_1.TransactionArgumentLCS.fromU64(data.toString());\n    //   }\n    //   else if (argType === transaction_pb_1.TransactionArgument.ArgType.ADDRESS) {\n    //       const data = this.getAddress(cursor);\n    //       return TransactionArgumentLCS_1.TransactionArgumentLCS.fromAddress(data);\n    //   }\n    //   else if (argType === transaction_pb_1.TransactionArgument.ArgType.STRING) {\n    //       const data = this.getString(cursor);\n    //       return TransactionArgumentLCS_1.TransactionArgumentLCS.fromString(data);\n    //   }\n    //   else if (argType === transaction_pb_1.TransactionArgument.ArgType.BYTEARRAY) {\n    //       const data = this.getByteArray(cursor);\n    //       return TransactionArgumentLCS_1.TransactionArgumentLCS.fromByteArray(data);\n    //   }\n    //   return new TransactionArgumentLCS_1.TransactionArgumentLCS();\n    // }\n\nclass CursorBuffer {\n    constructor(typedArray, littleEndian = true) {\n        this.dataView = new DataView(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n        this.littleEndian = littleEndian;\n        this.bytePositon = 0;\n    }\n    /**\n     * Reads 1 byte\n     *\n     */\n    read8() {\n        const value = this.dataView.getUint8(this.bytePositon);\n        this.bytePositon += 1;\n        return value;\n    }\n    /**\n     * Reads 4 bytes\n     *\n     */\n    read32() {\n        const value = this.dataView.getUint32(this.bytePositon, this.littleEndian);\n        this.bytePositon += 4;\n        return value;\n    }\n    /**\n     * Reads 8 bytes\n     *\n     *\n     */\n    // read64() {\n    //     const firstPart = this.read32();\n    //     const secondPart = this.read32();\n    //     const combined = this.littleEndian\n    //         ? secondPart.toString(16) + firstPart.toString(16).padStart(8, '0')\n    //         : firstPart.toString(16) + secondPart.toString(16).padStart(8, '0');\n    //     return new bignumber_js_1.default(`0x${combined}`, 16);\n    // }\n    readXBytes(x) {\n        // console.log(this.bytePositon, this.dataView.byteOffset);\n        // this.bytePositon -= 8;\n\n        const startPosition = this.bytePositon + this.dataView.byteOffset; // original = 27\n        console.log(startPosition);\n        const value = new Uint8Array(this.dataView.buffer, startPosition, x);\n        this.bytePositon += x;\n        return value;\n\n        // + 8 // receiver | 19 // sender (when not skipping bytes with .read32 before signedTxn)\n\n        // const startPosition = this.bytePositon + this.dataView.byteOffset + 8; // receiver = 35\n        // const value = new Uint8Array(this.dataView.buffer, startPosition, x);\n        // this.bytePositon += x;\n        // return value;\n\n        // const value = new Uint8Array(this.dataView.buffer, 19, x); // sender\n        // return value;\n    }\n    readXXBytes(x) {\n      this.bytePositon += 4;\n      \n      const value = new Uint8Array(this.dataView.buffer, 271, x);\n      return value;\n    }\n    /**\n     * Read bool as 1 byte\n     *\n     */\n    readBool() {\n        const value = this.dataView.getUint8(this.bytePositon);\n        this.bytePositon += 1;\n        if (value !== 0 && value !== 1) {\n            throw new Error(`bool must be 0 or 1, found ${value}`);\n        }\n        return value !== 0;\n    }\n}\n\n/**\n * An account key pair (public and secret keys).\n */\nexport class BusAccount {\n  _keypair: KeyPair;\n\n  /**\n   * Create a new BusAccount object\n   *\n   * If the privateKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param privateKey Secret key for the account\n   */\n  constructor(privateKey: ?Buffer = null) {\n    if (privateKey) {\n      this._keypair = nacl.sign.keyPair.fromSecretKey(privateKey);\n    } else {\n      this._keypair = nacl.sign.keyPair();\n    }\n  }\n\n  /**\n   * The public key for this account\n   */\n  get pubKey(): PubKey {\n    return new PubKey(this._keypair.publicKey);\n  }\n\n  /**\n   * The **unencrypted** secret key for this account\n   */\n  get privateKey(): Buffer {\n    return this._keypair.secretKey;\n  }\n}\n\n\n\n// static getRawTransaction(cursor) {\n    //     const sender = this.getAddress(cursor);\n    //     const sequence = cursor.read64();\n    //     const payload = this.getTransactionPayload(cursor);\n    //     const maxGasAmount = cursor.read64();\n    //     const gasUnitPrice = cursor.read64();\n    //     const expiryTime = cursor.read64();\n    //     const transaction = new RawTransactionLCS_1.RawTransactionLCS(sender.value, sequence.toString(), payload);\n    //     transaction.maxGasAmount = maxGasAmount;\n    //     transaction.gasUnitPrice = gasUnitPrice;\n    //     transaction.expirtationTime = expiryTime;\n    //     return transaction;\n    // }\n\n\n\n    \n\n    // static getRawTransaction(cursor) {\n    //   const sender = this.getAddress(cursor);\n    //   const sequence = cursor.read64();\n    //   // const payload = this.getTransactionPayload(cursor);\n    //   const maxGasAmount = cursor.read64();\n    //   const gasUnitPrice = new BigNumber.default(cursor.read64());\n    //   const expiryTime = new BigNumber.default(cursor.read64());\n    //   // const transaction = new RawTransactionLCS_1.RawTransactionLCS(sender.value, sequence.toString(), payload);\n    //   // transaction.maxGasAmount = maxGasAmount;\n    //   // transaction.gasUnitPrice = gasUnitPrice;\n    //   // transaction.expirtationTime = expiryTime;\n    //   return ({sender:sender, sequence:sequence, maxGasAmount:maxGasAmount, gasUnitPrice:gasUnitPrice, expiryTime:expiryTime});\n    // }\n\n\n    import * as fs from 'fs'\nimport * as path from 'path'\n\ntype PackageJson = {\n  name: string,\n  version?: string,\n  description?: string,\n  main?: string,\n  scripts?: { [string]: string },\n  dependencies?: { [string]: string },\n  devDependencies?: { [string]: string }\n}\n\nexport async function findNearestPackageJson(\n  directoryPath: string = path.resolve()\n): Promise<{ path: string, data: PackageJson }> {\n  try {\n    const packageJsonPath = path.join(directoryPath, 'package.json')\n    const packageJsonData = JSON.parse(await readFile(packageJsonPath))\n    return {\n      path: packageJsonPath,\n      data: packageJsonData\n    }\n  } catch (error) {\n    const parentDirectoryPath = path.dirname(directoryPath)\n    if (parentDirectoryPath === directoryPath) {\n      throw new Error('No package.json files found')\n    }\n    return findNearestPackageJson(parentDirectoryPath)\n  }\n}\n\nfunction readFile(filePath: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    fs.readFile(filePath, 'utf8', (error, result) => {\n      if (error) reject(error)\n      else resolve(result)\n    })\n  })\n}\n\nexport function findNearestPackageJsonSync(\n  directoryPath: string = path.resolve()\n): { path: string, data: PackageJson } {\n  try {\n    const packageJsonPath = path.join(directoryPath, 'package.json')\n    const packageJsonData = JSON.parse(readFileSync(packageJsonPath))\n    return {\n      path: packageJsonPath,\n      data: packageJsonData\n    }\n  } catch (error) {\n    const parentDirectoryPath = path.dirname(directoryPath)\n    if (parentDirectoryPath === directoryPath) {\n      throw new Error('No package.json files found')\n    }\n    return findNearestPackageJsonSync(parentDirectoryPath)\n  }\n}\n\nfunction readFileSync(filePath: string): string {\n  return fs.readFileSync(filePath, 'utf8')\n}\n\n\nclass StatusCode {\n    static getStatusMessage(status) {\n        let message = '';\n        switch (status) {\n            case this.Success:\n                message = 'success';\n                break;\n            case this.Unknown:\n                message = 'unknown';\n                break;\n            case this.BadRLP:\n                message = 'bad RLP';\n                break;\n            case this.InvalidFormat:\n                message = 'invalid format';\n                break;\n            case this.OutOfGasIntrinsic:\n                message = 'out of gas intrinsic';\n                break;\n            case this.InvalidSignature:\n                message = 'invalid signature';\n                break;\n            case this.InvalidNonce:\n                message = 'invalid nonce';\n                break;\n            case this.NotEnoughCash:\n                message = 'not enough cash';\n                break;\n            case this.OutOfGasBase:\n                message = 'out of gas base';\n                break;\n            case this.BlockGasLimitReached:\n                message = 'block gas limit reached';\n                break;\n            case this.BadInstruction:\n                message = 'bad instruction';\n                break;\n            case this.BadJumpDestination:\n                message = 'bad jump destination';\n                break;\n            case this.OutOfGas:\n                message = 'out of gas';\n                break;\n            case this.OutOfStack:\n                message = 'out of stack';\n                break;\n            case this.StackUnderflow:\n                message = 'stack underflow';\n                break;\n            case this.NonceCheckFail:\n                message = 'nonce check fail';\n                break;\n            case this.BlockLimitCheckFail:\n                message = 'block limit check fail';\n                break;\n            case this.FilterCheckFail:\n                message = 'filter check fail';\n                break;\n            case this.NoDeployPermission:\n                message = 'no deploy permission';\n                break;\n            case this.NoCallPermission:\n                message = 'no call permission';\n                break;\n            case this.NoTxPermission:\n                message = 'no tx permission';\n                break;\n            case this.PrecompiledError:\n                message = 'precompiled error';\n                break;\n            case this.RevertInstruction:\n                message = 'revert instruction';\n                break;\n            case this.InvalidZeroSignatureFormat:\n                message = 'invalid zero signature format';\n                break;\n            case this.AddressAlreadyUsed:\n                message = 'address already used';\n                break;\n            case this.PermissionDenied:\n                message = 'permission denied';\n                break;\n            case this.CallAddressError:\n                message = 'call address error';\n                break;\n            default:\n                message = `unknown status code:${status}`;\n                break;\n        }\n\n        return message;\n    }\n}\n\nStatusCode.Success = '0x0';\nStatusCode.Unknown = '0x1';\nStatusCode.BadRLP = '0x2';\nStatusCode.InvalidFormat = '0x3';\nStatusCode.OutOfGasIntrinsic = '0x4';\nStatusCode.InvalidSignature = '0x5';\nStatusCode.InvalidNonce = '0x6';\nStatusCode.NotEnoughCash = '0x7';\nStatusCode.OutOfGasBase = '0x8';\nStatusCode.BlockGasLimitReached = '0x9';\nStatusCode.BadInstruction = '0xa';\nStatusCode.BadJumpDestination = '0xb';\nStatusCode.OutOfGas = '0xc';\nStatusCode.OutOfStack = '0xd';\nStatusCode.StackUnderflow = '0xe';\nStatusCode.NonceCheckFail = '0xf';\nStatusCode.BlockLimitCheckFail = '0x10';\nStatusCode.FilterCheckFail = '0x11';\nStatusCode.NoDeployPermission = '0x12';\nStatusCode.NoCallPermission = '0x13';\nStatusCode.NoTxPermission = '0x14';\nStatusCode.PrecompiledError = '0x15';\nStatusCode.RevertInstruction = '0x16';\nStatusCode.InvalidZeroSignatureFormat = '0x17';\nStatusCode.AddressAlreadyUsed = '0x18';\nStatusCode.PermissionDenied = '0x19';\nStatusCode.CallAddressError = '0x1a';","// @flow\n\n\n\n/// conver scientific number to string\nfunction uintToString(num){\n  var num_str = \"\" + num;\n  /// scientific number\n  var index = num_str.indexOf(\"+\");\n  if(index != -1){\n    var result = num_str[0];\n    var power_len = parseInt(num_str.slice(index +1), 10);\n    var power_index = 0;\n    while(power_index < power_len){\n      /// num_str[index-1:] is 'e+...'\n      if((power_index +2) < (index -1)){\n        result += num_str[power_index +2];\n      }\n      else{\n        result += '0';\n      }\n      power_index += 1;\n    }\n    return result;\n  }\n  else{\n    return num_str;\n  }\n}\n\n/// generate an unsigned integer\n/// unum_min is defined, in most case it is 0\n/// unum_max may not be defined, e.g., undefined\nfunction gen_uint(uint_type, unum_min, unum_max){\n  /// get rid of uint in e.g., 'uint256'\n  var num_left = 4;\n  /// maybe it is an array, e,g., 'uint256[]'\n  var num_right = uint_type.indexOf('[');\n  if(num_right == -1){\n    /// it is primitive unit, not an array\n    num_right = uint_type.length;\n  } \n  /// the number of bytes\n  var byte_num = parseInt(uint_type.slice(num_left, num_right), 10) / 8;\n  var byte_index = 0;\n  var num_str = '0x';\n  while(byte_index < byte_num){\n    num_str += 'ff';\n    byte_index += 1;\n  }\n  if(unum_max === undefined){\n    /// unum_max is undefined, we use the default maximum value\n    unum_max = parseInt(num_str, 16); \n  }\n  else{\n    var num_max = parseInt(num_str, 16);\n    if(num_max < unum_max){\n      unum_max = num_max;\n    }\n  }\n  if(uint_type.indexOf('[') == -1){\n    /// primitive type\n    var value_int = randomNum(unum_min, unum_max);\n    var value = uintToString(value_int);\n    return value;\n  }\n  else if(adds_type.indexOf('[]') != -1){\n    /// dynamic array\n    var value_list = [];\n    var value_num = randomNum(dyn_array_min, dyn_array_max);\n    var value_index = 0;\n    while(value_index < value_num){\n      var value_int = randomNum(unum_min, unum_max);\n      var value = uintToString(value_int);;      \n      value_list.push(value);\n      value_index += 1;\n    }\n    return value_list;\n  }\n  else{\n    /// static array\n    var value_list = [];\n    var left_index = uint_type.indexOf('[');\n    var right_index = uint_type.indexOf(']');\n    var value_num = parseInt(uint_type.slice(left_index +1, right_index), 10);\n    var value_index = 0;\n    while(value_index < value_num){\n      var value_int = randomNum(unum_min, unum_max);\n      var value = uintToString(value_int);\n      value_list.push(value);\n      value_index += 1;\n    }\n    return value_list;\n  }\n}\n\n/**\n * @ignore\n */\nexport const NUM_TICKS_PER_SEC = 10;\n\n// tracer abstractions at instruction level\nvar targetIns_map;\nvar attackIns_map;\n\n// static dependency\nvar staticDep_target;\nvar staticDep_attack;\n\n/// the gas amount\nconst gasMin = 25000;\nconst gasMax = 8000000000;\n/// dynamci array\nconst dyn_array_min = 1;\nconst dyn_array_max = 10;\n\n/**\n * @ignore\n */\nexport const DEFAULT_TICKS_PER_SLOT = 8;\n\n\n\n\n/// the maximum length of seed_callSequence\nconst sequence_maxLen = 4;\n/// the maximum number of muated call sequences \nconst mutateSeque_maxLen = 4;\n/// the maximum number of muated operation for each call sequence\nconst mutateOper_maxLen = 3;\n/// the maximum length of changed call sequence\nconst operSeque_maxLen = 3;\n\n/// the set to keep the coverage for guided fuzzing\nvar stmt_trace = [];\nvar seque_stmt_trace = [];\nvar trans_depen_set = new Set();\nvar seque_depen_set = new Set();\nvar contr_depen_set = new Set();\n\n/// the last call\nvar lastCall = new Map();\n/// the call function list for the execution\nvar sequence_call_list = [];\n/// the executed call sequence\nvar sequence_executed = [];\n/// the index in sequence_executed\nvar sequeExe_index = 0;\n/// the sequence_exexuted become more meaningful\nvar sequeExe_meaningful = false;\n/// the execution results of a call function\nvar exec_results = [];\n/// another new call seqeunce\nvar new_sequence_start = false;\n\n/// the hash of previous transaction\nvar pre_txHash = \"0x0\";\nvar startTime, endTime;\nvar timeDiff;\n\n/// the candidate abi that can be used to start transaction\nvar cand_sequence = [];\n\nvar reset_num = 0;\nvar reset_index = 0;\n\nvar fuzzing_finish = false;","// @flow\n\nimport * as BufferLayout from 'buffer-layout';\n\n/// the last call\nvar lastCall = new Map();\n/// the call function list for the execution\nvar sequence_call_list = [];\n/// the executed call sequence\nvar sequence_executed = [];\n/// the index in sequence_executed\nvar sequeExe_index = 0;\n/// the sequence_exexuted become more meaningful\nvar sequeExe_meaningful = false;\n/// the execution results of a call function\nvar exec_results = [];\n/// another new call seqeunce\nvar new_sequence_start = false;\n\n/// the hash of previous transaction\nvar pre_txHash = \"0x0\";\nvar startTime, endTime;\nvar timeDiff;\n\n/// the candidate abi that can be used to start transaction\nvar cand_sequence = [];\n\nvar reset_num = 0;\nvar reset_index = 0;\n\nvar fuzzing_finish = false;\n\n/// the mutation for gas neighbor\nvar gas_neighbor = [];\ngas_neighbor.push('0.01');\ngas_neighbor.push('0.1');\ngas_neighbor.push('0.2');\ngas_neighbor.push('0.3');\ngas_neighbor.push('0.5');\ngas_neighbor.push('0.8');\ngas_neighbor.push('0.9');\ngas_neighbor.push('0.92');\ngas_neighbor.push('0.93');\ngas_neighbor.push('0.95');\ngas_neighbor.push('0.96');\ngas_neighbor.push('0.97');\ngas_neighbor.push('0.98');\ngas_neighbor.push('0.99');\ngas_neighbor.push('1.01');\ngas_neighbor.push('1.02');\ngas_neighbor.push('1.03');\ngas_neighbor.push('1.0');\ngas_neighbor.push('1.05');\ngas_neighbor.push('1.06');\ngas_neighbor.push('1.08');\ngas_neighbor.push('1.1');\ngas_neighbor.push('1.2');\ngas_neighbor.push('1.5');\ngas_neighbor.push('1.7');\ngas_neighbor.push('2.0');\ngas_neighbor.push('3.0');\ngas_neighbor.push('5.0');\ngas_neighbor.push('10.0');\ngas_neighbor.push('50.0');\ngas_neighbor.push('80.0');\ngas_neighbor.push('100.0');\ngas_neighbor.push('1000.0');\n\n/**\n * Layout for a public key\n */\nexport const pubKey = (property: string = 'pubKey'): Object => {\n  return BufferLayout.blob(32, property);\n};\n\n/// the mutation operation for uint neighbor\nvar uint_neighbor = [];\nuint_neighbor.push('1.05');\nuint_neighbor.push('0.95');\nuint_neighbor.push('1.1');\nuint_neighbor.push('0.9');\nuint_neighbor.push('1.15');\nuint_neighbor.push('0.85');  \nuint_neighbor.push('1.2');\nuint_neighbor.push('0.8');\nuint_neighbor.push('1.5');\nuint_neighbor.push('0.5');\nuint_neighbor.push('2.0');\nuint_neighbor.push('0.02');  \nuint_neighbor.push('3.0');\nuint_neighbor.push('0.015'); \nuint_neighbor.push('4.0');\nuint_neighbor.push('0.01'); \nuint_neighbor.push('5.0');\nuint_neighbor.push('0.001'); \nuint_neighbor.push('0.0001')\nuint_neighbor.push(1);\nuint_neighbor.push(-1);\nuint_neighbor.push(2);\nuint_neighbor.push(-2);\nuint_neighbor.push(4);\nuint_neighbor.push(-4);\nuint_neighbor.push(8);\nuint_neighbor.push(-8);\n\n/**\n * Layout for a 64bit unsigned value\n */\nexport const uint64 = (property: string = 'uint64'): Object => {\n  return BufferLayout.blob(8, property);\n};\n\n/**\n * Layout for a Rust String type\n */\nexport const rustString = (property: string = 'string') => {\n  const rsl = BufferLayout.struct(\n    [\n      BufferLayout.u32('length'),\n      BufferLayout.u32('lengthPadding'),\n      BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), 'chars'),\n    ],\n    property,\n  );\n  const _decode = rsl.decode.bind(rsl);\n  const _encode = rsl.encode.bind(rsl);\n\n  rsl.decode = (buffer, offset) => {\n    const data = _decode(buffer, offset);\n    return data.chars.toString('utf8');\n  };\n\n  rsl.encode = (str, buffer, offset) => {\n    const data = {\n      chars: Buffer.from(str, 'utf8'),\n    };\n    return _encode(data, buffer, offset);\n  };\n\n  return rsl;\n};\n\n\nasync function reset() {\n  if (target_con === undefined) {\n    throw \"Target contract is not loaded!\";\n  }\n  if (attack_con === undefined) {\n    throw \"Attack contract is not loaded!\";\n  }\n  // await resetBookKeeping();\n  await redeploy();\n  return \"Contracts are reset!\";\n}\n\n\n/// find the bookkeeping variable\nasync function findBookKeepingAbi(abis) {\n  for (var abi of abis) {\n    if (abi.type === 'function' && abi.constant &&\n        abi.inputs.length === 1 && abi.inputs[0].type === 'address' &&\n        abi.outputs.length === 1 && abi.outputs[0].type === 'uint256') {\n      return abi;\n    }\n  }\n  throw \"Cannot find bookkeeping variable!\";\n  return;\n}\n\n\nasync function findCandSequence(target_abis, attack_abis){\n  var target_switch = true;\n  var attack_switch = true;\n\n  if(target_switch){\n    await target_abis.forEach(function(abi) {\n      /// if abi.constant is true, it would not change state variables\n      if (abi.type === 'function' && abi.constant == false){\n        var notsupport = false;\n        var input_len = abi.inputs.length;\n        var input_index = 0;\n        while(input_index < input_len){\n          var input = abi.inputs[input_index];\n          if(input.type.indexOf('address') !== 0 && input.type.indexOf('uint') !== 0){\n            notsupport = true;\n            break;\n          }\n          input_index += 1;\n        }\n        if(!notsupport){\n          cand_sequence.push(abi);\n        }\n      }\n    }); \n  }\n  if(attack_switch){\n    await attack_abis.forEach(function(abi) {\n      if (abi.type === 'function' && abi.constant == false){\n        var notsupport = false;\n        var input_len = abi.inputs.length;\n        var input_index = 0;\n        while(input_index < input_len){\n          var input = abi.inputs[input_index];\n          if(input.type.indexOf('address') !== 0 && input.type.indexOf('uint') !== 0){\n            notsupport = true;\n            break;\n          }\n          input_index += 1;\n        }\n        if(!notsupport){\n          cand_sequence.push(abi);\n        }\n      }\n    }); \n  }\n}","// @flow\n\n// var util = require('util');\n// var _ = require('underscore');\n// var clc = require('cli-color');\n// var moment = require('moment');\n// import  RpcClient from './rpc-client' ;\n// var logger = require('bunyan').createLogger({\n//     name: 'RpcClient',\n//     level: 'trace'\n// });\n\n// function inspect(obj) {\n//     return obj ? util.inspect(obj, {\n//         depth: null\n//     }) : '';\n// }\n\n// function printResult(error, result) {\n//     console.log(clc.red(inspect(error)));\n//     console.log(clc.cyan(inspect(result)));\n// }\n\n// function printJsonResult(error, result) {\n//     console.log(clc.red(inspect(error)));\n\n//     var output = result;\n//     try {\n//         output = JSON.parse(result);\n//     } catch (err) {\n//         // use default\n//     }\n\n//     console.log(clc.cyan(inspect(output)));\n// }\n\n// var context = 'OR CPRS GUI CHART';\n\n// var configuration = {\n//     context: 'HMP UI CONTEXT',\n//     host: 'IP        ',\n//     port: 2222,\n//     accessCode: 'REDACTED',\n//     verifyCode: 'REDACTED',\n//     localIP: 'IP      ',\n//     localAddress: 'localhost'\n// };\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst buffer_1 = require(\"buffer\");\nclass BufferUtil {\n    static fromHex(source) {\n        const data = source.match(/.{1,2}/g).map(x => parseInt(x, 16));\n        return new Uint8Array(data);\n    }\n    static fromBase64(source) {\n        return Uint8Array.from(buffer_1.Buffer.from(source, 'base64'));\n    }\n    static fromString(source) {\n        const buffer = new ArrayBuffer(source.length);\n        const view = new DataView(buffer);\n        for (let i = 0; i < source.length; i++) {\n            view.setUint8(i, source.charCodeAt(i));\n        }\n        return new Uint8Array(buffer);\n    }\n    static toString(source) {\n        const data = [];\n        source.forEach(x => {\n            data.push(String.fromCharCode(x));\n        });\n        return data.join('');\n    }\n    static toHex(sources) {\n        const data = [];\n        sources.forEach(x => {\n            data.push(x.toString(16).padStart(2, '0'));\n        });\n        return data.join('');\n    }\n    static toBase64(sources) {\n        return buffer_1.Buffer.from(sources).toString('base64');\n    }\n    static concat(a, b) {\n        const c = new Uint8Array(a.length + b.length);\n        c.set(a);\n        c.set(b, a.length);\n        return c;\n    }\n}\nexports.BufferUtil = BufferUtil;\n\n/*\ndecode an array of number and return it's length.\n */\nexport function getDecodedArrayLength(bytes: Array<number>): number {\n  let len_to_return = 0;\n  let size = 0;\n  for (;;) {\n    let elem_of_array = bytes.shift();\n    len_to_return |= (elem_of_array & 0x7f) << (size * 7);\n    size += 1;\n    if ((elem_of_array & 0x80) === 0) {\n      break;\n    }\n  }\n  return len_to_return;\n}\n/*\nencode an array of number. \n*/\nexport function encodeArrayWithInteger(bytes: Array<number>, len: number) {\n  let new_len = len;\n  for (;;) {\n    let new_elem = new_len & 0x7f;\n    new_len >>= 7;\n    if (new_len == 0) {\n      bytes.push(new_elem);\n      break;\n    } else {\n      new_elem |= 0x80;\n      bytes.push(new_elem);\n    }\n  }\n}\n\n\n// Object.defineProperty(exports, \"__esModule\", { value: true });\nexports.CollectionUtil = {\n    binarySearch(sortedArray, item) {\n        let lowIdx = 0;\n        let highIdx = sortedArray.length - 1;\n        while (lowIdx <= highIdx) {\n            const midIdx = Math.floor((lowIdx + highIdx) / 2);\n            if (sortedArray[midIdx] === item) {\n                return midIdx;\n            }\n            else if (sortedArray[midIdx] < item) {\n                lowIdx = midIdx + 1;\n            }\n            else {\n                highIdx = midIdx - 1;\n            }\n        }\n        return null;\n    },\n};\nexports.default = exports.CollectionUtil;\n\n\nclass CursorBuffer {\n    constructor(typedArray, littleEndian = true) {\n        this.dataView = new DataView(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n        this.littleEndian = littleEndian;\n        this.bytePositon = 0;\n    }\n    /**\n     * Reads 1 byte\n     *\n     */\n    read8() {\n        const value = this.dataView.getUint8(this.bytePositon);\n        this.bytePositon += 1;\n        return value;\n    }\n    /**\n     * Reads 4 bytes\n     *\n     */\n    read32() {\n        const value = this.dataView.getUint32(this.bytePositon, this.littleEndian);\n        this.bytePositon += 4;\n        return value;\n    }\n    /**\n     * Reads 8 bytes\n     *\n     *\n     */\n    read64() {\n        const firstPart = this.read32();\n        const secondPart = this.read32();\n        const combined = this.littleEndian\n            ? secondPart.toString(16) + firstPart.toString(16).padStart(8, '0')\n            : firstPart.toString(16) + secondPart.toString(16).padStart(8, '0');\n        return new bignumber_js_1.default(`0x${combined}`, 16);\n    }\n    readXBytes(x) {\n        // console.log(this.bytePositon, this.dataView.byteOffset);\n        // this.bytePositon -= 8;\n\n        const startPosition = this.bytePositon + this.dataView.byteOffset; // original = 27\n        console.log(startPosition);\n        const value = new Uint8Array(this.dataView.buffer, startPosition, x);\n        this.bytePositon += x;\n        return value;\n\n        // + 8 // receiver | 19 // sender (when not skipping bytes with .read32 before signedTxn)\n\n        // const startPosition = this.bytePositon + this.dataView.byteOffset + 8; // receiver = 35\n        // const value = new Uint8Array(this.dataView.buffer, startPosition, x);\n        // this.bytePositon += x;\n        // return value;\n\n        // const value = new Uint8Array(this.dataView.buffer, 19, x); // sender\n        // return value;\n    }\n    readXXBytes(x) {\n      this.bytePositon += 4;\n      \n      const value = new Uint8Array(this.dataView.buffer, 271, x);\n      return value;\n    }\n    /**\n     * Read bool as 1 byte\n     *\n     */\n    readBool() {\n        const value = this.dataView.getUint8(this.bytePositon);\n        this.bytePositon += 1;\n        if (value !== 0 && value !== 1) {\n            throw new Error(`bool must be 0 or 1, found ${value}`);\n        }\n        return value !== 0;\n    }\n}","// @flow\n\nimport invariant from 'assert';\nimport * as BufferLayout from 'buffer-layout';\nimport nacl from 'tweetnacl';\nimport bs58 from 'bs58';\n\nimport * as Layout from './buffer-cntl';\nimport {PubKey} from './bvm-addr';\nimport {BusAccount} from './bvm-acct';\nimport * as shortvec from './util/integer-array-encoding';\nimport type {Blockhash} from './tx-seal';\n\n/////////////////////////////////////////////////////////////////////////////////////////\nasync function mutate_callFun(call, callSequence, index) {\n  var sequence_new_list = [];\n  /// mutate the gas\n  var gas_sequence_list = await mutate_gas(call, callSequence, index);\n  for(var gas_sequence of gas_sequence_list){\n    sequence_new_list.push(gas_sequence);\n  }\n  /// mutate the input based on the balance\n  var bal_sequence_list = await mutate_balance(call, callSequence, index);\n  for(var bal_sequence of bal_sequence_list){\n    sequence_new_list.push(bal_sequence);\n  }\n  /// mutate the input based on the neighbor\n  var uint_sequence_list = await mutate_uint(call, callSequence, index);\n  for(var uint_sequence of uint_sequence_list){\n    sequence_new_list.push(uint_sequence);\n  }  \n  return sequence_new_list;\n}\n\n\nasync function mutate_callFun_uint_meaningful(call, callSequence, index) {\n  var unum_diff = '0.0000001';\n  /// unum_diff is not handled here, because it is relevant to multiple parameters\n  /// generate a new call function\n  var modify_result = await modify_callFun_uint_meaningful(call, unum_diff);\n  if(modify_result[0]){\n    /// callSequence itself is changed, not change at its copy \n    callSequence[index] = modify_result[1]; \n    return true;\n  }\n  else{\n    return false;\n  }\n}\n\nasync function mutate_callFun_gas_meaningful(call, callSequence, index) {\n  var gas_diff = '30.0';\n  var modify_result = await modify_callFun_gas_meaningful(call, gas_diff);\n  /// callSequence itself is changed, not change at its copy \n  if(modify_result[0]){\n    callSequence[index] = modify_result[1]; \n    return true;\n  }\n  else{\n    return false;\n  }\n}\n\nasync function mutate_callSequence(callSequence){\n  var callSequence_new_set = new Set();\n  var mutateSeque_index = 0;\n  while(mutateSeque_index < mutateSeque_maxLen){\n    /// copy the previous sequence, it would be modified\n    var callSequence_new = callSequence.slice();\n    var sequence_len = callSequence_new.length;\n    var mutateOper_index = 0;\n    while(mutateOper_index < mutateOper_maxLen){\n      /// the location to mutate\n      var sequence_index = randomNum(0, sequence_len);\n      /// the type of mutation, e.g., add, delete, and modify\n      var mutation_type = randomNum(0, 3);\n      if(mutation_type == 0){\n        /// add operation\n        var operSeque_num = randomNum(0, operSeque_maxLen);\n        var operSeque_index = 0;\n        while(operSeque_index < operSeque_num){\n          var abi_index = randomNum(0, cand_sequence.length);\n          var abi = cand_sequence[abi_index];\n          var callFun = await gen_callFun(abi);\n          /// add the element\n          callSequence_new.splice(sequence_index, 0, callFun);\n          operSeque_index += 1;\n        }\n      }\n      else if(mutation_type == 1){\n        /// delete operation\n        var operSeque_num = randomNum(0, operSeque_maxLen);\n        /// delete operSeque_num element\n        callSequence_new.splice(sequence_index, operSeque_num);     \n      }\n      else if(mutation_type == 2){\n        /// modify operation\n        var operSeque_num = randomNum(0, operSeque_maxLen);\n        var operSeque_index = 0;\n        while(operSeque_index < operSeque_num){\n          var abi_index = randomNum(0, cand_sequence.length);\n          var abi = cand_sequence[abi_index];\n          var callFun = await gen_callFun(abi);\n          /// replace the element\n          callSequence_new.splice(sequence_index + operSeque_index, 1, callFun);\n          operSeque_index += 1;\n        }\n      }\n      mutateOper_index += 1;\n    }\n    callSequence_new_set.add(callSequence_new);\n    mutateSeque_index += 1;\n  }\n  return callSequence_new_set;\n}\n\nasync function insert_ownship(){\n  await target_con._jsonInterface.forEach(function(abi) {\n    /// abi.constant == true would not change state variables\n    if (abi.name == 'transferOwnship'){\n      let call = {\n        from: account_list[0],\n        to: target_con.options.address,\n        abi: abi,\n        gas: '1000000',\n        param: [],\n      }\n      return call;\n    }\n  });\n}\n\nasync function seed_callSequence() {\n  var call_sequence = [];\n\n  /// at least there are two calls\n  var sequence_len = randomNum(2, sequence_maxLen);\n  var sequence_index = 0;\n  while (sequence_index < sequence_len){\n    /// 0 <= call_index < cand_sequence.length\n    var abi_index = randomNum(0, cand_sequence.length);\n    var abi = cand_sequence[abi_index];\n    var callFun = await gen_callFun(abi);\n    call_sequence.push(callFun);\n    sequence_index += 1;\n  }\n  return call_sequence;\n}\n\n///Redeploy contract\nasync function redeploy(){\n  console.log(\"redeploy......\");\n  target_con = await target_con.deploy({data: target_artifact.bytecode, arguments: []})\n    .send({\n      from: account_list[0],\n      gas: 1500000,\n      value: web3.utils.toWei(\"5\", \"ether\")\n   });\n  attack_con = await attack_con.deploy({data: attack_artifact.bytecode, arguments: [target_con.options.address]})\n    .send({\n      from: account_list[0],\n      gas: 1500000,\n      value: web3.utils.toWei(\"5\", \"ether\")\n    });\n    console.log(target_con.options.address);\n}\n/////////////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * @typedef {string} TxnSignature\n */\nexport type TxnSignature = string;\n\n/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */\nexport const PACKET_DATA_SIZE = 1280 - 40 - 8;\n\n/**\n * List of TxOperation object fields that may be initialized at construction\n *\n * @typedef {Object} TxInstructionControlFields\n * @property {?Array<PubKey>} keys\n * @property {?PubKey} controllerId\n * @property {?Buffer} data\n */\ntype TxInstructionControlFields = {|\n  keys?: Array<{pubkey: PubKey, isSigner: boolean, isDebitable: boolean}>,\n  controllerId?: PubKey,\n  data?: Buffer,\n|};\n\n/**\n * Transaction Instruction class\n */\nexport class TxOperation {\n  /**\n   * Public keys to include in this transaction\n   * Boolean represents whether this pubkey needs to sign the transaction\n   */\n  keys: Array<{\n    pubkey: PubKey,\n    isSigner: boolean,\n    isDebitable: boolean,\n  }> = [];\n\n  /**\n   * Controller Id to execute\n   */\n  controllerId: PubKey;\n\n  /**\n   * Controller input\n   */\n  data: Buffer = Buffer.alloc(0);\n\n  constructor(opts?: TxInstructionControlFields) {\n    opts && Object.assign(this, opts);\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////\n/// for debugging\nasync function print_callSequence(calls_list){\n  for(var calls of calls_list){\n    console.log(calls);\n  }\n}\n\nasync function experiment_results(){\n  endTime = new Date();\n  timeDiff = Math.round((endTime - startTime) / 1000);\n  console.log(\"elapsed time: \" + timeDiff);\n  var coverage_stmt = new Set();\n  console.log(contr_depen_set);\n  for(var contr_depen of contr_depen_set){\n    var two_stmts = contr_depen.split('#');\n    coverage_stmt.add(two_stmts[0]);\n    coverage_stmt.add(two_stmts[1]);\n  }\n  var coverage_ratio = coverage_stmt.size / (attackStmt_set.size + targetStmt_set.size);\n  console.log(\"coverage ratio: \" + coverage_ratio);\n}\n\nasync function internal_change(exec_results){\n  if(exec_results[1] != exec_results[2]){\n    return true;\n  }\n  else if(exec_results[3] != exec_results[4]){\n    return true;\n  }\n  else if(exec_results[5] != exec_results[6]){\n    return true;\n  }\n  else if(exec_results[7] != exec_results[8]){\n    return true;\n  }\n  return false;\n}\n\n\nasync function exec_sequence_call(){\n  // console.log(sequence_call_list[0]);\n  if(fuzzing_finish){\n    /// for reentrancy\n    // if (stmt_trace.length > 30)\n      /// we finish the fuzzing\n    return;\n  }\n  /// deal with the results of previous transaction\n  /// mutate the function call, e.g., input, gas\n  seque_depen_num_bf = seque_depen_set.size;\n  /// add into the sequence dependencies\n  for(var trans_depen of trans_depen_set){\n    if (seque_depen_set.has(trans_depen) == false){\n      seque_depen_set.add(trans_depen);\n    }\n  }\n  seque_depen_num_af = seque_depen_set.size;\n  console.log(\"seque before: \" + seque_depen_num_bf + \" seque after: \" + seque_depen_num_af);\n  console.log(seque_depen_set);\n  if(seque_depen_num_af > seque_depen_num_bf){\n    /// mutate the input and gas of the call\n    /// sequence_executed, and sequeExe_index is still right\n    var calls_new_list = await mutate_callFun(lastCall, sequence_executed, sequeExe_index -1);\n    for(var calls_new of calls_new_list){\n      sequence_call_list.push(calls_new);\n    }    \n    var callSequence_new_set = await mutate_callSequence(sequence_executed);\n    for(var callSequence_new of callSequence_new_set){\n      sequence_call_list.push(callSequence_new);\n    }  \n  }\n\n  if(new_sequence_start){\n    /// it a new call sequence, we consider the precious call sequence\n    var contr_set_num_bf = contr_depen_set.size; \n    for(var seque_depen of seque_depen_set){\n      if(contr_depen_set.has(seque_depen) == false){\n        contr_depen_set.add(seque_depen);\n      }\n    }      \n    var contr_set_num_af = contr_depen_set.size;\n    if(contr_set_num_af > contr_set_num_bf){\n      /// the call sequence generate new coverage, generate the new call sequence\n      var callSequence_new_set = await mutate_callSequence(sequence_executed);\n      for(var callSequence_new of callSequence_new_set){\n        sequence_call_list.push(callSequence_new);\n      }\n    }\n\n    /// start another statement trace, because another call sequence\n    seque_stmt_trace = [];\n    /// clear the coverage of call sequence, because we execute the new call sequence\n    seque_depen_set.clear();\n    sequeExe_meaningful = false;\n    if(sequence_call_list.length != 0){\n      /// the call sequence for the next execution\n      sequence_executed = sequence_call_list[0].slice();\n      sequeExe_index = 0;\n      console.log(\"start another sequence.....\");\n    }\n    else{\n      fuzzing_finish = true;\n      await experiment_results();\n      console.log(\"fuzzing finish....\");\n      return;\n    }\n  }\n  // console.log(sequence_call_list[0]);\n  if(sequence_call_list.length !== 0){\n    var sequence = sequence_call_list[0];\n    var sequence_found = false;\n    while(true){\n      /// call sequence is empty, which may be generated by delete some calls\n      if(sequence.length !== 0){\n        sequence_found = true;\n        break;\n      }\n      else{\n        sequence_call_list.splice(0, 1);\n        if(sequence_call_list.length != 0){\n          /// start another statement trace, because another call sequence\n          seque_stmt_trace = [];\n          /// clear the coverage of call sequence, because we execute the new call sequence\n          seque_depen_set.clear();\n          sequeExe_meaningful = false;\n          /// the call sequence for the next execution\n          sequence_executed = sequence_call_list[0].slice();\n          sequeExe_index = 0;\n     \n          sequence = sequence_call_list[0];\n        }\n        else{\n          fuzzing_finish = true;\n          experiment_results();\n          console.log(\"fuzzing finish.....\");\n          return;\n        }\n      }\n    }\n    if(sequence_found){\n      var call = sequence[0];\n      lastCall = call;\n      exec_results = await exec_callFun(call);\n      if(exec_results === \"found\"){\n        /// stop the running\n        fuzzing_finish = true;\n        experiment_results();\n        console.log(\"fuzzing finish....\");\n      }\n      else if(exec_results === \"revert\"){\n        var mutate_gas_suc = await mutate_callFun_gas_meaningful(call, sequence_executed, sequeExe_index);\n        if(mutate_gas_suc){\n          sequeExe_meaningful = true;\n        }    \n        // if(exec_results[1] == exec_results[5] && exec_results[3] == exec_results[7]){\n        //   /// here we use sequence_executed[sequeExe_index], because call is changed by its gas before\n        //   var mutate_uint_suc = await mutate_callFun_uint_meaningful(sequence_executed[sequeExe_index], sequence_executed, sequeExe_index);\n        //   if(mutate_uint_suc){\n        //     sequeExe_meaningful = true;\n        //   }  \n        // } \n        exec_results = exec_results.slice(1);   \n        /// sort is performed at the original array, not generate a new copy\n        /// it is used in the mutate_callFun\n        exec_results.sort(sortNumber);        \n      }\n      else {\n        var status_change = await internal_change(exec_results);\n        if(!status_change){\n          /// here we use sequence_executed[sequeExe_index], because call is changed by its gas before\n          var mutate_uint_suc = await mutate_callFun_uint_meaningful(call, sequence_executed, sequeExe_index);\n          if(mutate_uint_suc){\n            sequeExe_meaningful = true;\n          }  \n        } \n        exec_results = exec_results.slice(1);   \n        /// sort is performed at the original array, not generate a new copy\n        /// it is used in the mutate_callFun\n        exec_results.sort(sortNumber);        \n      }\n\n      /// delete the call function\n      sequence.splice(0, 1);\n      /// sequeExe_index increase\n      sequeExe_index += 1;\n      new_sequence_start = false;\n      if(sequence.length === 0){\n        /// a call sequence is executed completely, delete the previous call sequence\n        sequence_call_list.splice(0, 1);\n        new_sequence_start = true;\n\n        /// the sequence_executed becomes more meaningfule\n        if(sequeExe_meaningful){\n          /// we should use sequence_executed.slice\n          /// because sequence_executed may be changer later\n          /// we should add them into the front, because it is meaningful verson of last call sequence\n          sequence_call_list.unshift(sequence_executed.slice());\n        }\n        else{\n          /// the transferred money cannot be change, we generate another call sequence\n          if(sequence_call_list.length <= 3){\n            var callSequence_new_set = await mutate_callSequence(sequence_executed);\n            for(var callSequence_new of callSequence_new_set){\n              sequence_call_list.push(callSequence_new);\n            }\n          }\n        }\n        /// TODO maybe the parameters are wrong\n        // if(reset_index >= reset_num){\n        //   await redeploy();  \n        //   reset_num = randomNum(0, 50);\n        //   reset_index = 0;          \n        // }\n        // else{\n        //   reset_index += 1;\n        // }\n      }\n    }\n  }\n}\n/////////////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * @private\n */\ntype SignaturePubkeyPair = {|\n  signature: Buffer | null,\n  pubKey: PubKey,\n|};\n\n/**\n * List of Transaction object fields that may be initialized at construction\n *\n * @typedef {Object} TxnControlFields\n * @property (?recentPackagehash} A recent block hash\n * @property (?signatures} One or more signatures\n *\n */\ntype TxnControlFields = {|\n  recentPackagehash?: Blockhash | null,\n  signatures?: Array<SignaturePubkeyPair>,\n|};\n\n/**\n * Transaction class\n */\nexport class Transaction {\n  /**\n   * Signatures for the transaction.  Typically created by invoking the\n   * `sign()` method\n   */\n  signatures: Array<SignaturePubkeyPair> = [];\n\n  /**\n   * The first (payer) Transaction signature\n   */\n  get signature(): Buffer | null {\n    if (this.signatures.length > 0) {\n      return this.signatures[0].signature;\n    }\n    return null;\n  }\n\n  /**\n   * The operations to atomically execute\n   */\n  operations: Array<TxOperation> = [];\n\n  /**\n   * A recent transaction id.  Must be populated by the caller\n   */\n  recentPackagehash: Blockhash | null;\n\n  /**\n   * Construct an empty Transaction\n   */\n  constructor(opts?: TxnControlFields) {\n    opts && Object.assign(this, opts);\n  }\n\n  /**\n   * Add one or more operations to this Transaction\n   */\n  add(\n    ...items: Array<\n      Transaction | TxOperation | TxInstructionControlFields,\n    >\n  ): Transaction {\n    if (items.length === 0) {\n      throw new Error('No operations');\n    }\n\n    items.forEach(item => {\n      if (item instanceof Transaction) {\n        this.operations = this.operations.concat(item.operations);\n      } else if (item instanceof TxOperation) {\n        this.operations.push(item);\n      } else {\n        this.operations.push(new TxOperation(item));\n      }\n    });\n    return this;\n  }\n\n  /**\n   * @private\n   */\n  _fetchSignData(): Buffer {\n    const {recentPackagehash} = this;\n    if (!recentPackagehash) {\n      throw new Error('Transaction recentPackagehash required');\n    }\n\n    if (this.operations.length < 1) {\n      throw new Error('No operations provided');\n    }\n\n    const keys = this.signatures.map(({pubKey}) => pubKey.toString());\n    let numRequiredSignatures = 0;\n    let numCreditOnlySignedAccounts = 0;\n    let numCreditOnlyUnsignedAccounts = 0;\n\n    const programIds = [];\n\n    this.operations.forEach(instruction => {\n      instruction.keys.forEach(keySignerPair => {\n        const keyStr = keySignerPair.pubkey.toString();\n        if (!keys.includes(keyStr)) {\n          if (keySignerPair.isSigner) {\n            numRequiredSignatures += 1;\n            if (!keySignerPair.isDebitable) {\n              numCreditOnlySignedAccounts += 1;\n            }\n          } else {\n            if (!keySignerPair.isDebitable) {\n              numCreditOnlyUnsignedAccounts += 1;\n            }\n          }\n          keys.push(keyStr);\n        }\n      });\n\n      const controllerId = instruction.controllerId.toString();\n      if (!programIds.includes(controllerId)) {\n        programIds.push(controllerId);\n      }\n    });\n\n    programIds.forEach(controllerId => {\n      if (!keys.includes(controllerId)) {\n        keys.push(controllerId);\n        numCreditOnlyUnsignedAccounts += 1;\n      }\n    });\n\n    if (numRequiredSignatures > this.signatures.length) {\n      throw new Error(\n        `Insufficent signatures: expected ${numRequiredSignatures} but got ${\n          this.signatures.length\n        }`,\n      );\n    }\n\n    let keyCount = [];\n    shortvec.encodeArrayWithInteger(keyCount, keys.length);\n\n    const operations = this.operations.map(instruction => {\n      const {data, controllerId} = instruction;\n      let keyIndicesCount = [];\n      shortvec.encodeArrayWithInteger(keyIndicesCount, instruction.keys.length);\n      let dataCount = [];\n      shortvec.encodeArrayWithInteger(dataCount, instruction.data.length);\n      return {\n        programIdIndex: keys.indexOf(controllerId.toString()),\n        keyIndicesCount: Buffer.from(keyIndicesCount),\n        keyIndices: Buffer.from(\n          instruction.keys.map(keyObj =>\n            keys.indexOf(keyObj.pubkey.toString()),\n          ),\n        ),\n        dataLength: Buffer.from(dataCount),\n        data,\n      };\n    });\n\n    operations.forEach(instruction => {\n      invariant(instruction.programIdIndex >= 0);\n      instruction.keyIndices.forEach(keyIndex => invariant(keyIndex >= 0));\n    });\n\n    let instructionCount = [];\n    shortvec.encodeArrayWithInteger(instructionCount, operations.length);\n    let instructionBuffer = Buffer.alloc(PACKET_DATA_SIZE);\n    Buffer.from(instructionCount).copy(instructionBuffer);\n    let instructionBufferLength = instructionCount.length;\n\n    operations.forEach(instruction => {\n      const instructionLayout = BufferLayout.struct([\n        BufferLayout.u8('programIdIndex'),\n\n        BufferLayout.blob(\n          instruction.keyIndicesCount.length,\n          'keyIndicesCount',\n        ),\n        BufferLayout.seq(\n          BufferLayout.u8('keyIndex'),\n          instruction.keyIndices.length,\n          'keyIndices',\n        ),\n        BufferLayout.blob(instruction.dataLength.length, 'dataLength'),\n        BufferLayout.seq(\n          BufferLayout.u8('userdatum'),\n          instruction.data.length,\n          'data',\n        ),\n      ]);\n      const length = instructionLayout.encode(\n        instruction,\n        instructionBuffer,\n        instructionBufferLength,\n      );\n      instructionBufferLength += length;\n    });\n    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n\n    const signDataLayout = BufferLayout.struct([\n      BufferLayout.blob(1, 'numRequiredSignatures'),\n      BufferLayout.blob(1, 'numCreditOnlySignedAccounts'),\n      BufferLayout.blob(1, 'numCreditOnlyUnsignedAccounts'),\n      BufferLayout.blob(keyCount.length, 'keyCount'),\n      BufferLayout.seq(Layout.pubKey('key'), keys.length, 'keys'),\n      Layout.pubKey('recentPackagehash'),\n    ]);\n\n    const transaction = {\n      numRequiredSignatures: Buffer.from([this.signatures.length]),\n      numCreditOnlySignedAccounts: Buffer.from([numCreditOnlySignedAccounts]),\n      numCreditOnlyUnsignedAccounts: Buffer.from([\n        numCreditOnlyUnsignedAccounts,\n      ]),\n      keyCount: Buffer.from(keyCount),\n      keys: keys.map(key => new PubKey(key).toBuffer()),\n      recentPackagehash: Buffer.from(bs58.decode(recentPackagehash)),\n    };\n\n    let signData = Buffer.alloc(2048);\n    const length = signDataLayout.encode(transaction, signData);\n    instructionBuffer.copy(signData, length);\n    signData = signData.slice(0, length + instructionBuffer.length);\n\n    return signData;\n  }\n\n  /**\n   * Sign the Transaction with the specified accounts.  Multiple signatures may\n   * be applied to a Transaction. The first signature is considered \"primary\"\n   * and is used when testing for Transaction confirmation.\n   *\n   * Transaction fields should not be modified after the first call to `sign`,\n   * as doing so may invalidate the signature and cause the Transaction to be\n   * rejected.\n   *\n   * The Transaction must be assigned a valid `recentPackagehash` before invoking this method\n   */\n  sign(...signers: Array<BusAccount>) {\n    this.signPartial(...signers);\n  }\n\n  /**\n   * Partially sign a Transaction with the specified accounts.  The `BusAccount`\n   * inputs will be used to sign the Transaction immediately, while any\n   * `PubKey` inputs will be referenced in the signed Transaction but need to\n   * be filled in later by calling `addSigner()` with the matching `BusAccount`.\n   *\n   * All the caveats from the `sign` method apply to `signPartial`\n   */\n  signPartial(...partialSigners: Array<PubKey | BusAccount>) {\n    if (partialSigners.length === 0) {\n      throw new Error('No signers');\n    }\n    const signatures: Array<SignaturePubkeyPair> = partialSigners.map(\n      accountOrPublicKey => {\n        const pubKey =\n          accountOrPublicKey instanceof BusAccount\n            ? accountOrPublicKey.pubKey\n            : accountOrPublicKey;\n        return {\n          signature: null,\n          pubKey,\n        };\n      },\n    );\n    this.signatures = signatures;\n    const signData = this._fetchSignData();\n\n    partialSigners.forEach((accountOrPublicKey, index) => {\n      if (accountOrPublicKey instanceof PubKey) {\n        return;\n      }\n      const signature = nacl.sign.detached(\n        signData,\n        accountOrPublicKey.privateKey,\n      );\n      invariant(signature.length === 64);\n      signatures[index].signature = Buffer.from(signature);\n    });\n  }\n\n  /**\n   * Fill in a signature for a partially signed Transaction.  The `signer` must\n   * be the corresponding `BusAccount` for a `PubKey` that was previously provided to\n   * `signPartial`\n   */\n  addSigner(signer: BusAccount) {\n    const index = this.signatures.findIndex(sigpair =>\n      signer.pubKey.equals(sigpair.pubKey),\n    );\n    if (index < 0) {\n      throw new Error(`Unknown signer: ${signer.pubKey.toString()}`);\n    }\n\n    const signData = this._fetchSignData();\n    const signature = nacl.sign.detached(signData, signer.privateKey);\n    invariant(signature.length === 64);\n    this.signatures[index].signature = Buffer.from(signature);\n  }\n\n  /**\n   * Serialize the Transaction in the wire format.\n   *\n   * The Transaction must have a valid `signature` before invoking this method\n   */\n  serialize(): Buffer {\n    const {signatures} = this;\n    if (!signatures) {\n      throw new Error('Transaction has not been signed');\n    }\n\n    const signData = this._fetchSignData();\n    const signatureCount = [];\n    shortvec.encodeArrayWithInteger(signatureCount, signatures.length);\n    const transactionLength =\n      signatureCount.length + signatures.length * 64 + signData.length;\n    const wireTransaction = Buffer.alloc(transactionLength);\n    invariant(signatures.length < 256);\n    Buffer.from(signatureCount).copy(wireTransaction, 0);\n    signatures.forEach(({signature}, index) => {\n      invariant(signature !== null, `null signature`);\n      invariant(signature.length === 64, `signature has invalid length`);\n      Buffer.from(signature).copy(\n        wireTransaction,\n        signatureCount.length + index * 64,\n      );\n    });\n    signData.copy(\n      wireTransaction,\n      signatureCount.length + signatures.length * 64,\n    );\n    invariant(\n      wireTransaction.length <= PACKET_DATA_SIZE,\n      `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`,\n    );\n    return wireTransaction;\n  }\n\n  /**\n   * Deprecated method\n   * @private\n   */\n  get keys(): Array<PubKey> {\n    invariant(this.operations.length === 1);\n    return this.operations[0].keys.map(keyObj => keyObj.pubkey);\n  }\n\n  /**\n   * Deprecated method\n   * @private\n   */\n  get controllerId(): PubKey {\n    invariant(this.operations.length === 1);\n    return this.operations[0].controllerId;\n  }\n\n  /**\n   * Deprecated method\n   * @private\n   */\n  get data(): Buffer {\n    invariant(this.operations.length === 1);\n    return this.operations[0].data;\n  }\n\n  /**\n   * Parse a wire transaction into a Transaction object.\n   */\n  static from(buffer: Buffer): Transaction {\n    const PUBKEY_LENGTH = 32;\n    const SIGNATURE_LENGTH = 64;\n\n    function isCreditDebit(\n      i: number,\n      numRequiredSignatures: number,\n      numCreditOnlySignedAccounts: number,\n      numCreditOnlyUnsignedAccounts: number,\n      numKeys: number,\n    ): boolean {\n      return (\n        i < numRequiredSignatures - numCreditOnlySignedAccounts ||\n        (i >= numRequiredSignatures &&\n          i < numKeys - numCreditOnlyUnsignedAccounts)\n      );\n    }\n\n    let transaction = new Transaction();\n\n    // Slice up wire data\n    let byteArray = [...buffer];\n\n    const signatureCount = shortvec.getDecodedArrayLength(byteArray);\n    let signatures = [];\n    for (let i = 0; i < signatureCount; i++) {\n      const signature = byteArray.slice(0, SIGNATURE_LENGTH);\n      byteArray = byteArray.slice(SIGNATURE_LENGTH);\n      signatures.push(signature);\n    }\n\n    const numRequiredSignatures = byteArray.shift();\n    // byteArray = byteArray.slice(1); // Skip numRequiredSignatures byte\n    const numCreditOnlySignedAccounts = byteArray.shift();\n    // byteArray = byteArray.slice(1); // Skip numCreditOnlySignedAccounts byte\n    const numCreditOnlyUnsignedAccounts = byteArray.shift();\n    // byteArray = byteArray.slice(1); // Skip numCreditOnlyUnsignedAccounts byte\n\n    const accountCount = shortvec.getDecodedArrayLength(byteArray);\n    let accounts = [];\n    for (let i = 0; i < accountCount; i++) {\n      const account = byteArray.slice(0, PUBKEY_LENGTH);\n      byteArray = byteArray.slice(PUBKEY_LENGTH);\n      accounts.push(account);\n    }\n\n    const recentPackagehash = byteArray.slice(0, PUBKEY_LENGTH);\n    byteArray = byteArray.slice(PUBKEY_LENGTH);\n\n    const instructionCount = shortvec.getDecodedArrayLength(byteArray);\n    let operations = [];\n    for (let i = 0; i < instructionCount; i++) {\n      let instruction = {};\n      instruction.programIndex = byteArray.shift();\n      const accountIndexCount = shortvec.getDecodedArrayLength(byteArray);\n      instruction.accountIndex = byteArray.slice(0, accountIndexCount);\n      byteArray = byteArray.slice(accountIndexCount);\n      const dataLength = shortvec.getDecodedArrayLength(byteArray);\n      instruction.data = byteArray.slice(0, dataLength);\n      byteArray = byteArray.slice(dataLength);\n      operations.push(instruction);\n    }\n\n    // Populate Transaction object\n    transaction.recentPackagehash = new PubKey(recentPackagehash).toBase58();\n    for (let i = 0; i < signatureCount; i++) {\n      const sigPubkeyPair = {\n        signature: Buffer.from(signatures[i]),\n        pubKey: new PubKey(accounts[i]),\n      };\n      transaction.signatures.push(sigPubkeyPair);\n    }\n    for (let i = 0; i < instructionCount; i++) {\n      let instructionData = {\n        keys: [],\n        controllerId: new PubKey(accounts[operations[i].programIndex]),\n        data: Buffer.from(operations[i].data),\n      };\n      for (let j = 0; j < operations[i].accountIndex.length; j++) {\n        const pubkey = new PubKey(accounts[operations[i].accountIndex[j]]);\n\n        instructionData.keys.push({\n          pubkey,\n          isSigner: transaction.signatures.some(\n            keyObj => keyObj.pubKey.toString() === pubkey.toString(),\n          ),\n          isDebitable: isCreditDebit(\n            j,\n            numRequiredSignatures,\n            numCreditOnlySignedAccounts,\n            numCreditOnlyUnsignedAccounts,\n            accounts.length,\n          ),\n        });\n      }\n      let instruction = new TxOperation(instructionData);\n      transaction.operations.push(instruction);\n    }\n    return transaction;\n  }\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////\nasync function generateFunctionInputs_donate(abi) {\n\n  let parameters = [];  \n  await abi.inputs.forEach(function(param) {\n    if (param.type == 'address') {\n      // parameters.push(attack_con.options.address);\n      parameters.push(account_list[0]);\n    } else if (param.type == 'uint256') {\n      // parameters.push(web3.utils.toWei('1', 'ether'));\n      parameters.push(\"2000000000\");\n    } else {\n      // default parameter\n      parameters.push(0);\n    }\n  });\n\n  let call = {\n    from: account_list[0],\n    to: abi.name.indexOf('vultron_') !== -1 ? attack_con.options.address : target_con.options.address,\n    abi: abi,\n    gas: '1000000',\n    param: parameters,\n  }\n  return call;\n}\n\nasync function generateFunctionInputs_withdraw(abi) {\n  if (abi.constant) return;\n  if (abi.type != 'function') return;\n\n  let parameters = [];  \n  await abi.inputs.forEach(function(param) {\n    if (param.type == 'address') {\n      parameters.push(attack_con.options.address);\n    } else if (param.type == 'uint256') {\n      // parameters.push(web3.utils.toWei('1', 'ether'));\n      parameters.push(\"1000000000\");\n    } else {\n      // default parameter\n      parameters.push(0);\n    }\n  });\n\n  let call = {\n    from: account_list[0],\n    to: abi.name.indexOf('vultron_') !== -1 ? attack_con.options.address : target_con.options.address,\n    abi: abi,\n    gas: '1000000',\n    param: parameters,\n  }\n  return call;\n}\n\nasync function simple_callSequence() {\n  let callFun_list = [];\n  await cand_sequence.forEach(function(abi) {\n    if (abi.name == 'setTaxes') {\n      generateFunctionInputs_donate(abi).then(function(call) {\n      callFun_list.push(call);\n      })\n    }\n  });\n  await cand_sequence.forEach(function(abi) {\n    if (abi.constant || abi.type != 'function')\n      return;\n\n    if (abi.name == 'transfer') {\n      generateFunctionInputs_withdraw(abi).then(function(call) {\n      callFun_list.push(call);\n      })\n    }\n  });\n  return callFun_list;\n}\n///////////////////////////////////////////////////////////////////////////////////////////","// @flow\n\n/*\ndormant XX million sec\n */\nexport function dormant(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n","// @flow\n\nimport assert from 'assert';\nimport {parse as urlParse, format as urlFormat} from 'url';\nimport fetch from 'node-fetch';\nimport jayson from 'jayson/lib/client/browser';\nimport {struct} from 'superstruct';\nimport {Client as RpcWebSocketClient} from 'rpc-websockets';\n\nimport {DEFAULT_TICKS_PER_SLOT, NUM_TICKS_PER_SEC} from './timing';\nimport {PubKey} from './bvm-addr';\nimport {Transaction} from './tx-dapp';\nimport {dormant} from './util/dormant';\nimport type {Blockhash} from './tx-seal';\nimport type {FeeCalculator} from './gas-cost';\nimport type {BusAccount} from './bvm-acct';\nimport type {TxnSignature} from './tx-dapp';\n\n\nvar number_type = 0;\nvar string_type = 1;\nvar object_type = 2;\nvar boolean_type = 3;\n\nvar _types = {\n    [number_type]: 'number',\n    [string_type]: 'string',\n    [object_type]: 'object',\n    [boolean_type]: 'boolean'\n};\n\nfunction check(args, ...types) {\n  if((typeof args !== typeof arguments) && !isArray(args)) {\n      args = [args];\n  }\n\n  if(args.length !== types.length){\n      throw new TypeError(`unmatch number of arguments, expected ${types.length} but got ${args.length}`);\n  }\n\n  for (let index in args) {\n      if(typeof types[index] === 'number') {\n          assert(types[index] in _types);\n\n          if(typeof args[index] !== _types[types[index]]) {\n              throw new TypeError(`invalid parameter at position ${index}, expected ${_types[types[index]]} but got ${typeof args[index]}`)\n          }\n      } else if(typeof types[index] === 'function') {\n          if(!(args[index] instanceof types[index])) {\n              let functionName = types[index].toString();\n              if (functionName.startsWith('class')) {\n                  functionName = functionName.substr('class '.length);\n                  functionName = functionName.substr(0, functionName.indexOf('{')).trim();\n              } else {\n                  functionName = functionName.substr('function '.length);\n                  functionName = functionName.substr(0, functionName.indexOf('(')).trim();\n              }\n\n              throw new TypeError(`invalid parameter at position ${index}, expected instance of ${functionName} but got ${typeof args[index]}`)\n          }\n      }\n  }\n}\n\n\nconst ConditionOp = {\n    EQ: 'eq',\n    NE: 'ne',\n    GT: 'gt',\n    GE: 'ge',\n    LT: 'lt',\n    LE: 'le',\n    LIMIT: 'limit'\n};\n\nclass Condition {\n    constructor() {\n        this.conditions = {};\n    }\n\n    eq(key, value) {\n        check(arguments, string, string);\n\n        this.conditions[key] = {\n            [ConditionOp.EQ]: value\n        };\n    }\n\n    ne(key, value) {\n        check(arguments, string, string);\n\n        this.conditions[key] = {\n            [ConditionOp.NE]: value\n        };\n    }\n\n    gt(key, value) {\n        check(arguments, string, string);\n\n        this.conditions[key] = {\n            [ConditionOp.GT]: value\n        };\n    }\n\n    ge(key, value) {\n        check(arguments, string, string);\n\n        this.conditions[key] = {\n            [ConditionOp.GE]: value\n        };\n    }\n\n    lt(key, value) {\n        check(arguments, string, string);\n\n        this.conditions[key] = {\n            [ConditionOp.LT]: value\n        };\n    }\n\n    le(key, value) {\n        check(arguments, string, string);\n\n        this.conditions[key] = {\n            [ConditionOp.LE]: value\n        };\n    }\n\n    limit(...args) {\n        if (args.length === 1) {\n            check(arguments, number);\n\n            let count = args[0];\n            this.limit(0, count);\n        } else {\n            check(arguments, number, number);\n\n            let offset = args[0];\n            let count = args[1];\n\n            if (offset < 0) {\n                offset = 0;\n            }\n\n            if (count < 0) {\n                count = 0;\n            }\n\n            this.conditions['limit'] = {\n                [ConditionOp.LIMIT]: offset + ',' + count\n            };\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nclass NetworkError extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = 'NetworkError';\n    }\n}\n\nconst tls = require('tls');\nconst fs = require('fs');\nconst net = require('net');\nconst uuidv4 = require('uuid/v4');\nconst events = require('events');\n// const { NetworkError } = require('./exceptions').NetworkError;\n\nlet emitters = new Map();\nlet buffers = new Map();\nlet sockets = new Map();\nlet lastBytesRead = new Map();\n\n/**\n * Parse response returned by node\n * @param {Buffer} response Node's response\n */\nfunction parseResponse(response) {\n    let seq = response.slice(6, 38).toString();\n    let result = JSON.parse(response.slice(42).toString());\n    let emitter = emitters.get(seq);\n    if(!emitter) {\n        // Stale message received\n        return;\n    }\n    emitter = emitter.emitter;\n\n    if (emitter) {\n        let readOnly = Object.getOwnPropertyDescriptor(emitter, 'readOnly').value;\n        if (readOnly) {\n            if (result.error || result.result !== undefined ) {\n                emitter.emit('gotresult', result);\n            }\n        } else {\n            if (result.error || result.status || (result.result && result.result.status)) {\n                emitter.emit('gotresult', result);\n            } else {\n                if (!result.result) {\n                    throw new NetworkError(`unknown message receieved, seq=${seq}, data=${response.toString()}`);\n                }\n            }\n        }\n    } else {\n        throw new NetworkError(`unknown owner message receieved, seq=${seq}, data=${response.toString()}`);\n    }\n}\n\n/**\n * Create a new TLS socket\n * @param {String} ip IP of channel server\n * @param {Number} port Port of channel server\n * @param {Object} authentication A JSON object contains certificate file path, private key file path and CA file path\n * @return {TLSSocket} A new TLS socket\n */\nfunction createNewSocket(ip, port, authentication) {\n    let secureContextOptions = {\n        key: fs.readFileSync(authentication.key),\n        cert: fs.readFileSync(authentication.cert),\n        ca: fs.readFileSync(authentication.ca),\n        ecdhCurve: 'secp256k1',\n    };\n\n    let secureContext = tls.createSecureContext(secureContextOptions);\n\n    let socket = new net.Socket();\n    socket.connect(port, ip);\n\n    let clientOptions = {\n        rejectUnauthorized: false,\n        secureContext: secureContext,\n        socket: socket\n    };\n\n    let tlsSocket = tls.connect(clientOptions);\n\n    tlsSocket.on('error', function (error) {\n        throw new Error(error);\n    });\n    \n    let socketID = `${ip}:${port}`;\n    \n    lastBytesRead.set(socketID, 0);\n\n    tlsSocket.on('data', function (data) {\n        let response = null;\n        if (data instanceof Buffer) {\n            response = data;\n        }\n        else {\n            response = Buffer.from(data, 'ascii');\n        }\n\n        if (!buffers.has(socketID)) {\n            // First time to read data from this socket\n            let expectedLength = null;\n            if (tlsSocket.bytesRead - lastBytesRead.get(socketID) >= 4) {\n                expectedLength = response.readUIntBE(0, 4);\n            }\n\n            if (!expectedLength || tlsSocket.bytesRead < lastBytesRead.get(socketID) + expectedLength) {\n                buffers.set(socketID, {\n                    expectedLength: expectedLength,\n                    buffer: response\n                });\n            } else {\n                lastBytesRead.set(socketID, lastBytesRead.get(socketID) + expectedLength);\n                parseResponse(response);\n                buffers.delete(socketID);\n            }\n        } else {\n            // Multiple reading\n            let cache = buffers.get(socketID);\n            cache.buffer = Buffer.concat([cache.buffer, response]);\n            if (!cache.expectedLength && tlsSocket.bytesRead - lastBytesRead.get(socketID) >= 4) {\n                cache.expectedLength = cache.buffer.readUIntBE(0, 4);\n            }\n\n            if (cache.expectedLength && tlsSocket.bytesRead - lastBytesRead.get(socketID) >= cache.expectedLength) {\n                lastBytesRead.set(socketID, lastBytesRead.get(socketID) + cache.expectedLength);\n                parseResponse(buffers.get(socketID).buffer);\n                buffers.delete(socketID);\n            }\n        }\n    });\n\n    return tlsSocket;\n}\n\n/**\n * Prepare the data which will be sent to channel server\n * @param {String} data JSON string of load\n * @return {Object} UUID and packaged data\n */\nfunction packageData(data) {\n    const headerLength = 4 + 2 + 32 + 4;\n\n    let length = Buffer.alloc(4);\n    length.writeUInt32BE(headerLength + data.length);\n    let type = Buffer.alloc(2);\n    type.writeUInt16BE(0x12);\n    let uuid = uuidv4();\n    uuid = uuid.replace(/-/g, '');\n    let seq = Buffer.from(uuid, 'ascii');\n    let result = Buffer.alloc(4);\n    result.writeInt32BE(0);\n    let msg = Buffer.from(data, 'ascii');\n\n    return {\n        'uuid': uuid,\n        'packagedData': Buffer.concat([length, type, seq, result, msg])\n    };\n}\n\n/**\n * Clear context when a message got response or timeout\n * @param {Socket} socket The socket who sends the message\n */\nfunction clearContext(uuid) {\n    clearTimeout(emitters.get(uuid).timer);\n    emitters.delete(uuid);\n    buffers.delete(uuid);\n}\n\n/**\n * Return channel promise for a request\n * @param {Object} node A JSON object which contains IP and port configuration of channel server\n * @param {Object} authentication A JSON object contains certificate file path, private key file path and CA file path\n * @param {String} data JSON string of load\n * @param {Number} timeout Timeout to wait response\n * @return {Promise} a promise which will be resolved when the request is satisfied\n */\nfunction channelPromise(node, authentication, data, timeout, readOnly = false) {\n    let ip = node.ip;\n    let port = node.port;\n\n    let connectionID = `${ip}${port}`;\n    if (!sockets.has(connectionID)) {\n        let newSocket = createNewSocket(ip, port, authentication);\n        newSocket.unref();\n        sockets.set(connectionID, newSocket);\n    }\n    let tlsSocket = sockets.get(connectionID);\n\n    let dataPackage = packageData(JSON.stringify(data));\n    let uuid = dataPackage.uuid;\n\n    tlsSocket.socketID = uuid;\n    let packagedData = dataPackage.packagedData;\n    let channelPromise = new Promise(async (resolve, reject) => {\n        let eventEmitter = new events.EventEmitter();\n        Object.defineProperty(eventEmitter, \"readOnly\", {\n            value: readOnly,\n            writable: false,\n            configurable: false,\n            enumerable: false\n        });\n\n        eventEmitter.on('gotresult', (result) => {\n            clearContext(uuid);\n            if (result.error) {\n                reject(result);\n            } else {\n                resolve(result);\n            }\n            return; // This `return` is not necessary, but it may can avoid future trap\n        });\n\n        eventEmitter.on('timeout', () => {\n            clearContext(uuid);\n            reject({ 'error': 'timeout' });\n            return; // This `return` is not necessary, but it may can avoid future trap\n        });\n\n        emitters.set(uuid, {\n            emitter: eventEmitter,\n            timer: setTimeout(() => {\n                eventEmitter.emit('timeout');\n            }, timeout)\n        });\n\n        tlsSocket.write(packagedData);\n    });\n    return channelPromise;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\ntype RpcReq = (methodName: string, args: Array<any>) => any;\n\n/**\n * Information describing a cluster node\n *\n * @typedef {Object} NodeInfo\n * @property {string} pubkey Identity public key of the node\n * @property {string} gossip Gossip network address for the node\n * @property {string} tpu TPU network address for the node (null if not available)\n * @property {string|null} rpc JSON RPC network address for the node (null if not available)\n */\ntype NodeInfo = {\n  pubkey: string,\n  gossip: string,\n  tpu: string | null,\n  rpc: string | null,\n};\n\n/**\n * Information describing a vote account\n *\n * @typedef {Object} VoteAccountInfo\n * @property {string} votePubkey Public key of the vote account\n * @property {string} nodePubkey Identity public key of the node voting with this account\n * @property {string} stake The stake, in difs, delegated to this vote account\n * @property {string} commission A 32-bit integer used as a fraction (commission/0xFFFFFFFF) for rewards payout\n */\ntype VoteAccountInfo = {\n  votePubkey: string,\n  nodePubkey: string,\n  stake: number,\n  commission: number,\n};\n\nfunction createRpcReq(url): RpcReq {\n  const server = jayson(async (request, callback) => {\n    const options = {\n      method: 'POST',\n      body: request,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n\n    try {\n      const res = await fetch(url, options);\n      const text = await res.text();\n      callback(null, text);\n    } catch (err) {\n      callback(err);\n    }\n  });\n\n  return (method, args) => {\n    return new Promise((resolve, reject) => {\n      server.request(method, args, (err, response) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(response);\n      });\n    });\n  };\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\nclass ConfigurationError extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = 'ConfigurationError';\n    }\n}\n\nclass TransactionError extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = 'TransactionError';\n    }\n}\n\nclass PrecompiledError extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = 'PrecompiledError';\n    }\n}\n\nclass CompileError extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = 'CompileError';\n    }\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Expected JSON RPC response for the \"fetchAccountBalance\" message\n */\nconst FetchBalanceRpcResult = struct({\n  jsonrpc: struct.literal('2.0'),\n  id: 'string',\n  error: 'any?',\n  result: 'number?',\n});\n\nconst FetchReputationRpcResult = struct({\n  jsonrpc: struct.literal('2.0'),\n  id: 'string',\n  error: 'any?',\n  result: 'number?',\n});\n\n\n/**\n * @private\n */\nfunction jsonRpcResult(resultDescription: any) {\n  const jsonRpcVersion = struct.literal('2.0');\n  return struct.union([\n    struct({\n      jsonrpc: jsonRpcVersion,\n      id: 'string',\n      error: 'any',\n    }),\n    struct({\n      jsonrpc: jsonRpcVersion,\n      id: 'string',\n      error: 'null?',\n      result: resultDescription,\n    }),\n  ]);\n}\n\n/**\n * @private\n */\nconst AccountDetailResult = struct({\n  executable: 'boolean',\n  owner: 'array',\n  difs: 'number',\n  reputations: 'number',\n  data: 'array',\n});\n\n/**\n * Expected JSON RPC response for the \"fetchAccountDetail\" message\n */\nconst fetchAccountDetailRpcResult = jsonRpcResult(AccountDetailResult);\n\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */\nconst AccountNoticeResult = struct({\n  subscription: 'number',\n  result: AccountDetailResult,\n});\n\n/**\n * @private\n */\nconst ControllerAccountDetailResult = struct(['string', AccountDetailResult]);\n\n/***\n * Expected JSON RPC response for the \"controllerNotification\" message\n */\nconst ControllerAccountNoticeResult = struct({\n  subscription: 'number',\n  result: ControllerAccountDetailResult,\n});\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// const fs = require('fs');\nconst path = require('path');\nconst childProcess = require('child_process');\n// const assert = require('assert');\n// const events = require('events');\nconst abi = require('ethjs-abi');\n\nfunction selectNode(nodes) {\n    return nodes[Math.floor(Math.random() * nodes.length)];\n};\n\n\nfunction checkContractLength(bin) {\n    if (bin.length && bin.length <= 0x40000) {\n        return;\n    }\n    throw new CompileError(`contract bin size overflow, limit=0x40000(256K), size=${bin.length}`);\n}\n\nfunction checkContractError(errors) {\n    // Standard error types of solcjs\n    var solcErrors = [\n        'JSONError',\n        'IOError',\n        'ParserError',\n        'DocstringParsingError',\n        'SyntaxError',\n        'DeclarationError',\n        'TypeError',\n        'UnimplementedFeatureError',\n        'InternalCompilerError',\n        'Exception',\n        'CompilerError',\n        'FatalError'\n    ];\n\n    if (!errors) {\n        return;\n    } else {\n        let errorMsgs = [];\n        for (let error of errors) {\n            let [lineNo, level, msg] = error.split(': ');\n            if (solcErrors.includes(level)) {\n                errorMsgs.push(error);\n            }\n        }\n\n        if(errorMsgs.length !== 0) {\n            throw new CompileError(errorMsgs);\n        }\n        return;\n    }\n}\n\nfunction compileWithSolcJS(contractPath, outputDir) {\n    let contractName = path.basename(contractPath, '.sol');\n\n    let contractContent = fs.readFileSync(contractPath).toString();\n    let verReg = /pragma\\s+solidity\\s+\\^(.*)\\s*;/;\n    let ver = verReg.exec(contractContent)[1] || null;\n\n    let readCallback = (importContractName) => {\n        let importContractPath = path.join(path.dirname(contractPath), importContractName);\n        return { contents: fs.readFileSync(importContractPath).toString() };\n    };\n    let writeToFile = (abi, bin) => {\n        checkContractLength(bin);\n\n        if (typeof abi !== 'string') {\n            abi = JSON.stringify(abi);\n        }\n\n        if (typeof bin !== 'string') {\n            bin = JSON.stringify(bin);\n        }\n\n        let abiFileName = contractName + '.abi';\n        let binFileName = contractName + '.bin';\n\n        fs.writeFileSync(path.join(outputDir, abiFileName), abi);\n        fs.writeFileSync(path.join(outputDir, binFileName), bin);\n    };\n\n    let solc = null;\n    let output = null;\n    if (ver && ver.startsWith('0.5')) {\n        solc = require('./solc-0.5');\n        let input = {\n            language: \"Solidity\",\n            sources: {\n                [contractName]: {\n                    content: contractContent\n                }\n            },\n            settings: {\n                outputSelection: {\n                    '*': {\n                        '*': ['abi', 'evm.bytecode']\n                    }\n                }\n            }\n        };\n        output = JSON.parse(solc.compile(JSON.stringify(input), readCallback));\n        checkContractError(output.errors);\n\n        let abi = output.contracts[contractName][contractName].abi;\n        let bin = output.contracts[contractName][contractName].evm.bytecode.object;\n        writeToFile(abi, bin);\n    } else {\n        solc = require('./solc-0.4');\n        let input = {\n            sources: {\n                [contractName]: contractContent\n            }\n        };\n\n        output = solc.compile(input, 1, readCallback);\n        checkContractError(output.errors);\n\n        let abi = output.contracts[`${contractName}:${contractName}`].interface;\n        let bin = output.contracts[`${contractName}:${contractName}`].bytecode;\n        writeToFile(abi, bin);\n    }\n\n    return Promise.resolve();\n}\n\nfunction compileWithBin(outputDir, contractPath, solc) {\n    let execEmitter = new events.EventEmitter();\n    let execPromise = new Promise((resolve, reject) => {\n        execEmitter.on('done', () => {\n            resolve();\n        });\n        execEmitter.on('error', (stdout, stderr) => {\n            console.error(chalk.red(`Compiling error: ${stdout}\\n${stderr}`));\n            reject();\n        });\n    });\n\n    let cmd = `${solc} --overwrite --abi --bin -o ${outputDir} ${contractPath}`;\n    childProcess.exec(\n        cmd,\n        (error, stdout, stderr) => {\n            if (!error) {\n                execEmitter.emit('done');\n            }\n            else {\n                execEmitter.emit('error', stdout, stderr);\n            }\n        });\n\n    return execPromise.then(result => {\n        let contractName = path.basename(contractPath, '.sol');\n        let bin = fs.readFileSync(path.join(outputDir, contractName + '.bin'));\n        checkContractLength(bin);\n        return result;\n    });\n}\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Expected JSON RPC response for the \"confmTxn\" message\n */\nconst ConfmTxnRpcResult = jsonRpcResult('boolean');\n\n/**\n * Expected JSON RPC response for the \"fetchRoundLeader\" message\n */\nconst FetchRoundLeader = jsonRpcResult('string');\n\n/**\n * Expected JSON RPC response for the \"fetchClusterNodes\" message\n */\nconst GetClusterNodes = jsonRpcResult(\n  struct.list([\n    struct({\n      pubkey: 'string',\n      gossip: 'string',\n      tpu: struct.union(['null', 'string']),\n      rpc: struct.union(['null', 'string']),\n    }),\n  ]),\n);\n/**\n * @ignore\n */\nconst GetClusterNodes_015 = jsonRpcResult(\n  struct.list([\n    struct({\n      id: 'string',\n      gossip: 'string',\n      tpu: struct.union(['null', 'string']),\n      rpc: struct.union(['null', 'string']),\n    }),\n  ]),\n);\n\n/**\n * Expected JSON RPC response for the \"getEpochVoteAccounts\" message\n */\nconst GetEpochVoteAccounts = jsonRpcResult(\n  struct.list([\n    struct({\n      votePubkey: 'string',\n      nodePubkey: 'string',\n      stake: 'number',\n      commission: 'number',\n    }),\n  ]),\n);\n\n/**\n * Expected JSON RPC response for the \"fetchSignatureState\" message\n */\nconst FetchSignatureStateRpcResult = jsonRpcResult(\n  struct.union([\n    'null',\n    struct.union([struct({Ok: 'null'}), struct({Err: 'object'})]),\n  ]),\n);\n\n/**\n * Expected JSON RPC response for the \"fetchTxnAmount\" message\n */\nconst FetchTxnAmountRpcResult = jsonRpcResult('number');\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////\nclass StatusCode {\n    static getStatusMessage(status) {\n        let message = '';\n        switch (status) {\n            case this.Success:\n                message = 'success';\n                break;\n            case this.Unknown:\n                message = 'unknown';\n                break;\n            case this.BadRLP:\n                message = 'bad RLP';\n                break;\n            case this.InvalidFormat:\n                message = 'invalid format';\n                break;\n            case this.OutOfGasIntrinsic:\n                message = 'out of gas intrinsic';\n                break;\n            case this.InvalidSignature:\n                message = 'invalid signature';\n                break;\n            case this.InvalidNonce:\n                message = 'invalid nonce';\n                break;\n            case this.NotEnoughCash:\n                message = 'not enough cash';\n                break;\n            case this.OutOfGasBase:\n                message = 'out of gas base';\n                break;\n            case this.BlockGasLimitReached:\n                message = 'block gas limit reached';\n                break;\n            case this.BadInstruction:\n                message = 'bad instruction';\n                break;\n            case this.BadJumpDestination:\n                message = 'bad jump destination';\n                break;\n            case this.OutOfGas:\n                message = 'out of gas';\n                break;\n            case this.OutOfStack:\n                message = 'out of stack';\n                break;\n            case this.StackUnderflow:\n                message = 'stack underflow';\n                break;\n            case this.NonceCheckFail:\n                message = 'nonce check fail';\n                break;\n            case this.BlockLimitCheckFail:\n                message = 'block limit check fail';\n                break;\n            case this.FilterCheckFail:\n                message = 'filter check fail';\n                break;\n            case this.NoDeployPermission:\n                message = 'no deploy permission';\n                break;\n            case this.NoCallPermission:\n                message = 'no call permission';\n                break;\n            case this.NoTxPermission:\n                message = 'no tx permission';\n                break;\n            case this.PrecompiledError:\n                message = 'precompiled error';\n                break;\n            case this.RevertInstruction:\n                message = 'revert instruction';\n                break;\n            case this.InvalidZeroSignatureFormat:\n                message = 'invalid zero signature format';\n                break;\n            case this.AddressAlreadyUsed:\n                message = 'address already used';\n                break;\n            case this.PermissionDenied:\n                message = 'permission denied';\n                break;\n            case this.CallAddressError:\n                message = 'call address error';\n                break;\n            default:\n                message = `unknown status code:${status}`;\n                break;\n        }\n\n        return message;\n    }\n}\n\nStatusCode.Success = '0x0';\nStatusCode.Unknown = '0x1';\nStatusCode.BadRLP = '0x2';\nStatusCode.InvalidFormat = '0x3';\nStatusCode.OutOfGasIntrinsic = '0x4';\nStatusCode.InvalidSignature = '0x5';\nStatusCode.InvalidNonce = '0x6';\nStatusCode.NotEnoughCash = '0x7';\nStatusCode.OutOfGasBase = '0x8';\nStatusCode.BlockGasLimitReached = '0x9';\nStatusCode.BadInstruction = '0xa';\nStatusCode.BadJumpDestination = '0xb';\nStatusCode.OutOfGas = '0xc';\nStatusCode.OutOfStack = '0xd';\nStatusCode.StackUnderflow = '0xe';\nStatusCode.NonceCheckFail = '0xf';\nStatusCode.BlockLimitCheckFail = '0x10';\nStatusCode.FilterCheckFail = '0x11';\nStatusCode.NoDeployPermission = '0x12';\nStatusCode.NoCallPermission = '0x13';\nStatusCode.NoTxPermission = '0x14';\nStatusCode.PrecompiledError = '0x15';\nStatusCode.RevertInstruction = '0x16';\nStatusCode.InvalidZeroSignatureFormat = '0x17';\nStatusCode.AddressAlreadyUsed = '0x18';\nStatusCode.PermissionDenied = '0x19';\nStatusCode.CallAddressError = '0x1a';\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Expected JSON RPC response for the \"getTotalSupply\" message\n */\nconst GetTotalSupplyRpcResult = jsonRpcResult('number');\n\n/**\n * Expected JSON RPC response for the \"fetchRecentBlockhash\" message\n */\nconst FetchRecentBlockhash = jsonRpcResult([\n  'string',\n  struct({\n    difsPerSignature: 'number',\n    maxDifsPerSignature: 'number',\n    minDifsPerSignature: 'number',\n    targetDifsPerSignature: 'number',\n    targetSignaturesPerSlot: 'number',\n  }),\n]);\n/**\n * @ignore\n */\nconst GetRecentBlockhash_015 = jsonRpcResult([\n  'string',\n  struct({\n    difsPerSignature: 'number',\n  }),\n]);\n\n/**\n * Expected JSON RPC response for the \"reqDrone\" message\n */\nconst ReqDroneRpcResult = jsonRpcResult('string');\n\n/**\n * Expected JSON RPC response for the \"reqReputation\" message\n */\nconst ReqReputationRpcResult = jsonRpcResult('string');\n\n/**\n * Expected JSON RPC response for the \"sendTxn\" message\n */\nconst SendTxnRpcResult = jsonRpcResult('string');\n\n/**\n * Information describing an account\n *\n * @typedef {Object} AccountDetail\n * @property {number} difs Number of difs assigned to the account\n * @property {PubKey} owner Identifier of the controller that owns the account\n * @property {?Buffer} data Optional data assigned to the account\n * @property {boolean} executable `true` if this account's data contains a loaded controller\n */\ntype AccountDetail = {\n  executable: boolean,\n  owner: PubKey,\n  difs: number,\n  reputations: number,\n  data: Buffer,\n};\n\n/**\n * BusAccount information identified by pubkey\n *\n * @typedef {Object} KeyedAccountDetail\n * @property {PubKey} accountId\n * @property {AccountDetail} fetchAccountDetail\n */\ntype KeyedAccountDetail = {\n  accountId: PubKey,\n  fetchAccountDetail: AccountDetail,\n};\n\n/**\n * Callback function for account change notifications\n */\nexport type AccountChangeCallback = (fetchAccountDetail: AccountDetail) => void;\n\n/**\n * @private\n */\ntype AccountSubscriptionDetail = {\n  pubKey: string, // PubKey of the account as a base 58 string\n  callback: AccountChangeCallback,\n  subscriptionId: null | number, // null when there's no current server subscription id\n};\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\nconst secp256k1 = require('secp256k1');\n// const cryptoJSSha3 = require('crypto-js/sha3');\nconst keccak = require('keccak');\n// const assert = require('assert');\nconst rlp = require('rlp');\nconst coder = require('web3-eth-abi');\nconst ethjsUtil = require('ethjs-util');\nconst encryptType = 0;\n\n/**\n * Convert data to Buffer\n * @param {any} data data to be transformed to buffer\n * @return {Buffer} transformation result\n */\nfunction toBuffer(data) {\n    if (!Buffer.isBuffer(data)) {\n        if (Array.isArray(data)) {\n            data = Buffer.from(data);\n        } else if (typeof data === 'string') {\n            if (ethjsUtil.isHexPrefixed(data)) {\n                data = Buffer.from(ethjsUtil.padToEven(ethjsUtil.stripHexPrefix(data)), 'hex');\n            } else {\n                data = Buffer.from(data, 'hex');\n            }\n        } else if (Number.isInteger(data)) {\n            data = ethjsUtil.intToBuffer(data);\n        } else if (data === null || data === undefined) {\n            data = Buffer.allocUnsafe(0);\n        } else if (data.toArray) {\n            data = Buffer.from(data.toArray());\n        } else {\n            throw new Error('invalid type');\n        }\n    }\n    return data;\n}\n\n/**\n * Calculate hash of data\n * @param {any} data data\n * @param {int} bits length of hash\n * @return {Buffer} hash of data\n */\nfunction sha3(data, bits) {\n    if (encryptType === 0) {\n        data = toBuffer(data);\n        if (!bits) {\n            bits = 256;\n        }\n        let digestData = keccak('keccak' + bits).update(data).digest();\n        return digestData;\n    } else {\n        throw new Error('Unsupported type of encryption');\n    }\n}\n\n/**\n * Calculate public key from private key\n * @param {Buffer} privateKey A private key must be 256 bits wide\n * @return {Buffer} public key\n */\nfunction privateKeyToPublicKey(privateKey) {\n    if (encryptType === 0) {\n        privateKey = toBuffer(privateKey);\n        let publicKey = secp256k1.publicKeyCreate(privateKey, false).slice(1);\n        return publicKey;\n    } else {\n        throw new Error('Unsupported type of encryption');\n    }\n}\n\n/**\n * Calculate address from public key\n * @param {Buffer} publicKey public key\n * @param {bool} sanitize whether to sanitize publicKey\n * @return {Buffer} address\n */\nfunction publicKeyToAddress(publicKey, sanitize = false) {\n    if (encryptType === 0) {\n        if (sanitize && (publicKey.length !== 64)) {\n            publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\n        }\n        assert(publicKey.length === 64);\n    }\n    // Only take the lower 160bits of the hash as address\n    return sha3(publicKey).slice(-20);\n}\n\n/**\n * Calculate address from private key\n * @param {Buffer} privateKey private key\n * @return {Buffer} address\n */\nfunction privateKeyToAddress(privateKey) {\n    return publicKeyToAddress(privateKeyToPublicKey(privateKey));\n}\n\n/**\n * Allocate a zero-filled buffer\n * @param {Number} length the length of buffer\n * @return {Buffer} buffer\n */\nfunction zeros(length) {\n    return Buffer.allocUnsafe(length).fill(0);\n}\n\nfunction setLength(msg, length, right) {\n    let buf = zeros(length);\n    msg = toBuffer(msg);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    } else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n}\n\n/**\n * Recover public key from (v, r, s)\n * @param {String} msgHash message hash\n * @param {String} v v\n * @param {String} r r\n * @param {String} s s\n * @return {String} public key recovered from (v, r, s)\n */\nfunction ecrecover(msgHash, v, r, s) {\n    let signature = Buffer.concat([setLength(r, 32), setLength(s, 32)], 64);\n    let recovery = v - 27;\n    if (recovery !== 0 && recovery !== 1) {\n        throw new Error('Invalid signature v value');\n    }\n    let senderPubickKey = secp256k1.recover(msgHash, signature, recovery);\n    return secp256k1.publicKeyConvert(senderPubickKey, false).slice(1);\n}\n\n/**\n * Create sign data\n * @param {String} msgHash message hash\n * @param {String} privateKey private key\n * @return {Object} returns (v, r, s) for secp256k1\n */\nfunction ecsign(msgHash, privateKey) {\n    let ret = {};\n    if (encryptType === 0) {\n        let sig = secp256k1.sign(msgHash, privateKey);\n        ret.r = sig.signature.slice(0, 32);\n        ret.s = sig.signature.slice(32, 64);\n        ret.v = sig.recovery + 27;\n    } else {\n        throw new Error('Unsupported type of encryption');\n    }\n    return ret;\n}\n\n/**\n * Calcuate hash of RLP data\n * @param {rlp} data RLP data\n * @return {String} the hash of data\n */\nfunction rlphash(data) {\n    return sha3(rlp.encode(data));\n}\n\n/**\n * encode params\n * @param {Array} types types\n * @param {Array} params params\n * @return {Buffer} params' code\n */\nfunction encodeParams(types, params) {\n    let ret = coder.encodeParameters(types, params);\n    return ret;\n}\n\n/**\n * decode params\n * @param {Array} types types\n * @param {Buffer} bytes params' code\n * @return {Array} params\n */\nfunction decodeParams(types, bytes) {\n    let ret = coder.decodeParameters(types, bytes);\n    return ret;\n}\n\n/**\n * encode function name\n * @param {String} fcn function name\n * @return {Buffer} function name's code\n */\nfunction encodeFunctionName(fcn) {\n    let digest = null;\n    if (encryptType === 1) {\n        digest = sha3(fcn, 256).toString('hex');\n    } else {\n    //     digest = cryptoJSSha3(fcn, {\n    //         outputLength: 256\n    //     }).toString();\n    }\n    let ret = '0x' + digest.slice(0, 8);\n    return ret;\n}\n\n/**\n * encode transaction data\n * @param {String} fcn function name\n * @param {Array} types types\n * @param {Array} params params\n * @return {Buffer} tx data's code\n */\nfunction encodeTxData(fcn, types, params) {\n    let txDataCode = encodeFunctionName(fcn);\n    let paramsCode = encodeParams(types, params);\n    txDataCode += ethjsUtil.stripHexPrefix(paramsCode);\n    return txDataCode;\n}\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Callback function for controller account change notifications\n */\nexport type ControllerAccountChangeCallback = (\n  keyedAccountInfo: KeyedAccountDetail,\n) => void;\n\n/**\n * @private\n */\ntype ControllerAccountSubscriptionDetail = {\n  controllerId: string, // PubKey of the controller as a base 58 string\n  callback: ControllerAccountChangeCallback,\n  subscriptionId: null | number, // null when there's no current server subscription id\n};\n\n/**\n * Signature status: Success\n *\n * @typedef {Object} SignaturePass\n */\nexport type SignaturePass = {|\n  Ok: null,\n|};\n\n/**\n * Signature status: TxnErr\n *\n * @typedef {Object} TxnErr\n */\nexport type TxnErr = {|\n  Err: Object,\n|};\n\n/**\n * @ignore\n */\ntype BlockhashAndFeeCalculator = [Blockhash, FeeCalculator]; // This type exists to workaround an esdoc parse error\n\n/**\n * A connection to a fullnode JSON RPC endpoint\n */\nexport class Connection {\n  _rpcReq: RpcReq;\n  _rpcWebSock: RpcWebSocketClient;\n  _rpcWebSockConnected: boolean = false;\n\n  _blockhashInfo: {\n    recentPackagehash: Blockhash | null,\n    seconds: number,\n    transactionSignatures: Array<string>,\n  };\n  _disableBlockhashCaching: boolean = false;\n  _accountChangeSubscriptions: {[number]: AccountSubscriptionDetail} = {};\n  _accountChangeSubscriptionCounter: number = 0;\n  _controllerAccountChangeSubscriptions: {\n    [number]: ControllerAccountSubscriptionDetail,\n  } = {};\n  _controllerAccountChangeSubscriptionCounter: number = 0;\n\n  /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   */\n  constructor(endpoint: string) {\n    let url = urlParse(endpoint);\n\n    this._rpcReq = createRpcReq(url.href);\n    this._blockhashInfo = {\n      recentPackagehash: null,\n      seconds: -1,\n      transactionSignatures: [],\n    };\n\n    url.protocol = url.protocol === 'https:' ? 'wss:' : 'ws:';\n    url.host = '';\n    url.port = String(Number(url.port) + 1);\n    if (url.port === '1') {\n      url.port = url.protocol === 'wss:' ? '8901' : '8900';\n    }\n    this._rpcWebSock = new RpcWebSocketClient(urlFormat(url), {\n      autoconnect: false,\n      max_reconnects: Infinity,\n    });\n    this._rpcWebSock.on('open', this._wsOnOpen.bind(this));\n    this._rpcWebSock.on('error', this._wsOnErr.bind(this));\n    this._rpcWebSock.on('close', this._wsOnClose.bind(this));\n    this._rpcWebSock.on(\n      'accountNotification',\n      this._wsOnAccountNotice.bind(this),\n    );\n    this._rpcWebSock.on(\n      'controllerNotification',\n      this._wsOnProgramAccountNotification.bind(this),\n    );\n  }\n\n  /**\n   * Fetch the balance for the specified public key\n   */\n  async fetchAccountBalance(pubKey: PubKey): Promise<number> {\n    const unsafeRes = await this._rpcReq('getDif', [\n      pubKey.toBase58(),\n    ]);\n    const res = FetchBalanceRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  async fetchAccountReputation(pubKey: PubKey): Promise<number> {\n    const unsafeRes = await this._rpcReq('getReputation', [\n      pubKey.toBase58(),\n    ]);\n    const res = FetchReputationRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Fetch all the account info for the specified public key\n   */\n  async fetchAccountDetail(pubKey: PubKey): Promise<AccountDetail> {\n    const unsafeRes = await this._rpcReq('getAccountInfo', [\n      pubKey.toBase58(),\n    ]);\n    const res = fetchAccountDetailRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n\n    const {result} = res;\n    assert(typeof result !== 'undefined');\n\n    return {\n      executable: result.executable,\n      owner: new PubKey(result.owner),\n      difs: result.difs,\n      reputations: result.reputations,\n      data: Buffer.from(result.data),\n    };\n  }\n\n  /**\n   * Confirm the transaction identified by the specified signature\n   */\n  async confmTxn(signature: TxnSignature): Promise<boolean> {\n    const unsafeRes = await this._rpcReq('confirmTxn', [signature]);\n    const res = ConfmTxnRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Return the list of nodes that are currently participating in the cluster\n   */\n  async fetchClusterNodes(): Promise<Array<NodeInfo>> {\n    const unsafeRes = await this._rpcReq('getClusterNodes', []);\n\n    // Legacy v0.15 response.  TODO: Remove in August 2019\n    try {\n      const res_015 = GetClusterNodes_015(unsafeRes);\n      if (res_015.error) {\n        console.log('no', res_015.error);\n        throw new Error(res_015.error.message);\n      }\n      return res_015.result.map(node => {\n        node.pubkey = node.id;\n        node.id = undefined;\n        return node;\n      });\n    } catch (e) {\n      // Not legacy format\n    }\n    // End Legacy v0.15 response\n\n    const res = GetClusterNodes(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Return the list of nodes that are currently participating in the cluster\n   */\n  async getEpochVoteAccounts(): Promise<Array<VoteAccountInfo>> {\n    const unsafeRes = await this._rpcReq('getEpochVoteAccounts', []);\n    const res = GetEpochVoteAccounts(unsafeRes);\n    //const res = unsafeRes;\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Fetch the current slot leader of the cluster\n   */\n  async fetchRoundLeader(): Promise<string> {\n    const unsafeRes = await this._rpcReq('getRoundLeader', []);\n    const res = FetchRoundLeader(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Fetch the current transaction count of the cluster\n   */\n  async fetchSignatureState(\n    signature: TxnSignature,\n  ): Promise<SignaturePass | TxnErr | null> {\n    const unsafeRes = await this._rpcReq('getSignatureState', [signature]);\n    const res = FetchSignatureStateRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Fetch the current transaction count of the cluster\n   */\n  async fetchTxnAmount(): Promise<number> {\n    const unsafeRes = await this._rpcReq('getTxnCnt', []);\n    const res = FetchTxnAmountRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return Number(res.result);\n  }\n\n  /**\n   * Fetch the current total currency supply of the cluster\n   */\n  async getTotalSupply(): Promise<number> {\n    const unsafeRes = await this._rpcReq('getTotalSupply', []);\n    const res = GetTotalSupplyRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return Number(res.result);\n  }\n\n  /**\n   * Fetch a recent blockhash from the cluster\n   */\n  async fetchRecentBlockhash(): Promise<BlockhashAndFeeCalculator> {\n    // const unsafeRes = await this._rpcReq('getLatestBlockhash', []);\n    const unsafeRes = await this._rpcReq('getLatestTransactionSeal', []);\n\n    // Legacy v0.15 response.  TODO: Remove in August 2019\n    try {\n      const res_015 = GetRecentBlockhash_015(unsafeRes);\n      if (res_015.error) {\n        throw new Error(res_015.error.message);\n      }\n      const [blockhash, feeCalculator] = res_015.result;\n      feeCalculator.targetSignaturesPerSlot = 42;\n      feeCalculator.targetDifsPerSignature =\n        feeCalculator.difsPerSignature;\n\n      return [blockhash, feeCalculator];\n    } catch (e) {\n      // Not legacy format\n    }\n    // End Legacy v0.15 response\n\n    const res = FetchRecentBlockhash(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Request an allocation of difs to the specified account\n   */\n  async reqDrone(\n    to: PubKey,\n    amount: number,\n  ): Promise<TxnSignature> {\n    const unsafeRes = await this._rpcReq('requestDif', [\n      to.toBase58(),\n      amount,\n    ]);\n    const res = ReqDroneRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n    /**\n   * Request an allocation of reputations to the specified account\n   */\n  async reqReputation(\n    to: PubKey,\n    amount: number,\n  ): Promise<TxnSignature> {\n    const unsafeRes = await this._rpcReq('requestReputation', [\n      to.toBase58(),\n      amount,\n    ]);\n    const res = ReqReputationRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Sign and send a transaction\n   */\n  async sendTxn(\n    transaction: Transaction,\n    ...signers: Array<BusAccount>\n  ): Promise<TxnSignature> {\n    for (;;) {\n      // Attempt to use a recent blockhash for up to 30 seconds\n      const seconds = new Date().getSeconds();\n      if (\n        this._blockhashInfo.recentPackagehash != null &&\n        this._blockhashInfo.seconds < seconds + 30\n      ) {\n        transaction.recentPackagehash = this._blockhashInfo.recentPackagehash;\n        transaction.sign(...signers);\n        if (!transaction.signature) {\n          throw new Error('!signature'); // should never happen\n        }\n\n        // If the signature of this transaction has not been seen before with the\n        // current recentPackagehash, all done.\n        const signature = transaction.signature.toString();\n        if (!this._blockhashInfo.transactionSignatures.includes(signature)) {\n          this._blockhashInfo.transactionSignatures.push(signature);\n          if (this._disableBlockhashCaching) {\n            this._blockhashInfo.seconds = -1;\n          }\n          break;\n        }\n      }\n\n      // Fetch a new blockhash\n      let attempts = 0;\n      const startTime = Date.now();\n      for (;;) {\n        const [\n          recentPackagehash,\n          //feeCalculator,\n        ] = await this.fetchRecentBlockhash();\n\n        if (this._blockhashInfo.recentPackagehash != recentPackagehash) {\n          this._blockhashInfo = {\n            recentPackagehash,\n            seconds: new Date().getSeconds(),\n            transactionSignatures: [],\n          };\n          break;\n        }\n        if (attempts === 50) {\n          throw new Error(\n            `Unable to obtain a new blockhash after ${Date.now() -\n              startTime}ms`,\n          );\n        }\n\n        // dormant for approximately half a slot\n        await dormant((500 * DEFAULT_TICKS_PER_SLOT) / NUM_TICKS_PER_SEC);\n\n        ++attempts;\n      }\n    }\n\n    const wireTransaction = transaction.serialize();\n    return await this.sendNativeTxn(wireTransaction);\n  }\n\n  /**\n   * @private\n   */\n  async fullnodeExit(): Promise<boolean> {\n    const unsafeRes = await this._rpcReq('fullnodeQuit', []);\n    const res = jsonRpcResult('boolean')(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Send a transaction that has already been signed and serialized into the\n   * wire format\n   */\n  async sendNativeTxn(\n    rawTransaction: Buffer,\n  ): Promise<TxnSignature> {\n    const unsafeRes = await this._rpcReq('sendTxn', [\n      [...rawTransaction],\n    ]);\n    const res = SendTxnRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    assert(res.result);\n    return res.result;\n  }\n\n  /**\n   * @private\n   */\n  _wsOnOpen() {\n    this._rpcWebSockConnected = true;\n    this._updateSubscriptions();\n  }\n\n  /**\n   * @private\n   */\n  _wsOnErr(err: Error) {\n    console.log('ws error:', err.message);\n  }\n\n  /**\n   * @private\n   */\n  _wsOnClose(code: number, message: string) {\n    // 1000 means _rpcWebSock.close() was called explicitly\n    if (code !== 1000) {\n      console.log('ws close:', code, message);\n    }\n    this._rpcWebSockConnected = false;\n  }\n\n  /**\n   * @private\n   */\n  async _updateSubscriptions() {\n    const accountKeys = Object.keys(this._accountChangeSubscriptions).map(\n      Number,\n    );\n    const programKeys = Object.keys(\n      this._controllerAccountChangeSubscriptions,\n    ).map(Number);\n    if (accountKeys.length === 0 && programKeys.length === 0) {\n      this._rpcWebSock.close();\n      return;\n    }\n\n    if (!this._rpcWebSockConnected) {\n      for (let id of accountKeys) {\n        this._accountChangeSubscriptions[id].subscriptionId = null;\n      }\n      for (let id of programKeys) {\n        this._controllerAccountChangeSubscriptions[id].subscriptionId = null;\n      }\n      this._rpcWebSock.connect();\n      return;\n    }\n\n    for (let id of accountKeys) {\n      const {subscriptionId, pubKey} = this._accountChangeSubscriptions[id];\n      if (subscriptionId === null) {\n        try {\n          this._accountChangeSubscriptions[\n            id\n          ].subscriptionId = await this._rpcWebSock.call('accountSubscribe', [\n            pubKey,\n          ]);\n        } catch (err) {\n          console.log(\n            `accountSubscribe error for ${pubKey}: ${err.message}`,\n          );\n        }\n      }\n    }\n    for (let id of programKeys) {\n      const {\n        subscriptionId,\n        controllerId,\n      } = this._controllerAccountChangeSubscriptions[id];\n      if (subscriptionId === null) {\n        try {\n          this._controllerAccountChangeSubscriptions[\n            id\n          ].subscriptionId = await this._rpcWebSock.call('programSubscribe', [\n            controllerId,\n          ]);\n        } catch (err) {\n          console.log(\n            `programSubscribe error for ${controllerId}: ${err.message}`,\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  _wsOnAccountNotice(notification: Object) {\n    const res = AccountNoticeResult(notification);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n\n    const keys = Object.keys(this._accountChangeSubscriptions).map(Number);\n    for (let id of keys) {\n      const sub = this._accountChangeSubscriptions[id];\n      if (sub.subscriptionId === res.subscription) {\n        const {result} = res;\n        assert(typeof result !== 'undefined');\n\n        sub.callback({\n          executable: result.executable,\n          owner: new PubKey(result.owner),\n          difs: result.difs,\n          reputations: result.reputations,\n          data: Buffer.from(result.data),\n        });\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Register a callback to be invoked whenever the specified account changes\n   *\n   * @param publickey Public key of the account to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @return subscription id\n   */\n  onAccountChange(\n    pubKey: PubKey,\n    callback: AccountChangeCallback,\n  ): number {\n    const id = ++this._accountChangeSubscriptionCounter;\n    this._accountChangeSubscriptions[id] = {\n      pubKey: pubKey.toBase58(),\n      callback,\n      subscriptionId: null,\n    };\n    this._updateSubscriptions();\n    return id;\n  }\n\n  /**\n   * Deregister an account notification callback\n   *\n   * @param id subscription id to deregister\n   */\n  async removeListenerOfAccountChange(id: number): Promise<void> {\n    if (this._accountChangeSubscriptions[id]) {\n      const {subscriptionId} = this._accountChangeSubscriptions[id];\n      delete this._accountChangeSubscriptions[id];\n      if (subscriptionId !== null) {\n        try {\n          await this._rpcWebSock.call('accountUnsubscribe', [subscriptionId]);\n        } catch (err) {\n          console.log('accountUnsubscribe error:', err.message);\n        }\n      }\n      this._updateSubscriptions();\n    } else {\n      throw new Error(`Unknown account change id: ${id}`);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _wsOnProgramAccountNotification(notification: Object) {\n    const res = ControllerAccountNoticeResult(notification);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n\n    const keys = Object.keys(this._controllerAccountChangeSubscriptions).map(\n      Number,\n    );\n    for (let id of keys) {\n      const sub = this._controllerAccountChangeSubscriptions[id];\n      if (sub.subscriptionId === res.subscription) {\n        const {result} = res;\n        assert(typeof result !== 'undefined');\n\n        sub.callback({\n          accountId: result[0],\n          fetchAccountDetail: {\n            executable: result[1].executable,\n            owner: new PubKey(result[1].owner),\n            difs: result[1].difs,\n            reputations: result[1].reputations,\n            data: Buffer.from(result[1].data),\n          },\n        });\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Register a callback to be invoked whenever accounts owned by the\n   * specified controller change\n   *\n   * @param controllerId Public key of the controller to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @return subscription id\n   */\n  onControllerAccountChange(\n    controllerId: PubKey,\n    callback: ControllerAccountChangeCallback,\n  ): number {\n    const id = ++this._controllerAccountChangeSubscriptionCounter;\n    this._controllerAccountChangeSubscriptions[id] = {\n      controllerId: controllerId.toBase58(),\n      callback,\n      subscriptionId: null,\n    };\n    this._updateSubscriptions();\n    return id;\n  }\n\n  /**\n   * Deregister an account notification callback\n   *\n   * @param id subscription id to deregister\n   */\n  async removeControllerAccountChangeListener(id: number): Promise<void> {\n    if (this._controllerAccountChangeSubscriptions[id]) {\n      const {subscriptionId} = this._controllerAccountChangeSubscriptions[id];\n      delete this._controllerAccountChangeSubscriptions[id];\n      if (subscriptionId !== null) {\n        try {\n          await this._rpcWebSock.call('programUnsubscribe', [subscriptionId]);\n        } catch (err) {\n          console.log('programUnsubscribe error:', err.message);\n        }\n      }\n      this._updateSubscriptions();\n    } else {\n      throw new Error(`Unknown account change id: ${id}`);\n    }\n  }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// let utils = require('./utils');\n// const encryptType = 2;\n// const ethjsUtil = require('ethereumjs-util');\nconst BN = ethjsUtil.BN;\n\n/**\n * Constructor of transaction\n * @param {data} data transaction data\n */\n// function Transaction(data) {\n//     data = data || {};\n//     let fields = null;\n\n//     if (encryptType === 1) {\n//         fields = [{\n//             name: 'randomid',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'gasPrice',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'gasLimit',\n//             alias: 'gas',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'blockLimit',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'to',\n//             allowZero: true,\n//             length: 20,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'value',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'data',\n//             alias: 'input',\n//             allowZero: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'pub',\n//             length: 64,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'r',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 's',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }];\n//     } else {\n//         fields = [{\n//             name: 'randomid',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'gasPrice',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'gasLimit',\n//             alias: 'gas',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'blockLimit',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'to',\n//             allowZero: true,\n//             length: 20,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'value',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'data',\n//             alias: 'input',\n//             allowZero: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'chainId',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'groupId',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'extraData',\n//             allowZero: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 'v',\n//             length: 1,\n//             default: Buffer.from([0x1c])\n//         }, {\n//             name: 'r',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }, {\n//             name: 's',\n//             length: 32,\n//             allowLess: true,\n//             default: Buffer.from([])\n//         }];\n//     }\n\n//     ethjsUtil.defineProperties(this, fields, data);\n\n//     /*\n//     Object.defineProperty(this, 'from', {\n//         enumerable: true,\n//         configurable: true,\n//         get: this.getSenderAddress.bind(this)\n//     });\n//     */\n\n//     let sigV = ethjsUtil.bufferToInt(this.v);\n//     let chainId = Math.floor((sigV - 35) / 2);\n//     if (chainId < 0) {\n//         chainId = 0;\n//     }\n\n//     this._chainId = chainId || data.chainId || 0;\n//     this._homestead = true;\n// }\n\n/**\n * If the tx's `to` is to the creation address\n * @return {Boolean} returns `true` if tx is to to the creation address, otherwise returns `false`\n */\nfunction toCreationAddress() {\n    return this.to.toString('hex') === '';\n}\n\n/**\n * Computes a sha3-256 hash of the serialized tx\n * @param {Boolean} [includeSignature=true] whether or not to inculde the signature\n * @return {Buffer} a sha3-256 hash of the serialized tx\n */\nfunction hash(includeSignature) {\n    if (includeSignature === undefined) {\n        includeSignature = true;\n    }\n    // backup original signature\n    const rawCopy = this.raw.slice(0);\n\n    // generate rlp params for hash\n    let txRawForHash = includeSignature ? this.raw : this.raw.slice(0, this.raw.length - 3);\n    //var txRawForHash = includeSignature ? this.raw : this.raw.slice(0, 7)\n\n    // restore original signature\n    this.raw = rawCopy.slice();\n\n    // create hash\n    return rlphash(txRawForHash);\n}\n\n/**\n * returns the chain ID\n * @return {Number} chain ID\n */\nfunction getChainId() {\n    return this._chainId;\n}\n\n/**\n * returns the sender's address\n * @return {Buffer} sender's address\n */\nfunction getSenderAddress() {\n    if (this._from) {\n        return this._from;\n    }\n    const pubkey = this.getSenderPublicKey();\n    this._from = ethjsUtil.publicToAddress(pubkey);\n    return this._from;\n}\n\n/**\n * returns the public key of the sender\n * @return {Buffer} the public key of the sender\n */\nfunction getSenderPublicKey() {\n    if (!this._senderPubKey || !this._senderPubKey.length) {\n        if (!this.verifySignature()) {\n            throw new Error('Invalid Signature');\n        }\n    }\n    return this._senderPubKey;\n}\n\n/**\n * Determines if the signature is valid\n * @return {Boolean} whether the signature is valid\n */\nfunction verifySignature() {\n    let SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);\n    const msgHash = this.hash(false);\n    // All transaction signatures whose s-value is greater than secp256k1n/2 are considered invalid.\n    if (this._homestead && new BN(this.s).cmp(SECP256K1_N_DIV_2) === 1) {\n        return false;\n    }\n\n    try {\n        let v = ethjsUtil.bufferToInt(this.v);\n        this._senderPubKey = ecrecover(msgHash, v, this.r, this.s);\n    } catch (e) {\n        console.error(e.stack);\n        return false;\n    }\n\n    return !!this._senderPubKey;\n}\n\n/**\n * sign a transaction with a given private key\n * @param {Buffer} privateKey private key\n */\nfunction sign(privateKey) {\n    const msgHash = this.hash(false);\n    const sig = ecsign(msgHash, privateKey);\n    Object.assign(this, sig);\n}\n\n/**\n * the up front amount that an account must have for this transaction to be valid\n * @return {BN} up front amount\n */\nfunction getUpfrontCost() {\n    return new BN(this.gasLimit)\n        .imul(new BN(this.gasPrice))\n        .iadd(new BN(this.value));\n}\n\n/**\n * validates the signature and checks to see if it has enough gas\n * @param {Boolean} [stringError=false] whether to return a string with a dscription of why the validation failed or return a Bloolean\n * @return {Boolean|String} validation result\n */\nfunction validate(stringError) {\n    const errors = [];\n    if (!this.verifySignature()) {\n        errors.push('Invalid Signature');\n    }\n\n    if (this.getBaseFee().cmp(new BN(this.gasLimit)) > 0) {\n        errors.push([`gas limit is to low. Need at least ${this.getBaseFee()}`]);\n    }\n\n    if (stringError === undefined || stringError === false) {\n        return errors.length === 0;\n    } else {\n        return errors.join(' ');\n    }\n}\n////////////////////////////////////////////////////////////////////////////////////////////////////////////","var _ = require('underscore');\n\n// Don't use this constructor, use the type factory functions:\n//    list(), literal(), reference(), encrypted()\nfunction RpcParameter(value, type, attributes) {\n    if (!(this instanceof RpcParameter)) {\n        return new RpcParameter(value, type, attributes);\n    }\n\n    this.value = value;\n    this.type = type;\n\n    this.attributes = {};\n\n    if (!_.isUndefined(attributes) && !_.isNull(attributes)) {\n        this.attributes = attributes;\n    }\n}\n\nRpcParameter.list = function(param) {\n    return new RpcParameter(param, 'list');\n};\n\nRpcParameter.literal = function(param) {\n    return new RpcParameter(param, 'literal');\n};\n\nRpcParameter.encrypted = function(param, assocIndex, idIndex) {\n    return new RpcParameter(param, 'encrypted', {\n        assocIndex: assocIndex,\n        idIndex: idIndex\n    });\n};\n\nRpcParameter.reference = function(param) {\n    return new RpcParameter(param, 'reference');\n};\n\nRpcParameter.isRpcParameter = function(param) {\n    return !_.isUndefined(param) && !_.isNull(param) && param instanceof RpcParameter;\n};\n\nmodule.exports.RpcParameter = RpcParameter;","var _ = require('underscore');\nvar RpcParameter = require('./rpc-parameter').RpcParameter;\n\nfunction RpcCall(rpcName, params) {\n    if (!(this instanceof RpcCall)) {\n        return new RpcCall(rpcName, params);\n    }\n\n    this.rpcName = rpcName;\n    this.params = params || [];\n}\n\n\n/*\nVariadic:\ncreate(rpcName)\ncreate(rpcName, processor)\ncreate(rpcName, params...)\ncreate(rpcName, [params...])\ncreate(rpcCall)\nAdditionally, this function takes the form of a single\narray argument with the array containing some combination\nof the parameters described above in the variadic forms.\n*/\nRpcCall.create = function create(rpcName, params) {\n    if (arguments.length === 0 || !_.isArray(arguments[0])) {\n        return create(_.toArray(arguments));\n    }\n\n    var args = arguments[0];\n\n    if (args.length < 1 || _.isEmpty(args[0])) {\n        return;\n    }\n\n    if (RpcCall.isRpcCall(args[0])) {\n        return args[0];\n    }\n\n    rpcName = args[0];\n\n    if (args.length < 2) {\n        return new RpcCall(rpcName);\n    }\n\n    params = processParamList(_.rest(args));\n\n    return new RpcCall(rpcName, params);\n};\n\n\nRpcCall.isRpcCall = function isRpcCall(param) {\n    return !_.isEmpty(param) && param instanceof RpcCall;\n};\n\n\nfunction flattenAndRemoveNullishValues(paramList) {\n    if (_.isUndefined(paramList) || _.isNull(paramList)) {\n        return [];\n    }\n\n    if (!_.isArray(paramList)) {\n        return [paramList];\n    }\n\n    return _.filter(_.flatten(paramList), function(value) {\n        return !_.isUndefined(value) && !_.isNull(value);\n    });\n}\n\n\nfunction processParamList(paramList) {\n    if (_.isUndefined(paramList) || _.isNull(paramList)) {\n        return [];\n    }\n\n    var convertedParams = flattenAndRemoveNullishValues(paramList);\n\n    return _.map(convertedParams, function(param) {\n        if (RpcParameter.isRpcParameter(param)) {\n            return param;\n        }\n\n        var stringParam = param;\n        if (_.isNumber(param)) {\n            stringParam = String(param);\n        }\n\n        if (_.isString(stringParam)) {\n            return RpcParameter.literal(stringParam);\n        }\n\n        return RpcParameter.list(param);\n    });\n}\n\nmodule.exports.RpcCall = RpcCall;\nRpcCall._flattenAndRemoveNullishValues = flattenAndRemoveNullishValues;\nRpcCall._processParamList = processParamList;","// @flow\n\nimport invariant from 'assert';\n\nimport {Connection} from '../netutility';\nimport {Transaction} from '../tx-dapp';\nimport {dormant} from './dormant';\nimport type {BusAccount} from '../bvm-acct';\nimport type {TxnSignature} from '../tx-dapp';\nimport {DEFAULT_TICKS_PER_SLOT, NUM_TICKS_PER_SEC} from '../timing';\n\nvar util = require('util');\nvar _ = require('underscore');\nvar _str = require('underscore.string');\n\n// var RpcCall = require('../rpc-call').RpcCall;\nimport RpcCall from '../rpc-call';\nimport { stat } from 'fs';\n\nvar _ = require('underscore');\nvar _str = require('underscore.string');\nvar Socket = require('net').Socket;\nvar format = require('util').format;\n\n\nvar PREFIX = '[XWB]';\nvar RPC_VERSION = '1.108';\n\nvar NUL = '\\u0000';\nvar SOH = '\\u0001';\nvar EOT = '\\u0004';\nvar ENQ = '\\u0005';\n\nvar CIPHER_PAD = [\n    'wkEo-ZJt!dG)49K{nX1BS$vH<&:Myf*>Ae0jQW=;|#PsO`\\'%+rmb[gpqN,l6/hFC@DcUa ]z~R}\"V\\\\iIxu?872.(TYL5_3',\n    'rKv`R;M/9BqAF%&tSs#Vh)dO1DZP> *fX\\'u[.4lY=-mg_ci802N7LTG<]!CWo:3?{+,5Q}(@jaExn$~p\\\\IyHwzU\"|k6Jeb',\n    '\\\\pV(ZJk\"WQmCn!Y,y@1d+~8s?[lNMxgHEt=uw|X:qSLjAI*}6zoF{T3#;ca)/h5%`P4$r]G\\'9e2if_>UDKb7<v0&- RBO.',\n    'depjt3g4W)qD0V~NJar\\\\B \"?OYhcu[<Ms%Z`RIL_6:]AX-zG.#}$@vk7/5x&*m;(yb2Fn+l\\'PwUof1K{9,|EQi>H=CT8S!',\n    'NZW:1}K$byP;jk)7\\'`x90B|cq@iSsEnu,(l-hf.&Y_?J#R]+voQXU8mrV[!p4tg~OMez CAaGFD6H53%L/dT2<*>\"{\\\\wI=',\n    'vCiJ<oZ9|phXVNn)m K`t/SI%]A5qOWe\\\\&?;jT~M!fz1l>[D_0xR32c*4.P\"G{r7}E8wUgyudF+6-:B=$(sY,LkbHa#\\'@Q',\n    'hvMX,\\'4Ty;[a8/{6l~F_V\"}qLI\\\\!@x(D7bRmUH]W15J%N0BYPkrs&9:$)Zj>u|zwQ=ieC-oGA.#?tfdcO3gp`S+En K2*<',\n    'jd!W5[];4\\'<C$/&x|rZ(k{>?ghBzIFN}fAK\"#`p_TqtD*1E37XGVs@0nmSe+Y6Qyo-aUu%i8c=H2vJ\\\\) R:MLb.9,wlO~P',\n    '2ThtjEM+!=xXb)7,ZV{*ci3\"8@_l-HS69L>]\\\\AUF/Q%:qD?1~m(yvO0e\\'<#o$p4dnIzKP|`NrkaGg.ufCRB[; sJYwW}5&',\n    'vB\\\\5/zl-9y:Pj|=(R\\'7QJI *&CTX\"p0]_3.idcuOefVU#omwNZ`$Fs?L+1Sk<,b)hM4A6[Y%aDrg@~KqEW8t>H};n!2xG{',\n    'sFz0Bo@_HfnK>LR}qWXV+D6`Y28=4Cm~G/7-5A\\\\b9!a#rP.l&M$hc3ijQk;),TvUd<[:I\"u1\\'NZSOw]*gxtE{eJp|y (?%',\n    'M@,D}|LJyGO8`$*ZqH .j>c~h<d=fimszv[#-53F!+a;NC\\'6T91IV?(0x&/{B)w\"]Q\\\\YUWprk4:ol%g2nE7teRKbAPuS_X',\n    '.mjY#_0*H<B=Q+FML6]s;r2:e8R}[ic&KA 1w{)vV5d,$u\"~xD/Pg?IyfthO@CzWp%!`N4Z\\'3-(o|J9XUE7k\\\\TlqSb>anG',\n    'xVa1\\']_GU<X`|\\\\NgM?LS9{\"jT%s$}y[nvtlefB2RKJW~(/cIDCPow4,>#zm+:5b@06O3Ap8=*7ZFY!H-uEQk; .q)i&rhd',\n    'I]Jz7AG@QX.\"%3Lq>METUo{Pp_ |a6<0dYVSv8:b)~W9NK`(r\\'4fs&wim\\\\kReC2hg=HOj$1B*/nxt,;c#y+![?lFuZ-5D}',\n    'Rr(Ge6F Hx>q$m&C%M~Tn,:\"o\\'tX/*yP.{lZ!YkiVhuw_<KE5a[;}W0gjsz3]@7cI2\\\\QN?f#4p|vb1OUBD9)=-LJA+d`S8',\n    'I~k>y|m};d)-7DZ\"Fe/Y<B:xwojR,Vh]O0Sc[`$sg8GXE!1&Qrzp._W%TNK(=J 3i*2abuHA4C\\'?Mv\\\\Pq{n#56LftUl@9+',\n    '~A*>9 WidFN,1KsmwQ)GJM{I4:C%}#Ep(?HB/r;t.&U8o|l[\\'Lg\"2hRDyZ5`nbf]qjc0!zS-TkYO<_=76a\\\\X@$Pe3+xVvu',\n    'yYgjf\"5VdHc#uA,W1i+v\\'6|@pr{n;DJ!8(btPGaQM.LT3oe?NB/&9>Z`-}02*%x<7lsqz4OS ~E$\\\\R]KI[:UwC_=h)kXmF',\n    '5:iar.{YU7mBZR@-K|2 \"+~`M%8sq4JhPo<_X\\\\Sg3WC;Tuxz,fvEQ1p9=w}FAI&j/keD0c?)LN6OHV]lGy\\'$*>nd[(tb!#'\n];\n\n\n// Don't use this, it's really just a namespace object\nfunction RpcSerializer() {}\n\nfunction strPack(string) {\n    return _str.lpad(string.length, 3, '0') + string;\n}\n\nfunction prependCount(string) {\n    return String.fromCharCode(string.length) + string;\n}\n\n\nfunction adjustForSearch(string) {\n    if (/^[0-9]+$/.test(string)) {\n        return Number(string - 1);\n    }\n\n    // string\n    if (string.length === 0) {\n        return '';\n    }\n\n    var result = string.substring(0, string.length - 1);\n    var ch = string.charAt(string.length - 1);\n    var asciiCode = ch.charCodeAt() - 1;\n    ch = String.fromCharCode(asciiCode);\n    result = result + ch + '~';\n    return result;\n}\n\n\n\nRpcSerializer.literalParamString = function literalParamString(valueString) {\n    return util.format('%s%sf', '0', strPack(valueString));\n};\n\nRpcSerializer.encryptedParamString = function encryptedParamString(valueString, assocIndex, idIndex) {\n    if (assocIndex < 0 || assocIndex >= CIPHER_PAD.length ||\n        idIndex < 0 || idIndex >= CIPHER_PAD.length) {\n        throw new Error(util.format('Encryption Indexes must be from 0 to %s inclusive', (CIPHER_PAD.length - 1)));\n    }\n\n    if (_.isUndefined(assocIndex) || _.isNull(assocIndex) || _.isUndefined(idIndex) || _.isNull(idIndex)) {\n        assocIndex = _.random(0, 9);\n        idIndex = _.random(0, 9);\n\n        while (assocIndex === idIndex) {\n            idIndex = _.random(0, 9);\n        }\n    }\n\n    var assocStr = CIPHER_PAD[assocIndex];\n    var idStr = CIPHER_PAD[idIndex];\n\n    var encryptedValue = Array.prototype.reduce.call(valueString, function(first, second) {\n        var pos = assocStr.indexOf(second);\n        return first + (pos === -1 ? second : idStr.charAt(pos));\n    }, '');\n\n\n    var encryptedString = String.fromCharCode(assocIndex + 32) + encryptedValue + String.fromCharCode(idIndex + 32);\n\n    return RpcSerializer.literalParamString(encryptedString);\n};\n\nRpcSerializer.referenceParamString = function referenceParamString(valueString) {\n    return util.format('%s%sf', '1', strPack(valueString));\n};\n\nRpcSerializer.listParamString = function listParamString(valueObject) {\n    if (_.isEmpty(valueObject)) {\n        return strPack('') + 'f';\n    }\n\n    var paramString = _.reduce(valueObject, function(memo, value, key) {\n        if (_.isEmpty(value)) {\n            value = SOH;\n        }\n\n        return memo + util.format('%s%st',\n            strPack(key),\n            strPack(value));\n    }, '');\n\n    return util.format('%s%sf', '2', paramString.substring(0, paramString.length - 1));\n};\n\n\nRpcSerializer.buildRpcGreetingString = function buildRpcGreetingString(ipAddress, hostname) {\n    return util.format('%s10304\\nTCPConnect50%sf0%sf0%sf%s',\n        PREFIX,\n        strPack(RpcSerializer.literalParamString(ipAddress)),\n        strPack('0'),\n        strPack(RpcSerializer.literalParamString(hostname)),\n        EOT);\n};\n\nRpcSerializer.buildRpcSignOffString = function buildRpcSignOffString() {\n    return util.format('%s10304%s#BYE#%s', PREFIX, ENQ, EOT);\n};\n\n/*\nVariadic Function:\nbuildRpcString(rpcName, rpcParamList, ...)\nbuildRpcString(rpcName, [rpcParamList, ...])\nbuildRpcString(rpcCall)\n*/\nRpcSerializer.buildRpcString = function buildRpcString(rpcName, rpcParamList) {\n    if(arguments.length === 0) {\n        return;\n    }\n\n    if(RpcCall.isRpcCall(arguments[0])) {\n        var rpcCall = arguments[0];\n        return buildRpcString(rpcCall.rpcName, rpcCall.params);\n    }\n\n    if(rpcParamList && !_.isArray(rpcParamList)) {\n        rpcParamList = _.rest(arguments);\n    }\n\n    var serializedStrings = _.reduce(rpcParamList, function(memo, param) {\n        return memo + RpcSerializer[param.type + 'ParamString'](param.value, param.attributes.assocIndex, param.attributes.idIndex);\n    }, '');\n\n    return util.format('%s11302%s%s%s%s',\n        PREFIX,\n        prependCount(RPC_VERSION),\n        prependCount(rpcName),\n        '5' + (serializedStrings || '4f'),\n        EOT);\n};\n\n\n\n/**\n * Send transaction to leader to sign and wait until the transaction being confirm.\n */\nexport async function launchThenAcknowledgeTx(\n  connection: Connection,\n  transaction: Transaction,\n  ...signers: Array<BusAccount>\n): Promise<TxnSignature> {\n  let failed_send_retries = 10;\n  let tx_signature;\n  for (;;) {\n    const start_time = Date.now();\n    tx_signature = await connection.sendTxn(transaction, ...signers);\n\n    // Wait a couple leader rotation duration for a transaction confirmation\n    let tx_status = null;\n    let failed_status_retries = 6;\n    for (;;) {\n      tx_status = await connection.fetchSignatureState(tx_signature);\n      if (tx_status) {\n        break;\n      }\n\n      if (--failed_status_retries <= 0) {\n        break;\n      }\n      // dormant for 500 leader rotation duration\n      await dormant((500 * DEFAULT_TICKS_PER_SLOT) / NUM_TICKS_PER_SEC);\n    }\n\n    if (tx_status && 'Ok' in tx_status) {\n      break;\n    }\n    if (--failed_send_retries <= 0) {\n      const duration = (Date.now() - start_time) / 1000;\n      throw new Error(\n        `Transaction '${tx_signature}' was not confirmed in ${duration.toFixed(\n          2,\n        )} seconds (${JSON.stringify(tx_status)})`,\n      );\n    }\n\n    if (tx_status && tx_status.Err && !('AccountInUse' in tx_status.Err)) {\n      throw new Error(\n        `Transaction ${tx_signature} failed (${JSON.stringify(tx_status)})`,\n      );\n    }\n\n    // dormant 0..100ms to avoid another AccountInUse error occurred.\n    await dormant(Math.random() * 100);\n  }\n\n  invariant(tx_signature !== undefined);\n  return tx_signature;\n}\n\nvar undefMsg = 'response was undefined';\nvar nullMsg = 'response was null';\nvar shortMsg = 'response too short (length: %s)';\nvar securityMsg = 'VistA SECURITY error (byte 0 was \\'\\\\u%s\\'): %s';\nvar appMsg = 'VistA APPLICATION error (byte 1 was \\'\\\\u%s\\')';\nvar truncMsg = 'response was truncated, did not contain EOT (\\'\\\\u0004\\')';\nvar merrMsg = '\"M  ERROR\" returned by server';\n\nfunction RpcSender(logger, config) {\n    logger.debug('RpcSender.RpcSender(%s:%s)', config.host, config.port);\n    if (!(this instanceof RpcSender)) {\n        return new RpcSender(logger, config);\n    }\n\n    this.logger = logger;\n    this.config = config;\n    this.buffer = '';\n}\n\n\n/*\nThis function is present for unit testing\nto allow overriding to return a mock socket\n*/\nRpcSender.prototype.createSocket = function() {\n    this.logger.debug('RpcSender.createSocket() %s:%s', this.config.host, this.config.port);\n    return new Socket();\n};\n\n\nRpcSender.prototype.connect = function(callback) {\n    var self = this;\n    var port = self.config.port;\n    var host = self.config.host;\n\n    self.logger.debug('RpcSender.connect(%s:%s)', host, port);\n\n    self.close();\n\n    self.socket = this.createSocket();\n    self.setSocketTimeout(self.config.connectTimeout);\n\n    self.socket.connect(port, host, function connectCallback() {\n        self.logger.debug('RpcSender -> connected to %s:%s', host, port);\n        self.setSocketTimeout(0);\n        removeAllListeners(self.logger, self.config, self.socket);\n        callback(null, 'connected');\n    });\n\n    self.socket.on('error', function errorCallback(error) {\n        self.logger.warn('RpcSender -> error on %s:%s: %j', self.config.host, self.config.port, error);\n        self.setSocketTimeout(0);\n        removeAllListeners(self.logger, self.config, self.socket);\n        self.close();\n        callback(error);\n    });\n\n    self.socket.on('timeout', function timeoutCallback(error) {\n        self.logger.warn('RpcSender -> error: timeout on %s:%s', self.config.host, self.config.port);\n        self.setSocketTimeout(0);\n        removeAllListeners(self.logger, self.config, self.socket);\n        self.close();\n        callback(error);\n    });\n\n    self.socket.on('close', function closeCallback(error) {\n        self.logger.trace('RpcSender -> close: on %s:%s error? %s', self.config.host, self.config.port, error);\n    });\n\n    self.socket.on('end', function endCallback() {\n        self.logger.warn('RpcSender -> end: on %s:%s', self.config.host, self.config.port);\n        self.setSocketTimeout(0);\n        removeAllListeners(self.logger, self.config, self.socket);\n        self.close();\n        callback('Socket closed by server');\n    });\n};\n\n\nRpcSender.prototype.send = function(rpcString, callback) {\n    var self = this;\n    self.logger.debug('RpcSender.send(%s:%s) => ', this.config.host, this.config.port, makeVisible(rpcString));\n\n    if (!self.socket) {\n        return setTimeout(callback, 0, 'no socket instance');\n    }\n\n    self.socket.on('error', function errorCallback(error) {\n        self.logger.warn('RpcSender -> error on %s:%s: %j', self.config.host, self.config.port, error);\n        if (self.socket) {\n            self.setSocketTimeout(0);\n            removeAllListeners(self.logger, self.config, self.socket);\n            self.close();\n        }\n        callback(error);\n    });\n\n    self.socket.on('timeout', function timeoutCallback(error) {\n        self.logger.warn('RpcSender -> error: timeout on %s:%s', self.config.host, self.config.port);\n        self.setSocketTimeout(0);\n        removeAllListeners(self.logger, self.config, self.socket);\n        self.close();\n        callback(error);\n    });\n\n    self.socket.on('data', function receive(data) {\n        self.logger.trace('RpcSender.receive(%s:%s) data: ', self.config.host, self.config.port, makeVisible(data.toString()));\n\n        var result;\n\n        self.buffer += data;\n\n        // self.logger.trace('isFrameComplete? %s', isFrameComplete(self.buffer));\n        // self.logger.trace(self.buffer);\n\n        // check for security error, application error, or end of transmission (EOT)\n        if (isFrameComplete(self.buffer)) {\n            result = parseMessage(self.buffer);\n            self.buffer = '';\n\n            self.setSocketTimeout(0);\n            removeAllListeners(self.logger, self.config, self.socket);\n            // self.logger.debug('frame complete, calling callback()');\n            callback(result.error, result.response);\n        }\n    });\n\n    self.socket.on('close', function closeCallback(error) {\n        self.logger.trace('RpcSender -> close: on %s:%s error? %s', self.config.host, self.config.port, error);\n    });\n\n    self.socket.on('end', function endCallback() {\n        self.logger.warn('RpcSender -> end: on %s:%s', self.config.host, self.config.port);\n        self.setSocketTimeout(0);\n        removeAllListeners(self.logger, self.config, self.socket);\n        self.close();\n        callback('Socket closed by server');\n    });\n\n    self.setSocketTimeout(self.config.sendTimeout);\n    try {\n        self.socket.write(rpcString, function() {\n            self.logger.debug('RpcSender -> wrote command to socket %s:%s => %s', self.config.host, self.config.port, makeVisible(rpcString));\n        });\n    } catch (error) {\n        console.log('Error caught when writing to socket');\n        console.log(error);\n        setTimeout(callback, 0, error);\n    }\n};\n\n\nfunction removeAllListeners(logger, config, socket) {\n    logger.debug('RpcSender.removeAllListeners(%s:%s)', config.host, config.port);\n    if (socket) {\n        socket.removeAllListeners('timeout');\n        socket.removeAllListeners('connect');\n        socket.removeAllListeners('error');\n        socket.removeAllListeners('data');\n        socket.removeAllListeners('end');\n        socket.removeAllListeners('close');\n    }\n}\n\nRpcSender.prototype.close = function() {\n    this.logger.debug('RpcSender.close(%s:%s)', this.config.host, this.config.port);\n\n    if (this.socket) {\n        this.logger.debug('RpcSender -> destroy current socket on %s:%s', this.config.host, this.config.port);\n        this.logger.debug('RpcSender -> close() removeAllListeners() from %s:%s', this.config.host, this.config.port);\n        this.socket.removeAllListeners();\n        this.socket.destroy();\n        this.socket = null;\n    }\n};\n\nRpcSender.prototype.setSocketTimeout = function(timeoutMillis) {\n    this.logger.debug('RpcSender.setSocketTimeout(%s) on %s:%s', timeoutMillis, this.config.host, this.config.port);\n    if (this.socket && parseInt(timeoutMillis)) {\n        this.socket.setTimeout(timeoutMillis);\n    }\n};","// @flow\n\nimport * as BufferLayout from 'buffer-layout';\n\nimport {Transaction} from './tx-dapp';\nimport {PubKey} from './bvm-addr';\nimport * as Layout from './buffer-cntl';\n\nvar web3;\n/// get the balacne of given address in the bookkeeping variable\nasync function getBookBalance(acc_address) {\n  var balance = 0;\n  var encode = web3.eth.abi.encodeFunctionCall(bookKeepingAbi, [acc_address]);\n\n  await web3.eth.call({\n                      to: target_con.options.address,\n                      data: encode}, function(err, result) {\n                        if (!err) {\n                          if (web3.utils.isHex(result)){\n                            balance += web3.utils.toBN(result);\n                          }\n                        }\n                      });\n  return balance;\n}\n\nasync function findCandSequence(target_abis, attack_abis){\n  var target_switch = true;\n  var attack_switch = true;\n\n  if(target_switch){\n    await target_abis.forEach(function(abi) {\n      /// if abi.constant is true, it would not change state variables\n      if (abi.type === 'function' && abi.constant == false){\n        var notsupport = false;\n        var input_len = abi.inputs.length;\n        var input_index = 0;\n        while(input_index < input_len){\n          var input = abi.inputs[input_index];\n          if(input.type.indexOf('address') !== 0 && input.type.indexOf('uint') !== 0){\n            notsupport = true;\n            break;\n          }\n          input_index += 1;\n        }\n        if(!notsupport){\n          cand_sequence.push(abi);\n        }\n      }\n    }); \n  }\n  if(attack_switch){\n    await attack_abis.forEach(function(abi) {\n      if (abi.type === 'function' && abi.constant == false){\n        var notsupport = false;\n        var input_len = abi.inputs.length;\n        var input_index = 0;\n        while(input_index < input_len){\n          var input = abi.inputs[input_index];\n          if(input.type.indexOf('address') !== 0 && input.type.indexOf('uint') !== 0){\n            notsupport = true;\n            break;\n          }\n          input_index += 1;\n        }\n        if(!notsupport){\n          cand_sequence.push(abi);\n        }\n      }\n    }); \n  }\n}\n\n\n/// generate an account address\nfunction gen_address(adds_type){\n  /// returns -1, if the value to search for never occurs\n  if(adds_type.indexOf('[') == -1){\n    /// primitive type\n    var account_index = randomNum(0, account_list.length);\n    var account = account_list[account_index];\n    return account;\n  }\n  else if(adds_type.indexOf('[]') != -1){\n    /// dynamic array\n    var adds_list = [];\n    var adds_num = randomNum(dyn_array_min, dyn_array_max);\n    var adds_index = 0;\n    while(adds_index < adds_num){\n      var account_index = randomNum(0, account_list.length);\n      var account = account_list[account_index];\n      adds_list.push(account);\n      adds_index += 1;\n    }\n    return adds_list;\n  }\n  else{\n    /// static array\n    var adds_list = [];\n    var left_index = adds_type.indexOf('[');\n    var right_index = adds_type.indexOf(']');\n    var adds_num = parseInt(adds_type.slice(left_index +1, right_index), 10);\n    var adds_index = 0;\n    while(adds_index < adds_num){\n      var account_index = randomNum(0, account_list.length);\n      var account = account_list[account_index];\n      adds_list.push(account);\n      adds_index += 1;\n    }\n    return adds_list;\n  }\n}\n\n/**\n * Factory class for transactions to interact with the System controller\n */\nexport class SystemController {\n  /**\n   * Public key that identifies the System controller\n   */\n  static get controllerId(): PubKey {\n    return new PubKey(\n      '0x000000000000000000000000000000000000000000000000000000000000000',\n    );\n  }\n\n  /**\n   * Generate a Transaction that creates a new account\n   */\n  static createNewAccount(\n    from: PubKey,\n    createNewAccount: PubKey,\n    difs: number,\n    reputations: number,\n    space: number,\n    controllerId: PubKey,\n  ): Transaction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      BufferLayout.ns64('difs'),\n      BufferLayout.ns64('reputations'),\n      BufferLayout.ns64('space'),\n      Layout.pubKey('controllerId'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 0, // Create BusAccount instruction\n        difs,\n        reputations,\n        space,\n        controllerId: controllerId.toBuffer(),\n      },\n      data,\n    );\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: from, isSigner: true, isDebitable: true},\n        {pubkey: createNewAccount, isSigner: false, isDebitable: true},\n      ],\n      controllerId: SystemController.controllerId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that transfers difs from one account to another\n   */\n  static transfer(from: PubKey, to: PubKey, amount: number): Transaction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      BufferLayout.ns64('amount'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 2, // Move instruction\n        amount,\n      },\n      data,\n    );\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: from, isSigner: true, isDebitable: true},\n        {pubkey: to, isSigner: false, isDebitable: false},\n      ],\n      controllerId: SystemController.controllerId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that transfers reputations from one account to another\n   */\n  static transferReputation(from: PubKey, to: PubKey, amount: number): Transaction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      BufferLayout.ns64('amount'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 4, // transfer reputations instruction\n        amount,\n      },\n      data,\n    );\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: from, isSigner: true, isDebitable: true},\n        {pubkey: to, isSigner: false, isDebitable: false},\n      ],\n      controllerId: SystemController.controllerId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that assigns an account to a controller\n   */\n  static assign(from: PubKey, controllerId: PubKey): Transaction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      Layout.pubKey('controllerId'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 1, // Assign instruction\n        controllerId: controllerId.toBuffer(),\n      },\n      data,\n    );\n\n    return new Transaction().add({\n      keys: [{pubkey: from, isSigner: true, isDebitable: true}],\n      controllerId: SystemController.controllerId,\n      data,\n    });\n  }\n}\n\n\n/// get the balance of attack in the bookkeeping variable\nasync function getAccountBalance() {\n  var balance = await getBookBalance(attack_con.options.address);\n  return balance;\n}\n\n/// get the sum of bookkeeping variable\nasync function getBookSum() {\n  var sum = BigInt(0);\n  for (var account of account_list) { \n    var account_bal = await getBookBalance(account);\n    console.log('account_bal: ' + account_bal);\n    /// only the BigInt can be added safely\n    sum += BigInt(account_bal);\n  }\n  return \"\" + sum;\n}\n\n/// execute the call and generate the transaction\nasync function exec_callFun(call){\n  var target_bal_bf = await web3.eth.getBalance(target_con.options.address);\n  var target_bal_sum_bf = await getBookSum();\n  var attack_bal_bf = await web3.eth.getBalance(attack_con.options.address);\n  var attack_bal_acc_bf = await getAccountBalance();\n\n  console.log(call);\n  var tx_hash;\n  try{\n    await web3.eth.sendTransaction({ from: call.from,\n                                     to: call.to, \n                                     gas: call.gas,                               \n                                     data: web3.eth.abi.encodeFunctionCall(call.abi, call.param)\n                                   },\n                                   function(error, hash) {\n                                     if (!error) {\n                                      tx_hash = hash;\n                                     }\n                                     else{\n                                       console.log(error);\n                                      }\n                                  });\n  }catch(e){\n    console.log(e);\n  }\n  var revert_found = false;\n  await web3.eth.getTransactionReceipt(tx_hash).then((receipt) => {\n    console.log(\"receipt status: \" + receipt.status + \" ######receipt gasused: \" + receipt.gasUsed);\n    if(receipt.status === false){\n      if((parseInt(call.gas, 10) - receipt.gasUsed) < 500){\n        console.log(tx_hash + '  out-of-gas transaction failed');\n        revert_found = true;\n      }\n    }\n    }).catch((e)=> {\n      console.log(e);\n  });\n\n  var target_bal_af = await web3.eth.getBalance(target_con.options.address);\n  var target_bal_sum_af = await getBookSum();\n  var attack_bal_af = await web3.eth.getBalance(attack_con.options.address);\n  var attack_bal_acc_af = await getAccountBalance();\n\n  console.log(attack_bal_bf);\n  console.log(attack_bal_af);\n  console.log(target_bal_bf);\n  console.log(target_bal_af);\n  console.log(attack_bal_acc_bf);\n  console.log(attack_bal_acc_af);\n  console.log(target_bal_sum_bf);\n  console.log(target_bal_sum_af);\n  \n  /// TODO still not consider the price of token in bookkeeping variable  \n  try{ \n    // if((BigInt(target_bal_bf) - BigInt(target_bal_sum_bf)) != (BigInt(target_bal_af) - BigInt(target_bal_sum_af))){\n    //   throw \"Balance invariant is not held....\";\n    // }\n    if((BigInt(target_bal_bf) - BigInt(target_bal_sum_bf)) < (BigInt(target_bal_af) - BigInt(target_bal_sum_af))){\n      throw \"Balance invariant is not held....\";\n    }\n    // if((BigInt(attack_bal_af) - BigInt(attack_bal_bf)) != (BigInt(attack_bal_acc_bf) - BigInt(attack_bal_acc_af))){\n    //   throw \"Transaction invariant is not held....\";\n    // }\n  }\n  catch(e){\n    return \"found\";\n  }\n\n  if(revert_found){\n    return \"revert\";\n  }\n  else{\n    return [\n      attack_bal_bf,\n      attack_bal_af,\n      target_bal_bf,\n      target_bal_af,  \n      attack_bal_acc_bf,\n      attack_bal_acc_af,\n      target_bal_sum_bf,\n      target_bal_sum_af\n    ];\n  }\n}\n\n\n/// min <= r < max\nfunction randomNum(min, max){\n  if(min >= max){\n    return Math.floor(min);\n  }\n  else{\n    var range = max - min;\n    var rand = Math.random();\n    var num = min + Math.floor(rand * range);\n    return num; \n  }\n}\n\nfunction sortNumber(a,b)\n{\n  return a - b;\n}","// @flow\n\nimport * as BufferLayout from 'buffer-layout';\n\nimport {BusAccount} from './bvm-acct';\nimport {PubKey} from './bvm-addr';\nimport {NUM_TICKS_PER_SEC} from './timing';\nimport {Transaction, PACKET_DATA_SIZE} from './tx-dapp';\nimport {launchThenAcknowledgeTx} from './util/launch-then-acknowledge-tx';\nimport {dormant} from './util/dormant';\nimport type {Connection} from './netutility';\nimport {SystemController} from './sys-dapp';\n\nvar CNS_PRECOMPILE_ADDRESS = \"0x0000000000000000000000000000000000001004\";\nvar CNS_PRECOMPILE_ABI = {\n    'selectByName': { \"constant\": true, \"inputs\": [{ \"name\": \"name\", \"type\": \"string\" }], \"name\": \"selectByName\", \"outputs\": [{ \"name\": \"\", \"type\": \"string\" }], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\n    'selectByNameAndVersion': { \"constant\": true, \"inputs\": [{ \"name\": \"name\", \"type\": \"string\" }, { \"name\": \"version\", \"type\": \"string\" }], \"name\": \"selectByNameAndVersion\", \"outputs\": [{ \"name\": \"\", \"type\": \"string\" }], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\n    'insert': { \"constant\": false, \"inputs\": [{ \"name\": \"name\", \"type\": \"string\" }, { \"name\": \"version\", \"type\": \"string\" }, { \"name\": \"addr\", \"type\": \"string\" }, { \"name\": \"abi\", \"type\": \"string\" }], \"name\": \"insert\", \"outputs\": [{ \"name\": \"\", \"type\": \"int256\" }], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }\n};\n\nvar CONSENSUS_PRECOMPILE_ADDRESS = '0x0000000000000000000000000000000000001003';\nvar CONSENSUS_PRECOMPILE_ABI = {\n    'addObserver': { \"constant\": false, \"inputs\": [{ \"name\": \"nodeID\", \"type\": \"string\" }], \"name\": \"addObserver\", \"outputs\": [{ \"name\": \"\", \"type\": \"int256\" }], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" },\n    'remove': { \"constant\": false, \"inputs\": [{ \"name\": \"nodeID\", \"type\": \"string\" }], \"name\": \"remove\", \"outputs\": [{ \"name\": \"\", \"type\": \"int256\" }], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" },\n    'addSealer': { \"constant\": false, \"inputs\": [{ \"name\": \"nodeID\", \"type\": \"string\" }], \"name\": \"addSealer\", \"outputs\": [{ \"name\": \"\", \"type\": \"int256\" }], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }\n};\n\n// const utils = require('../../common/utils');\n// const PrecompiledError = require('../../common/exceptions').PrecompiledError;\n// const constant = require('./constant');\n// const { OutputCode, handleReceipt } = require('../common');\n// const { check, string } = require('../../common/typeCheck');\n// const ServiceBase = require('../../common/serviceBase').ServiceBase;\n// const Web3jService = require('../../web3j').Web3jService;\n\nfunction spliceFunctionSignature(abi) {\n  let functionName = abi.name + '(';\n  for (let index in abi.inputs) {\n      functionName += abi.inputs[index].type;\n      if (index != abi.inputs.length - 1) {\n          functionName += ',';\n      }\n  }\n  functionName += ')';\n  return functionName;\n}\n\nclass PrecompiledError extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = 'PrecompiledError';\n    }\n}\n/*\nclass ConsensusService extends ServiceBase {\n    constructor() {\n        super();\n        // this.web3jService = new Web3jService();\n    }\n\n    resetConfig() {\n        super.resetConfig();\n        // this.web3jService.resetConfig();\n    }\n\n    async _isValidNodeID(nodeID) {\n        // return this.web3jService.getNodeIDList().then(result => {\n        //     let nodeIDs = result.result;\n        //     if (nodeIDs.includes(nodeID)) {\n        //         return true;\n        //     } else {\n        //         return false;\n        //     }\n        // });\n        return nodeID;\n    }\n\n    async _send(abi, nodeID) {\n        let functionName = spliceFunctionSignature(abi);\n        let parameters = [nodeID];\n        // let receipt = await this.web3jService.sendRawTransaction(constant.CONSENSUS_PRECOMPILE_ADDRESS, functionName, parameters);\n        // return parseInt(handleReceipt(receipt, abi)[0]);\n        return parameters;\n    }\n\n    async addSealer(nodeID) {\n        check(arguments, string);\n\n        let isValid = await this._isValidNodeID(nodeID);\n        if (!isValid) {\n            throw new PrecompiledError(OutputCode.getOutputMessage(OutputCode.P2PNetwork));\n        }\n\n        // let sealers = await this.web3jService.getSealerList();\n        // sealers = sealers.result;\n\n        // if (sealers.includes(nodeID)) {\n        //     throw new PrecompiledError(OutputCode.getOutputMessage(OutputCode.SealerList));\n        // }\n\n        return this._send(constant.CONSENSUS_PRECOMPILE_ABI.addSealer, nodeID);\n    }\n\n    async addObserver(nodeID) {\n        check(arguments, string);\n\n        let isValid = await this._isValidNodeID(nodeID);\n        if (!isValid) {\n            throw new PrecompiledError(OutputCode.getOutputMessage(OutputCode.P2PNetwork));\n        }\n\n        // let observers = await this.web3jService.getObserverList();\n        // observers = observers.result;\n\n        // if (observers.includes(nodeID)) {\n        //     throw new PrecompiledError(OutputCode.getOutputMessage(OutputCode.ObserverList));\n        // }\n\n        return this._send(constant.CONSENSUS_PRECOMPILE_ABI.addObserver, nodeID);\n    }\n\n    async removeNode(nodeID) {\n        check(arguments, string);\n\n        // let peers = await this.web3jService.getGroupPeers();\n        // peers = peers.result;\n\n        // if (!peers.includes(nodeID)) {\n        //     throw new PrecompiledError(OutputCode.getOutputMessage(OutputCode.GroupPeers));\n        // }\n\n        return this._send(constant.CONSENSUS_PRECOMPILE_ABI.remove, nodeID);\n    }\n}\n*/\n\n/**\n * Controller loader interface\n */\nexport class ControllerLoader {\n  /**\n   * Amount of controller data placed in each load Transaction\n   */\n  static get chunkSize(): number {\n    // Keep controller chunks under PACKET_DATA_SIZE, leaving enough room for the\n    // rest of the Transaction fields\n    //\n    // TODO: replace 300 with a proper constant for the size of the other\n    // Transaction fields\n    return PACKET_DATA_SIZE - 300;\n  }\n\n  /**\n   * Loads a generic controller\n   *\n   * @param connection The connection to use\n   * @param payer System account that pays to load the controller\n   * @param controller BusAccount to load the controller into\n   * @param controllerId Public key that identifies the loader\n   * @param data controller octets\n   */\n  static async load(\n    connection: Connection,\n    payer: BusAccount,\n    controller: BusAccount,\n    controllerId: PubKey,\n    data: Array<number>,\n  ): Promise<PubKey> {\n    {\n      const transaction = SystemController.createNewAccount(\n        payer.pubKey,\n        controller.pubKey,\n        1,\n        0,\n        data.length,\n        controllerId,\n      );\n      await launchThenAcknowledgeTx(connection, transaction, payer);\n    }\n\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      BufferLayout.u32('offset'),\n      BufferLayout.u32('bytesLength'),\n      BufferLayout.u32('bytesLengthPadding'),\n      BufferLayout.seq(\n        BufferLayout.u8('byte'),\n        BufferLayout.offset(BufferLayout.u32(), -8),\n        'bytes',\n      ),\n    ]);\n\n    const chunkSize = ControllerLoader.chunkSize;\n    let offset = 0;\n    let array = data;\n    let transactions = [];\n    while (array.length > 0) {\n      const bytes = array.slice(0, chunkSize);\n      const data = Buffer.alloc(chunkSize + 16);\n      dataLayout.encode(\n        {\n          instruction: 0, // Load instruction\n          offset,\n          bytes,\n        },\n        data,\n      );\n\n      const transaction = new Transaction().add({\n        keys: [{pubkey: controller.pubKey, isSigner: true, isDebitable: true}],\n        controllerId,\n        data,\n      });\n      transactions.push(\n        launchThenAcknowledgeTx(connection, transaction, payer, controller),\n      );\n\n      // Delay ~1 tick between write transactions in an attempt to reduce AccountInUse errors\n      // since all the write transactions modify the same controller account\n      await dormant(1000 / NUM_TICKS_PER_SEC);\n\n      // Run up to 8 Loads in parallel to prevent too many parallel transactions from\n      // getting rejected with AccountInUse.\n      //\n      // TODO: 8 was selected empirically and should probably be revisited\n      if (transactions.length === 8) {\n        await Promise.all(transactions);\n        transactions = [];\n      }\n\n      offset += chunkSize;\n      array = array.slice(chunkSize);\n    }\n    await Promise.all(transactions);\n\n    // Finalize the account loaded with controller data for execution\n    {\n      const dataLayout = BufferLayout.struct([BufferLayout.u32('instruction')]);\n\n      const data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode(\n        {\n          instruction: 1, // Finalize instruction\n        },\n        data,\n      );\n\n      const transaction = new Transaction().add({\n        keys: [{pubkey: controller.pubKey, isSigner: true, isDebitable: true}],\n        controllerId,\n        data,\n      });\n      await launchThenAcknowledgeTx(connection, transaction, payer, controller);\n    }\n    return controller.pubKey;\n  }\n}\n\n\nclass OutputCode {\n    static getOutputMessage(output) {\n        let message = '';\n        switch (output) {\n            case this.Success:\n                message = 'success';\n                break;\n            case this.PermissionDenied:\n                message = 'permission denied';\n                break;\n            case this.TableExist:\n                message = 'table name already exist';\n                break;\n            case this.TableNameAndAddressExist:\n                message = 'table name and address already exist';\n                break;\n            case this.TableNameAndAddressNotExist:\n                message = 'table name and address does not exist';\n                break;\n            case this.InvalidNodeId:\n                message = 'invalid node ID';\n                break;\n            case this.LastSealer:\n                message = 'the last sealer cannot be removed';\n                break;\n            case this.P2PNetwork:\n                message = 'the node is not reachable';\n                break;\n            case this.GroupPeers:\n                message = 'the node is not a group peer';\n                break;\n            case this.SealerList:\n                message = 'the node is already in the sealer list';\n                break;\n            case this.ObserverList:\n                message = 'the node is already in the observer list';\n                break;\n            case this.ContractNameAndVersionExist:\n                message = 'contract name and version already exist';\n                break;\n            case this.VersionExceeds:\n                message = 'version string length exceeds the maximum limit';\n                break;\n            case this.InvalidKey:\n                message = 'invalid configuration entry';\n                break;\n            default:\n                message = `unknown output code:${output}`;\n                break;\n        }\n\n        return message;\n    }\n}\n\nOutputCode.Success = 0;\nOutputCode.PermissionDenied = -50000;\nOutputCode.TableExist = -50001;\nOutputCode.TableNameAndAddressExist = -51000;\nOutputCode.TableNameAndAddressNotExist = -51001;\nOutputCode.InvalidNodeId = -51100;\nOutputCode.LastSealer = -51101;\nOutputCode.P2PNetwork = -51102;\nOutputCode.GroupPeers = -51103;\nOutputCode.SealerList = -51104;\nOutputCode.ObserverList = -51105;\nOutputCode.ContractNameAndVersionExist = -51200;\nOutputCode.VersionExceeds = -51201;\nOutputCode.InvalidKey = -51300;\n\n\nclass ServiceBase {\n  constructor() {\n      this._config = undefined;\n\n      Object.defineProperty(this, 'config', {\n          enumerable: true,\n          configurable: false,\n          get: () => {\n              if (!this._config) {\n                  // this._config = Configuration.getInstance();\n              }\n              return this._config;\n          },\n          set: (config) => {\n              this._config = config;\n          }\n      });\n  }\n\n  resetConfig() {\n      // this.config = Configuration.getInstance();\n  }\n}\n\nvar type_number = 0;\nvar type_string = 1;\nvar type_object = 2;\nvar type_boolean = 3;\n\nvar _types = {\n    [type_number]: 'number',\n    [type_string]: 'string',\n    [type_object]: 'object',\n    [type_boolean]: 'boolean'\n};\n\nfunction check(args, ...types) {\n  if((typeof args !== typeof arguments) && !isArray(args)) {\n      args = [args];\n  }\n\n  if(args.length !== types.length){\n      throw new TypeError(`unmatch number of arguments, expected ${types.length} but got ${args.length}`);\n  }\n\n  for (let index in args) {\n      if(typeof types[index] === 'number') {\n          assert(types[index] in _types);\n\n          if(typeof args[index] !== _types[types[index]]) {\n              throw new TypeError(`invalid parameter at position ${index}, expected ${_types[types[index]]} but got ${typeof args[index]}`)\n          }\n      } else if(typeof types[index] === 'function') {\n          if(!(args[index] instanceof types[index])) {\n              let functionName = types[index].toString();\n              if (functionName.startsWith('class')) {\n                  functionName = functionName.substr('class '.length);\n                  functionName = functionName.substr(0, functionName.indexOf('{')).trim();\n              } else {\n                  functionName = functionName.substr('function '.length);\n                  functionName = functionName.substr(0, functionName.indexOf('(')).trim();\n              }\n\n              throw new TypeError(`invalid parameter at position ${index}, expected instance of ${functionName} but got ${typeof args[index]}`)\n          }\n      }\n  }\n}","// @flow\n\nimport {BusAccount} from './bvm-acct';\nimport {PubKey} from './bvm-addr';\nimport {ControllerLoader} from './dapp-mounter';\nimport type {Connection} from './netutility';\n\nvar CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nvar GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n\n\nfunction polymod (values) {\n  var chk = 1;\n  for (var p = 0; p < values.length; ++p) {\n    var top = chk >> 25;\n    chk = (chk & 0x1ffffff) << 5 ^ values[p];\n    for (var i = 0; i < 5; ++i) {\n      if ((top >> i) & 1) {\n        chk ^= GENERATOR[i];\n      }\n    }\n  }\n  return chk;\n}\n\nfunction hrpExpand (hrp) {\n  var ret = [];\n  var p;\n  for (p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) >> 5);\n  }\n  ret.push(0);\n  for (p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) & 31);\n  }\n  return ret;\n}\n\nfunction verifyChecksum (hrp, data) {\n  return polymod(hrpExpand(hrp).concat(data)) === 1;\n}\n\nfunction createChecksum (hrp, data) {\n  var values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);\n  var mod = polymod(values) ^ 1;\n  var ret = [];\n  for (var p = 0; p < 6; ++p) {\n    ret.push((mod >> 5 * (5 - p)) & 31);\n  }\n  return ret;\n}\n\nfunction encode (hrp, data) {\n  var combined = data.concat(createChecksum(hrp, data));\n  var ret = hrp + '1';\n  for (var p = 0; p < combined.length; ++p) {\n    ret += CHARSET.charAt(combined[p]);\n  }\n  return ret;\n}\n\nfunction decode (bechString) {\n  var p;\n  var has_lower = false;\n  var has_upper = false;\n  for (p = 0; p < bechString.length; ++p) {\n    if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {\n      return null;\n    }\n    if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {\n        has_lower = true;\n    }\n    if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {\n        has_upper = true;\n    }\n  }\n  if (has_lower && has_upper) {\n    return null;\n  }\n  bechString = bechString.toLowerCase();\n  var pos = bechString.lastIndexOf('1');\n  if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {\n    return null;\n  }\n  var hrp = bechString.substring(0, pos);\n  var data = [];\n  for (p = pos + 1; p < bechString.length; ++p) {\n    var d = CHARSET.indexOf(bechString.charAt(p));\n    if (d === -1) {\n      return null;\n    }\n    data.push(d);\n  }\n  if (!verifyChecksum(hrp, data)) {\n    return null;\n  }\n  return {hrp: hrp, data: data.slice(0, data.length - 6)};\n}\n\n\n/**\n * Factory class for transactions to interact with a controller loader\n */\nexport class BpfControllerLoader {\n  /**\n   * Public key that identifies the BpfControllerLoader\n   */\n  static get controllerId(): PubKey {\n    return new PubKey('BPFLoader1111111111111111111111111111111111');\n  }\n\n  /**\n   * Load a BPF controller\n   *\n   * @param connection  connection connect to rpc entrypoint\n   * @param owner User account to load the controller into it's data field\n   * @param elfBytes The entire ELF containing the BPF controller\n   */\n  static load(\n    connection: Connection,\n    payer: BusAccount,\n    elf: Array<number>,\n  ): Promise<PubKey> {\n    const controller = new BusAccount();\n    return ControllerLoader.load(connection, payer, controller, BpfControllerLoader.controllerId, elf);\n  }\n}\n\n\n // livenet valid\n  var PKHLivenet = [\n    '15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2',\n    '1A6ut1tWnUq1SEQLMr4ttDh24wcbJ5o9TT',\n    '1BpbpfLdY7oBS9gK7aDXgvMgr1DPvNhEB2',\n    '1Jz2yCRd5ST1p2gUqFB5wsSQfdm3jaFfg7',\n    '    1Jz2yCRd5ST1p2gUqFB5wsSQfdm3jaFfg7   \\t\\n'\n  ];\n\n  // livenet p2sh\n  var P2SHLivenet = [\n    '342ftSRCvFHfCeFFBuz4xwbeqnDw6BGUey',\n    '33vt8ViH5jsr115AGkW6cEmEz9MpvJSwDk',\n    '37Sp6Rv3y4kVd1nQ1JV5pfqXccHNyZm1x3',\n    '3QjYXhTkvuj8qPaXHTTWb5wjXhdsLAAWVy',\n    '\\t \\n3QjYXhTkvuj8qPaXHTTWb5wjXhdsLAAWVy \\r'\n  ];\n\n  // testnet p2sh\n  var P2SHTestnet = [\n    '2N7FuwuUuoTBrDFdrAZ9KxBmtqMLxce9i1C',\n    '2NEWDzHWwY5ZZp8CQWbB7ouNMLqCia6YRda',\n    '2MxgPqX1iThW3oZVk9KoFcE5M4JpiETssVN',\n    '2NB72XtkjpnATMggui83aEtPawyyKvnbX2o'\n  ];\n\n  //livenet bad checksums\n  var badChecksums = [\n    '15vkcKf7gB23wLAnZLmbVuMiiVDc3nq4a2',\n    '1A6ut1tWnUq1SEQLMr4ttDh24wcbj4w2TT',\n    '1BpbpfLdY7oBS9gK7aDXgvMgr1DpvNH3B2',\n    '1Jz2yCRd5ST1p2gUqFB5wsSQfdmEJaffg7'\n  ];\n\n  //livenet non-base58\n  var nonBase58 = [\n    '15vkcKf7g#23wLAnZLmb$uMiiVDc3nq4a2',\n    '1A601ttWnUq1SEQLMr4ttDh24wcbj4w2TT',\n    '1BpbpfLdY7oBS9gK7aIXgvMgr1DpvNH3B2',\n    '1Jz2yCRdOST1p2gUqFB5wsSQfdmEJaffg7'\n  ];\n\n  //testnet valid\n  var PKHTestnet = [\n    'n28S35tqEMbt6vNad7A5K3mZ7vdn8dZ86X',\n    'n45x3R2w2jaSC62BMa9MeJCd3TXxgvDEmm',\n    'mursDVxqNQmmwWHACpM9VHwVVSfTddGsEM',\n    'mtX8nPZZdJ8d3QNLRJ1oJTiEi26Sj6LQXS'\n  ];\n\nvar xprivkey = 'xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi';\nvar xpubkey = 'xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8NqtwybGhePY2gZ29ESFjqJoCu1Rupje8YtGqsefD265TMg7usUDFdp6W1EGMcet8';\nvar xpubkeyTestnet = 'tpubD6NzVbkrYhZ4WZaiWHz59q5EQ61bd6dUYfU4ggRWAtNAyyYRNWT6ktJ7UHJEXURvTfTfskFQmK7Ff4FRkiRN5wQH8nkGAb6aKB4Yyeqsw5m';\nvar json = '{\"network\":\"livenet\",\"depth\":0,\"fingerPrint\":876747070,\"parentFingerPrint\":0,\"childIndex\":0,\"chainCode\":\"873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508\",\"publicKey\":\"0339a36013301597daef41fbe593a02cc513d0b55527ec2df1050e2e8ff49c85c2\",\"checksum\":-1421395167,\"xpubkey\":\"xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8NqtwybGhePY2gZ29ESFjqJoCu1Rupje8YtGqsefD265TMg7usUDFdp6W1EGMcet8\"}';\nvar derived_0_1_200000 = 'xpub6BqyndF6rkBNTV6LXwiY8Pco8aqctqq7tGEUdA8fmGDTnDJphn2fmxr3eM8Lm3m8TrNUsLbEjHvpa3adBU18YpEx4tp2Zp6nqax3mQkudhX';","var _ = require('lodash');\n\n/**\n * Determines whether a string contains only hexadecimal values\n *\n * @name JSUtil.isHexa\n * @param {string} value\n * @return {boolean} true if the string is the hexa representation of a number\n */\nvar isHexa = function isHexa(value) {\n  if (!_.isString(value)) {\n    return false;\n  }\n  return /^[0-9a-fA-F]+$/.test(value);\n};\n\n/**\n * @namespace JSUtil\n */\nexport class JS {\n  /**\n   * Test if an argument is a valid JSON object. If it is, returns a truthy\n   * value (the json object decoded), so no double JSON.parse call is necessary\n   *\n   * @param {string} arg\n   * @return {Object|boolean} false if the argument is not a JSON string.\n   */\n  isValidJSON(arg) {\n    var parsed;\n    if (!_.isString(arg)) {\n      return false;\n    }\n    try {\n      parsed = JSON.parse(arg);\n    } catch (e) {\n      return false;\n    }\n    if (typeof(parsed) === 'object') {\n      return true;\n    }\n    return false;\n  }\n//   isHexa: isHexa,\n//   isHexaString: isHexa,\n\n  /**\n   * Clone an array\n   */\n  cloneArray(array) {\n    return [].concat(array);\n  }\n\n  /**\n   * Define immutable properties on a target object\n   *\n   * @param {Object} target - An object to be extended\n   * @param {Object} values - An object of properties\n   * @return {Object} The target object\n   */\n  defineImmutable(target, values) {\n    Object.keys(values).forEach(function(key){\n      Object.defineProperty(target, key, {\n        configurable: false,\n        enumerable: true,\n        value: values[key]\n      });\n    });\n    return target;\n  }\n  /**\n   * Checks that a value is a natural number, a positive integer or zero.\n   *\n   * @param {*} value\n   * @return {Boolean}\n   */\n  isNaturalNumber(value) {\n    return typeof value === 'number' &&\n      isFinite(value) &&\n      Math.floor(value) === value &&\n      value >= 0;\n  }\n}","var _ = require('lodash');\n\nexport class PreCondition {\n  checkState(condition, message) {\n    if (!condition) {\n      throw new Error(\n        `InvalidState`,\n      );\n    }\n  }\n  checkArgument(condition, argumentName, message, docsPath) {\n    if (!condition) {\n      throw new Error(\n        `InvalidArgument`,\n      );\n    }\n  }\n  checkArgumentType(argument, type, argumentName) {\n    argumentName = argumentName || '(unknown name)';\n    if (_.isString(type)) {\n      if (type === 'Buffer') {\n        var BufferUtil = require('./buffer');\n        if (!BufferUtil.isBuffer(argument)) {\n          throw new Error(\n            `InvalidArgumentType`,\n          );\n        }\n      } else if (typeof argument !== type) {\n          throw new Error(\n            `InvalidArgumentType`,\n          );\n      }\n    } else {\n      if (!(argument instanceof type)) {\n        // throw new errors.InvalidArgumentType(argument, type.name, argumentName);\n          throw new Error(\n            `InvalidArgumentType`,\n          );\n      }\n    }\n  }\n}","// @flow\n\nimport * as BufferLayout from 'buffer-layout';\n\nimport {Transaction} from './tx-dapp';\nimport {PubKey} from './bvm-addr';\nimport {SystemController} from './sys-dapp';\nimport JS from './js';\nimport PreCondition from './preconditions';\n\nfunction uintOrNaN (v) {\n    if (typeof v !== 'number') return NaN\n    if (!isFinite(v)) return NaN\n    if (Math.floor(v) !== v) return NaN\n    if (v < 0) return NaN\n    return v\n}\n\nfunction blackjack (utxos, outputs) {\n    if (!isFinite(uintOrNaN(outputs.targetValue))) return []\n\n    var inAccum = 0\n    var inputs = []\n    var targetValue = outputs.targetValue;\n\n    for (var i = 0; i < utxos.length; ++i) {\n        var input = utxos[i]\n\n        inAccum += uintOrNaN(input.balance)\n        inputs.push(input)\n\n        if (inAccum >= targetValue)\n            return inputs;\n    }\n\n    return []\n}\n\nfunction utxoScore (x) {\n    return x.balance\n}\n\nfunction numberWithCommas(x) {\n    var number = x.toString();\n    var beforePeriod = number.slice(0, number.indexOf(\".\"));\n    var afterPeriod = number.slice(number.indexOf(\".\"), number.length);\n    var numberWithComma = beforePeriod.replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n\n    return numberWithComma + afterPeriod;\n}\n\nfunction showSnackBar(msg) {\n    var $snackbar = $('#snackbar');\n    if ($snackbar.length === 0) {\n        $('body').append('<div id=\"snackbar\"></div>');\n        $snackbar = $('#snackbar');\n    }\n\n    $snackbar.text(msg);\n    $snackbar.addClass(\"show\");\n    setTimeout(function(){\n        $snackbar.removeClass(\"show\");\n    }, 3000);\n}\n\nfunction changeDateFormatKr(date) {\n    var year = date.getFullYear();\n    var month = (1 + date.getMonth());\n    month = month >= 10 ? month : '0' + month;\n    var day = date.getDate();\n    day = day >= 10 ? day : '0' + day;\n\n    var hh = date.getHours();\n    hh = hh >= 10 ? hh : '0' + hh;\n    var mm = date.getMinutes();\n    mm = mm >= 10 ? mm : '0' + mm;\n\n    return  year + '.' + month + '.' + day + \" \" + hh + \":\" + mm;\n}\n\nfunction filterNumberOnly(input) {\n    return (input != null ? input.replace(/[^0-9.]/gi, '') : input);\n}\n\nfunction toDisplayAmount(number) {\n    if (typeof number !== 'number') {\n        number = Number(number);\n    }\n\n    number = number.toFixed(8);\n    number = number.replace(/(0+$)/, \"\");\n\n    if (number.indexOf(\".\") === (number.length - 1)) {\n        number = number.substr(0, number.length - 1)\n    }\n\n    return number;\n}\n\n/**\n * Matched a condiction which created by executing a transaction generated by sealWithSignature()\n * \n * @typedef {Object} SignatureCond\n * @property {string} type string type for 'signature'\n * @property {PubKey} from Public key for whom signed the transaction\n */\nexport type SignatureCond = {\n  type: 'signature',\n  from: PubKey,\n};\n\n/**\n * Matched a condiction which created by executing a transaction generated by sealWithDatetime()\n\n * @typedef {Object} TimestampCond\n * @property {string} type string type 'timestamp'\n * @property {PubKey} from Public key from which `sealWithDatetime()` will be accepted from\n * @property {Date} when The timestamp that will be trigger\n */\nexport type TimestampCond = {\n  type: 'timestamp',\n  from: PubKey,\n  when: Date,\n};\n\n/**\n * Payment consist of payment's amount and payee's public key\n * \n * @typedef {Object} Payment\n * @property {number} amount Amount of difs\n * @property {PubKey} to Public key of the payee\n */\nexport type Payment = {\n  amount: number,\n  to: PubKey,\n};\n\n/**\n * Condition to release a payment\n * \n * @typedef {SignatureCond|TimestampCond} BudgetCond\n */\nexport type BudgetCond = SignatureCond | TimestampCond;\n\n/**\n *  Serialie a Payment into buffer to transport on the network.\n * \n * @private\n */\nfunction serializePayment(payment: Payment): Buffer {\n  const toData = payment.to.toBuffer();\n  const data = Buffer.alloc(8 + toData.length);\n  data.writeUInt32LE(payment.amount, 0);\n  toData.copy(data, 8);\n  return data;\n}\n\n/**\n *  Serialize  a Datetime into buffer to transport on the network.\n * \n * @private\n */\nfunction serializeTime(when: Date): Buffer {\n  const data = Buffer.alloc(8 + 20);\n  data.writeUInt32LE(20, 0); // size of timestamp as u64\n\n  function iso(date) {\n    function pad(number) {\n      if (number < 10) {\n        return '0' + number;\n      }\n      return number;\n    }\n\n    return (\n      date.getUTCFullYear() +\n      '-' +\n      pad(date.getUTCMonth() + 1) +\n      '-' +\n      pad(date.getUTCDate()) +\n      'T' +\n      pad(date.getUTCHours()) +\n      ':' +\n      pad(date.getUTCMinutes()) +\n      ':' +\n      pad(date.getUTCSeconds()) +\n      'Z'\n    );\n  }\n  data.write(iso(when), 8);\n  return data;\n}\n\n/**\n * Serialize a BudgetCond into buffer to transport on the network.\n * \n * @private\n */\nfunction serializeCond(condition: BudgetCond) {\n  switch (condition.type) {\n    case 'timestamp': {\n      const date = serializeTime(condition.when);\n      const from = condition.from.toBuffer();\n\n      const data = Buffer.alloc(4 + date.length + from.length);\n      data.writeUInt32LE(0, 0); // Condition enum = Timestamp\n      date.copy(data, 4);\n      from.copy(data, 4 + date.length);\n      return data;\n    }\n    case 'signature': {\n      const from = condition.from.toBuffer();\n      const data = Buffer.alloc(4 + from.length);\n      data.writeUInt32LE(1, 0); // Condition enum = Signature\n      from.copy(data, 4);\n      return data;\n    }\n    default:\n      throw new Error(`Unknown condition type: ${condition.type}`);\n  }\n}\n\n/**\n * Factory class for transactions to interact with the Budget controller\n */\nexport class BudgetController {\n  /**\n   * Public key that identifies the Budget controller\n   */\n  static get controllerId(): PubKey {\n    return new PubKey('Budget1111111111111111111111111111111111111');\n  }\n\n  /**\n   * The amount of space this controller requires\n   */\n  static get size(): number {\n    return 128;\n  }\n\n  /**\n   * Creates a timestamp condition\n   */\n  static datetimeCond(from: PubKey, when: Date): TimestampCond {\n    return {\n      type: 'timestamp',\n      from,\n      when,\n    };\n  }\n\n  /**\n   * Creates a signature condition\n   */\n  static signatureCond(from: PubKey): SignatureCond {\n    return {\n      type: 'signature',\n      from,\n    };\n  }\n\n  /**\n   * Generates a transaction that transfers difs once any of the conditions are met\n   */\n  static pay(\n    from: PubKey,\n    controller: PubKey,\n    to: PubKey,\n    amount: number,\n    ...conditions: Array<BudgetCond>\n  ): Transaction {\n    const data = Buffer.alloc(1024);\n    let pos = 0;\n    data.writeUInt32LE(0, pos); // NewBudget instruction\n    pos += 4;\n\n    switch (conditions.length) {\n      case 0: {\n        data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay\n        pos += 4;\n\n        {\n          const payment = serializePayment({amount, to});\n          payment.copy(data, pos);\n          pos += payment.length;\n        }\n        const trimmedData = data.slice(0, pos);\n\n        const transaction = SystemController.createNewAccount(\n          from,\n          controller,\n          amount,\n          amount,\n          trimmedData.length,\n          this.controllerId,\n        );\n\n        return transaction.add({\n          keys: [\n            {pubkey: to, isSigner: false, isDebitable: false},\n            {pubkey: controller, isSigner: false, isDebitable: true},\n          ],\n          controllerId: this.controllerId,\n          data: trimmedData,\n        });\n      }\n      case 1: {\n        data.writeUInt32LE(1, pos); // BudgetExpr enum = After\n        pos += 4;\n        {\n          const condition = conditions[0];\n\n          const conditionData = serializeCond(condition);\n          conditionData.copy(data, pos);\n          pos += conditionData.length;\n\n          data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay\n          pos += 4;\n\n          const paymentData = serializePayment({amount, to});\n          paymentData.copy(data, pos);\n          pos += paymentData.length;\n        }\n        const trimmedData = data.slice(0, pos);\n\n        const transaction = SystemController.createNewAccount(\n          from,\n          controller,\n          amount,\n          amount,\n          trimmedData.length,\n          this.controllerId,\n        );\n\n        return transaction.add({\n          keys: [{pubkey: controller, isSigner: false, isDebitable: true}],\n          controllerId: this.controllerId,\n          data: trimmedData,\n        });\n      }\n\n      case 2: {\n        data.writeUInt32LE(2, pos); // BudgetExpr enum = Or\n        pos += 4;\n\n        for (let condition of conditions) {\n          const conditionData = serializeCond(condition);\n          conditionData.copy(data, pos);\n          pos += conditionData.length;\n\n          data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay\n          pos += 4;\n\n          const paymentData = serializePayment({amount, to});\n          paymentData.copy(data, pos);\n          pos += paymentData.length;\n        }\n        const trimmedData = data.slice(0, pos);\n\n        const transaction = SystemController.createNewAccount(\n          from,\n          controller,\n          amount,\n          amount,\n          trimmedData.length,\n          this.controllerId,\n        );\n\n        return transaction.add({\n          keys: [{pubkey: controller, isSigner: false, isDebitable: true}],\n          controllerId: this.controllerId,\n          data: trimmedData,\n        });\n      }\n\n      default:\n        throw new Error(\n          `A maximum of two conditions are support: ${\n            conditions.length\n          } provided`,\n        );\n    }\n  }\n\n  /**\n   * Generates a transaction that transfers difs once both conditions are met\n   */\n  static payOnAll(\n    from: PubKey,\n    controller: PubKey,\n    to: PubKey,\n    amount: number,\n    condition1: BudgetCond,\n    condition2: BudgetCond,\n  ): Transaction {\n    const data = Buffer.alloc(1024);\n    let pos = 0;\n    data.writeUInt32LE(0, pos); // NewBudget instruction\n    pos += 4;\n\n    data.writeUInt32LE(3, pos); // BudgetExpr enum = And\n    pos += 4;\n\n    for (let condition of [condition1, condition2]) {\n      const conditionData = serializeCond(condition);\n      conditionData.copy(data, pos);\n      pos += conditionData.length;\n    }\n\n    data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay\n    pos += 4;\n\n    const paymentData = serializePayment({amount, to});\n    paymentData.copy(data, pos);\n    pos += paymentData.length;\n\n    const trimmedData = data.slice(0, pos);\n\n    const transaction = SystemController.createNewAccount(\n      from,\n      controller,\n      amount,\n      amount,\n      trimmedData.length,\n      this.controllerId,\n    );\n\n    return transaction.add({\n      keys: [{pubkey: controller, isSigner: false, isDebitable: true}],\n      controllerId: this.controllerId,\n      data: trimmedData,\n    });\n  }\n\n  /**\n   * Generates a transaction that applies a timestamp, which could enable a\n   * pending payment to proceed.\n   */\n  static sealWithDatetime(\n    from: PubKey,\n    controller: PubKey,\n    to: PubKey,\n    when: Date,\n  ): Transaction {\n    const whenData = serializeTime(when);\n    const data = Buffer.alloc(4 + whenData.length);\n\n    data.writeUInt32LE(1, 0); // ApplyTimestamp instruction\n    whenData.copy(data, 4);\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: from, isSigner: true, isDebitable: true},\n        {pubkey: controller, isSigner: false, isDebitable: true},\n        {pubkey: to, isSigner: false, isDebitable: false},\n      ],\n      controllerId: this.controllerId,\n      data,\n    });\n  }\n\n  /**\n   * Generates a transaction that applies a signature, which could enable a\n   * pending payment to proceed.\n   */\n  static sealWithSignature(\n    from: PubKey,\n    controller: PubKey,\n    to: PubKey,\n  ): Transaction {\n    const dataLayout = BufferLayout.struct([BufferLayout.u32('instruction')]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 2, // ApplySignature instruction\n      },\n      data,\n    );\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: from, isSigner: true, isDebitable: true},\n        {pubkey: controller, isSigner: false, isDebitable: true},\n        {pubkey: to, isSigner: false, isDebitable: false},\n      ],\n      controllerId: this.controllerId,\n      data,\n    });\n  }\n}\n\n\nfunction getPath(internal_path, external_path) {\n  var bip_path = 0x8000002c;\n  var coin_path = 0x800000c8;\n  var account_path = 0x80000000;\n\n  return bip_path + '/' + coin_path + '/' + account_path + '/' + internal_path + '/' + external_path;\n}\n\nfunction getPathFromAddress(wallet, address) {\n  for (var idx in wallet.internal_addresses) {\n      if (address === wallet.internal_addresses[idx].address) {\n          return this.getPath(1, idx);\n      }\n  }\n\n  for(idx in wallet.external_addresses) {\n      if (address === wallet.external_addresses[idx].address) {\n          return this.getPath(0, idx);\n      }\n  }\n\n  return '';\n}\n\n\nvar buffer = require('buffer');\nvar assert = require('assert');\n\n// var js = require('./js');\n// var $ = require('./preconditions');\n\n\n\nfunction equals(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  var length = a.length;\n  for (var i = 0; i < length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n  * Fill a buffer with a value.\n  *\n  * @param {Buffer} buffer\n  * @param {number} value\n  * @return {Buffer}\n  */\n// function fill(buffer, value) {\n//   PreCondition.checkArgumentType(buffer, 'Buffer', 'buffer');\n//   PreCondition.checkArgumentType(value, 'number', 'value');\n//   var length = buffer.length;\n//   for (var i = 0; i < length; i++) {\n//     buffer[i] = value;\n//   }\n//   return buffer;\n// }\n\n\nconst buffer_1 = require(\"buffer\");\nclass BufferUtil {\n    static fromHex(source) {\n        const data = source.match(/.{1,2}/g).map(x => parseInt(x, 16));\n        return new Uint8Array(data);\n    }\n    static fromBase64(source) {\n        return Uint8Array.from(buffer_1.Buffer.from(source, 'base64'));\n    }\n    static fromString(source) {\n        const buffer = new ArrayBuffer(source.length);\n        const view = new DataView(buffer);\n        for (let i = 0; i < source.length; i++) {\n            view.setUint8(i, source.charCodeAt(i));\n        }\n        return new Uint8Array(buffer);\n    }\n    static toString(source) {\n        const data = [];\n        source.forEach(x => {\n            data.push(String.fromCharCode(x));\n        });\n        return data.join('');\n    }\n    static toHex(sources) {\n        const data = [];\n        sources.forEach(x => {\n            data.push(x.toString(16).padStart(2, '0'));\n        });\n        return data.join('');\n    }\n    static toBase64(sources) {\n        return buffer_1.Buffer.from(sources).toString('base64');\n    }\n    static concat(a, b) {\n        const c = new Uint8Array(a.length + b.length);\n        c.set(a);\n        c.set(b, a.length);\n        return c;\n    }\n}\n\n\nfunction binarySearch(sortedArray, item) {\n  let lowIdx = 0;\n  let highIdx = sortedArray.length - 1;\n  while (lowIdx <= highIdx) {\n      const midIdx = Math.floor((lowIdx + highIdx) / 2);\n      if (sortedArray[midIdx] === item) {\n          return midIdx;\n      }\n      else if (sortedArray[midIdx] < item) {\n          lowIdx = midIdx + 1;\n      }\n      else {\n          highIdx = midIdx - 1;\n      }\n  }\n  return null;\n}","// @flow\n\nimport {BusAccount} from './bvm-acct';\nimport {PubKey} from './bvm-addr';\nimport {ControllerLoader} from './dapp-mounter';\nimport type {Connection} from './netutility';\n\n////////////////////////////////////////////////////////////////////////////////////\n// const request = require(\"request\");\nconst path = require('path');\n\nconst Web3 = require('web3');\n//const AbiCoder = require('web3-eth-abi');\n\nconst Promise = require(\"bluebird\");\n// const truffle_contract = require('truffle-contract');\nconst assert = require('assert');\n// const tracer = require('../EVM2Code');\nconst fs = require('fs');\nconst locks = require('locks');\n// mutex\nconst mutex = locks.createMutex();\nconst async = require('async');\n\nconst g_cwd = \"connection/ethereum\";\nvar g_data_feedback = false;\n\n/// the file that used to keep exploit script\nconst g_exploit_path = \"./exploit.txt\";\n\n/// json file\nlet g_target_artifact;\nlet g_attack_artifact;\n// truffle-contract abstractions\nlet g_targetContract;\nlet g_attackContract;\n\n// web3 abstractions\nlet web3;\nlet Provider;\nlet g_account_list = [];\n/// the bookkeeping variable abi\nlet g_bookKeepingAbi;\n\nlet g_attackStmt_set;\nlet g_targetStmt_set;\n// tracer abstractions at instruction level\nlet g_attackIns_map;\nlet g_targetIns_map;\n// static dependency\nlet g_staticDep_attack;\nlet g_staticDep_target;\n\n/// the gas amount\nconst gasMax = 8000000000;\n/// dynamci array\nconst dyn_array_min = 1;\nconst dyn_array_max = 5;\n/// the maximum length of seed_callSequence\nconst sequence_maxLen = 4;\n\n/// the call sequence to be executed\nlet g_callSequen_list = [];\n/// another new call seqeunce\nlet g_callSequen_start = false;\n\n/// the current executed call, don't initialized because it is assigned again\n/// we will mutate the inputs of this call function \nlet g_lastCall_exec;\n/// the current index in g_callSequen_cur, it corresponds to \"g_lastCall_exec\"\nlet g_callIndex_cur = 0;\n/// the executed call sequence\nlet g_callSequen_cur = [];\n/// the trace of a transaction\nlet g_trans_stmt_trace = [];\n/// the trace of a call sequence\nlet g_sequen_stmt_trace = [];\n/// the key is i^th call in sequence, the value is read/write variable\nlet g_stmt_read_map = new Map();\nlet g_stmt_write_map = new Map();\n/// the set of dynamic dependencies in a call sequence\nlet g_sequen_depen_set = new Set();\n/// the set of all dynamic dependencies in this contract until now\nlet g_contra_depen_set = new Set();\n\n/// the hash of previous transactions\nlet g_pre_txHash_set = new Set();\nlet g_startTime, g_endTime;\nlet g_timeDiff;\n\n/// the current call that is executed\nlet g_callFun_cur;\n/// the candidate abi that can be used to start transaction\nlet g_cand_sequence = [];\nlet g_fuzzing_finish = false;\n\n/// the account pools\nlet g_from_account;\n/// the send and call statements\nlet g_send_call_set;\n/// whether it has static control dependencies or write variable\nlet g_send_call_found;\n\nlet  g_fuzz_start_time = 0;\nconst FUZZ_TIME_SCALE = 10 * 60 * 1000;\n\nfunction unlockAccount(){\n  /// it is initialized by the blockchain, \n  /// for example, /home/hjwang/Tools/SCFuzzer/test_geth/data/keystore\n  var g_from_account;\n  web3.eth.getAccounts().then(e => {\n    g_from_account = e[0];\n    g_account_list.push(e[0]);\n    console.log(\"Account[0]: \" + g_from_account);\n  }).then(() => {\n    /// unlock initial user, which is also miner account\n    web3.eth.personal.unlockAccount(g_from_account, \"123456\", 200 * 60 * 60)\n      .then(() => {\n        console.log('Account unlocked!');\n      })\n      .catch(() => {\n        console.log('Account unlock failed!');\n      });\n  }).catch(() => {\n    console.log('Cannot read account info!');\n  });\n}\n\nfunction setProvider(httpRpcAddr){\n  Provider = new Web3.providers.HttpProvider(httpRpcAddr);\n  web3 = new Web3(new Web3.providers.HttpProvider(httpRpcAddr));\n  assert(web3);\n}\n\nfunction test_deployed(artifact_path){\n  let artifact = require(path.relative(g_cwd, artifact_path));\n  let network_id = Object.keys(artifact[\"networks\"])[0];\n  return network_id!=undefined;\n}\n\n////////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Factory class for transactions to interact with a controller loader\n */\nexport class NativeControllerLoader {\n  /**\n   * Public key that identifies the NativeControllerLoader\n   */\n  static get controllerId(): PubKey {\n    return new PubKey('NativeLoader1111111111111111111111111111111');\n  }\n\n  /**\n   * Loads a native controller\n   *\n   * @param connection The connection to use\n   * @param payer System account that pays to load the controller\n   * @param controllerName Name of the native controller\n   */\n  static load(\n    connection: Connection,\n    payer: BusAccount,\n    controllerName: string,\n  ): Promise<PubKey> {\n    const bytes = [...Buffer.from(controllerName)];\n    const controller = new BusAccount();\n    return ControllerLoader.load(\n      connection,\n      payer,\n      controller,\n      NativeControllerLoader.controllerId,\n      bytes,\n    );\n  }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////\nasync function get_instance(artifact_path){\n  // console.log(artifact_path);\n  let artifact = require(path.relative(g_cwd, artifact_path));\n  //let network_id = Object.keys(artifact[\"networks\"])[0];\n  // let conf = {\n  //   contract_name:artifact[\"contractName\"],\n  //   abi:  artifact[\"abi\"],                     // Array; required.  Application binary interface.\n  //   unlinked_binary: artifact[\"bytecode\"],       // String; optional. Binary without resolve library links.\n  //   address: artifact[\"networks\"][network_id][\"address\"],               // String; optional. Deployed address of contract.\n  //   network_id: parseInt(network_id),            // String; optional. ID of network being saved within abstraction.\n  //   default_network: parseInt(network_id)       // String; optional. ID of default network this abstraction should use.\n  // };\n  //console.log(artifact);\n  let MyContract = truffle_contract(artifact);\n  //console.log(MyContract);\n  MyContract.setProvider(Provider);\n  let instance = await MyContract.deployed();\n  //console.log(\"instance: \" + instance);\n  return instance;\n}\n\n/// load some static information for the dynamic analysis. e.g., fuzzing\nasync function load(targetPath, attackPath, targetSolPath, attackSolPath){\n  g_attackContract = await get_instance(attackPath);\n  g_targetContract = await get_instance(targetPath);\n  g_attack_artifact = require(path.relative(g_cwd, attackPath));\n  g_target_artifact = require(path.relative(g_cwd, targetPath));\n  \n  /// add the attack contract address\n  g_account_list.push(g_attackContract.address);\n  /// find bookkeeping variable\n  g_bookKeepingAbi = await findBookKeepingAbi(g_targetContract.abi);\n  /// all the possible abi, then we use to synthesize the call sequence\n  g_cand_sequence = [];\n  await findCandSequence(g_targetContract.abi, g_attackContract.abi);\n\n  /// the set of statements, which may be used for computing experimental results\n  g_attackStmt_set = await buildStmtSet(g_attack_artifact.sourcePath,\n                                               g_attack_artifact.deployedSourceMap,\n                                               g_attack_artifact.source);\n  g_targetStmt_set = await buildStmtSet(g_target_artifact.sourcePath,\n                                               g_target_artifact.deployedSourceMap,\n                                               g_target_artifact.source);     \n  \n  /// the map that the instruction corresponds to the statement \n  /// the form: [ '239JUMPI', 'Attack_SimpleDAO0.sol:1' ]\n  /// where 239 is the offset, JUMPI is the instruction\n  g_attackIns_map = await buildInsMap(g_attack_artifact.sourcePath,\n                                             g_attack_artifact.deployedBytecode,\n                                             g_attack_artifact.deployedSourceMap,\n                                             g_attack_artifact.source);\n  g_targetIns_map = await buildInsMap(g_target_artifact.sourcePath,\n                                             g_target_artifact.deployedBytecode,\n                                             g_target_artifact.deployedSourceMap,\n                                             g_target_artifact.source);\n\n  /// the static dependencies\n  /// The form:\n  // { Read: { 'SimpleDAO.sol:17': [ 'credit' ] },\n  //  Write: { 'SimpleDAO.sol:8': [ 'owner' ] },\n  //  CDepen: { 'SimpleDAO.sol:21': [ 'SimpleDAO.sol:22' ] } }\n  // console.log(\"arriving here\");\n  g_staticDep_attack = await buildStaticDep(attackSolPath);\n  g_staticDep_target = await buildStaticDep(targetSolPath);\n\n  g_send_call_set = await buildMoneySet(targetSolPath);\n  g_send_call_found = await buildRelevantDepen(g_staticDep_target, g_send_call_set);\n  console.log(g_send_call_found);\n\n  // /// clear the exploit script\n  // if(fs.existsSync(g_exploit_path)){\n  //   fs.unlinkSync(g_exploit_path);\n  // }\n\n  return {\n   accounts: g_account_list,\n   attack_adds: g_attackContract.address,\n   target_adds: g_targetContract.address,\n   attack_abi: g_attackContract.abi,\n   target_abi: g_targetContract.abi\n  };\n}\n\nfunction buildRelevantDepen(staticDep_target, send_call_set){\n  var send_call_found = build_relevant_depen(staticDep_target, send_call_set);\n  return send_call_found;\n} \n\nconst  build_relevant_depen = (staticDep_target, send_call_set) => {\n  var send_call_found = new Set();\n\n  // var write_target_map = staticDep_target[\"Write\"];\n  // var cd_target_map = staticDep_target[\"CDepen\"];\n\n  // for(var step of send_call_set){\n  //   if(!write_target_map.hasOwnProperty(step) && !cd_target_map.hasOwnProperty(step)){\n  //     send_call_found.add(step);\n  //   }\n  // }\n\n  return send_call_found; \n}\n\nfunction buildMoneySet(targetSolPath){\n  var send_call_set = build_sendCall_set(targetSolPath);\n  return send_call_set;\n}\n\nfunction buildStaticDep(fileName){\n  var execSync = require('child_process').execSync;\n  var cmdStr = \"python3 ./connection/buildDepen.py \" + fileName;\n  var output = execSync(cmdStr);\n  var staticDep = JSON.parse(output);\n  return staticDep;\n}\n\n\n/// the seed for dynamic fuzzing\nasync function seed() {\n  if (g_targetContract === undefined) {\n    throw \"Target contract is not deployed!\";\n  }\n  if (g_attackContract === undefined) {\n    throw \"Attack contract is not deployed!\";\n  }\n  // we only generate a call sequence\n  let callFun_list;\n  if(g_data_feedback){\n    callFun_list = await seed_callSequence();\n  }\n  else{\n    callFun_list = await seed_callSequence_withoutData();\n  }\n  // Execute the seed call sequence\n  mutex.lock(async function() {\n    try{\n      /// the call sequence to be executed\n      g_callSequen_list.push(callFun_list);\n      g_callSequen_start = true;\n      await exec_sequence_call();\n    }\n    catch (e) {\n      console.log(e);\n    }\n    finally{\n      mutex.unlock();\n    }\n  });\n\n  let execResult_list = \"successful!\";\n  return {\n    callFuns: callFun_list,\n    execResults: execResult_list\n  };\n}\n\n/// it will be executed after each transaction is executed\nasync function fuzz(txHash, ins_trace) {\n  const getTransaction = Promise.promisify(web3.eth.getTransaction);\n\n  if (g_attackContract === undefined) {\n    throw \"Attack contract is not loaded!\";\n  }\n  if (g_targetContract === undefined) {\n    throw \"Target contract is not loaded!\";\n  }\n\n  mutex.lock(async function() {\n    /// different transaction hash code, it is a string\n    if(!g_pre_txHash_set.has(txHash)){\n      /// store current txHash as previous txHash\n      g_pre_txHash_set.add(txHash);\n      try{\n        /// this is used to get the input of transaction \n        // let transObj = await getTransaction(txHash);\n        // console.log(\"receive: \"+ transObj.input);\n     \n        /// when attack_target == 0, it is on attack contract\n        /// when attack_target == 1, it is on target contract\n        var attack_target = 0;\n        /// ins_trace is the instrcution trace\n        /// g_stmt_trace is list of line nunmber trace\n        if(g_callFun_cur.to == g_targetContract.address){\n          attack_target = 1;\n        }\n        g_trans_stmt_trace = await buildTraceMap(ins_trace,\n                                                        g_attackIns_map,\n                                                        g_targetIns_map,\n                                                        attack_target);\n\n        // for(var stmt_trace of g_trans_stmt_trace){\n        //   if(g_send_call_found.has(stmt_trace)){\n        //     console.log(Date.now() - g_fuzz_start_time);\n        //     g_fuzzing_finish = true;\n        //     return \"Oracles are violated!\";\n        //   }\n        // }\n        /// the read/write variable in this transaction\n        /// we use it to switch the order of sequence\n        var WR_set = await buildWRSet(g_trans_stmt_trace,\n                                             g_staticDep_attack,\n                                             g_staticDep_target);\n        g_stmt_write_map[g_callIndex_cur -1] = WR_set[0];\n        g_stmt_read_map[g_callIndex_cur -1] = WR_set[1];\n\n        /// concate the transaction tract into sequence trace\n        g_sequen_stmt_trace = g_sequen_stmt_trace.concat(g_trans_stmt_trace);\n        /// the dynamic dependencies in the g_stmt_trace\n        g_sequen_depen_set = await buildDynDep(g_sequen_stmt_trace,\n                                                      g_staticDep_attack,\n                                                      g_staticDep_target);\n\n\n\n        /// before executing next transaction, we first mutate the just executed transaction\n        if(g_data_feedback){\n          await determine_funMutation();\n          await determine_sequenMutation();\n        }\n        else{\n          await determine_funMutation_withoutData();\n        }\n\n        /// execute a function call\n        await exec_sequence_call();\n      }\n      catch (e) {\n        console.log(e);\n      }\n      finally{\n        mutex.unlock();\n      }\n    }\n  });     \n}\n\nfunction buildDynDep(trace, staticDep_attack, staticDep_target){\n  var dynamicDep = buildDynamicDep(trace, staticDep_attack, staticDep_target);\n  return dynamicDep;\n}\n\nconst buildDynamicDep = (trace, staticDep_attack, staticDep_target) => {\n  var dynamicDep = new Set();\n  return dynamicDep;\n}\n\nconst byteToTrace = (ins_list, byteToSrc_attack, byteToSrc_target, attack_target) => {\n  var trace_list = [];\n  return trace_list;\n}\n\nfunction buildWRSet(stmt_trace, staticDep_attack, staticDep_target){\n  var WR_set = trace_WR(stmt_trace, staticDep_attack, staticDep_target);\n  return WR_set;\n}\n\nconst trace_WR = (stmt_trace, staticDep_attack, staticDep_target) => {\n  var stmt_write_set = new Set();\n  var stmt_read_set = new Set();\n  return [stmt_write_set, stmt_read_set];\n}\n\n\nfunction buildTraceMap(ins_list, byteToSrc_attack, byteToSrc_target, attack_target) {\n  var trace_list = byteToTrace(ins_list, byteToSrc_attack, byteToSrc_target, attack_target);\n  return trace_list;\n}\n\nconst json_parse = (fileName, srcmap, srccode) =>{\n  /// the window system may use '\\r\\n' as newline, but getLineFromPos would take them as two lines\n  // srccode = srccode.split('\\r\\n').join('\\n');\n  // srccode = srccode.split('\\n\\r').join('\\n');\n  // /// truncate the prefix of the path\n  // fileName = fileName.slice(fileName.lastIndexOf('/') +1);\n  // /// the first \"\" is set undefined (map ([s, l, f, j])), l,f,j does not exist.\n  // const src_number = srcmap\n  //       .split(\";\")\n  //       .map(l => l.split(\":\"))\n  //       .map(([s, l, f, j]) => ({ s: s === \"\" ? undefined : s, l, f, j }))\n  //       .reduce(\n  //         ([last, ...list], {s, l, f, j }) => [\n  //           {\n  //             s: parseInt(s || last.s, 10),\n  //             l: parseInt(l || last.l, 10),\n  //             f: parseInt(f || last.f, 10),\n  //             j: j || last.j\n  //           },\n  //           last,\n  //           ...list\n  //         ],\n  //         [{}]\n  //       )\n  //       .reverse()\n  //       .slice(1)\n  //       .map(\n  //         ({ s, l, f, j }) => `${fileName}:${getLineFromPos(srccode, s)}`\n  //       );\n  // // writeSrcIndex_list(src_number);\n  // return src_number;\n}\n\nconst stmtCollection = (src_number) =>{\n  var stmt_set = new Set();\n\tsrc_number.forEach(function(value, key, map){\n\t\tstmt_set.add(value);\n\t});\n\treturn stmt_set;\n}\n\n\nconst build_sendCall_set = (targetSolPath) => {\n  var send_call_set = new Set();\n  // var srccode = fs.readFileSync(targetSolPath, \"utf-8\"); \n  // srccode = srccode.split('\\r\\n').join('\\n');\n  // srccode = srccode.split('\\n\\r').join('\\n');\n  // var code_list = srccode.split('\\n');\n  // var lineNum = 1;\n  // for (var line of code_list){\n  //   if(line.indexOf(\"send(\") != -1 || line.indexOf(\"send (\") != -1 || line.indexOf(\"call.value\") != -1){\n  //     var content =  targetSolPath + \":\" + lineNum;\n  //     var lastIndex = content.lastIndexOf(\"/\");\n  //     content = content.slice(lastIndex +1);\n  //     send_call_set.add(content);\n  //   }\n  //   lineNum++;\n  // }\n  return send_call_set;\n}\n\n/// each byte to the source code\nconst byteToInstIndex = (src_number, binary) => {\n  const byteToSrc = new Map();\n  /// \"0x\" is removed from binary\n  // let byteIndex = 0;\n  // let instIndex = 0;\n  // /// for the binary code\n  // const binmap = Buffer.from(binary.substring(2), \"hex\");\n  // while (byteIndex < binmap.length) {\n  //   const length = instructionLength(binmap[byteIndex]);\n  //   if(opCodeToString[binmap[byteIndex]] != undefined && src_number[instIndex] != undefined){\n  //     var key = byteIndex + opCodeToString[binmap[byteIndex]];\n  //     var value = src_number[instIndex];\n  //     byteToSrc[key] = value;\n  //   }\n  //   byteIndex += length;\n  //   instIndex += 1;\n  // }\n  // writeByteIndex_list(byteToSrc);\n  return byteToSrc;\n}\n\nfunction  buildInsMap(fileName, binary, srcmap, srccode) {\n  var src_number = json_parse(fileName, srcmap, srccode);\n  /// compute each instruction to its line number\n  var byteToSrc = byteToInstIndex(src_number, binary);\n  /// compute multiple instructions to their line number\n  /// we do not use multiple instructions to the line number again, \n  /// because it is difficult to recognize the seperator instruction, specially not executed completely due to gas limit\n  // var mulToSrc = mulbytesToSrcCode(byteToSrc);\n  // return mulToSrc; \n  return byteToSrc\n}\n\n\nfunction buildStmtSet(fileName, srcmap, srccode) {\n    var src_number = json_parse(fileName, srcmap, srccode);\n    var stmt_set = stmtCollection(src_number);\n    return stmt_set; \n  }\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////////","/**\n * @flow\n */\n\n\n\n////////////////////////////////////////////////////////////////////////////////////////////\n\n/// conver scientific number to string\nfunction uintToString(num){\n  var num_str = \"\" + num;\n  /// scientific number\n  var index = num_str.indexOf(\"+\");\n  if(index != -1){\n    var result = num_str[0];\n    var power_len = parseInt(num_str.slice(index +1), 10);\n    var power_index = 0;\n    while(power_index < power_len){\n      /// num_str[index-1:] is 'e+...'\n      if((power_index +2) < (index -1)){\n        result += num_str[power_index +2];\n      }\n      else{\n        result += '0';\n      }\n      power_index += 1;\n    }\n    return result;\n  }\n  else{\n    return num_str;\n  }\n}\n\n/// modify the 'input_orig_list' at 'input_index' with 'unum_diff' \nfunction modify_uint(input_orig_list, input_index, unum_diff){\n  var input_orig = input_orig_list[input_index];\n  if (typeof input_orig === 'string' || input_orig instanceof String){\n    /// it is primitive, e.g., uint\n    var input_orig_int = parseInt(input_orig, 10);\n    if(typeof unum_diff === \"number\" || unum_diff instanceof Number){\n      /// modify with the instant value\n      var input_modify = input_orig_int + unum_diff;\n      if(input_modify !== input_orig_int){\n        if(input_modify >= 1){\n          var modify_str = uintToString(input_modify)\n          return modify_str;\n        }\n        else{\n          return undefined;\n        }        \n      }\n      else{\n        return undefined;\n      }\n    }\n    else if(typeof unum_diff === 'string' || unum_diff instanceof String){\n      /// modify with 'xxx' times\n      var unum_diff_int = parseFloat(unum_diff, 10);\n      var input_modify = input_orig_int * unum_diff;\n      if(input_modify !== input_orig_int){\n        var modify_int =  Math.round(input_modify)\n        if(modify_int >= 1){\n          var modify_str = uintToString(Math.round(input_modify));\n          return modify_str;   \n        }\n        else{\n          return undefined;\n        }\n      }\n      else{\n        return undefined;\n      }\n    }\n  }\n  else if (input_orig instanceof Array){\n    /// generate a copy to mutate, otherwise the original input will be modified\n    input_orig = input_orig.slice()\n    /// select an element to mutate\n    var index = randomNum(0, input_orig.length);\n    var input_orig_int = parseInt(input_orig[index], 10);\n    if(typeof unum_diff === \"number\" || unum_diff instanceof Number){\n      var input_modify = input_orig_int + unum_diff;\n      if(input_modify !== input_orig_int){\n        if(input_modify >= 1){\n          var modify_str = uintToString(input_modify);\n          input_orig[index] = modify_str;\n        }\n        else{\n          return undefined;\n        }   \n        return input_orig;     \n      }\n      else{\n        return undefined;\n      }\n    }\n    else if(typeof unum_diff === 'string' || unum_diff instanceof String){\n      var unum_diff_int = parseFloat(unum_diff, 10);\n      var input_modify = input_orig_int * unum_diff;\n      if(input_modify !== input_orig_int){\n        var modify_int =  Math.round(input_modify)\n        if(modify_int >= 1){\n          var modify_str = uintToString(Math.round(input_modify));\n          input_orig[index] = modify_str;   \n        }\n        else{\n          input_orig[index] = '1';\n        }\n        return input_orig;         \n      }\n      else{\n        return undefined;\n      }\n    }\n  }\n  else{\n    /// no change, it needs to proceed further\n    return undefined;\n  }\n}\n\nasync function modify_callInput_uint(call, unum_diff) {\n  var param_list_set = new Set();\n  var input_type_list = call.abi.inputs;\n  var input_orig_list = call.param;\n  var param_i = 0;\n  var param_len = input_type_list.length;\n  /// for each element in input_orig_list to mutate\n  while(param_i < param_len){\n    /// the generated parameters\n    var param_list = [];\n    var modify_found = false;\n    var param_j = 0;\n    while(param_j < param_len){\n      /// we only consider the element that larger than param_i\n      if(modify_found == false && param_j >= param_i){\n        var input_type = input_type_list[param_j];\n        if(input_type.type.indexOf('uint') == 0){\n          var uint_param = modify_uint(input_orig_list, param_j, unum_diff);\n          if(uint_param !== undefined){\n            param_list.push(uint_param);\n            modify_found = true;\n          }\n          /// param_i can be speed up\n          param_i = param_j +1;\n        }\n        else{\n          /// it is not unit type\n          param_list.push(input_orig_list[param_j]);\n        }\n      }\n      else{\n        param_list.push(input_orig_list[param_j]);\n      }\n      param_j += 1;\n    } \n    /// has modified the element \n    if(modify_found){\n      param_list_set.add(param_list);\n    }\n    else{\n      /// there is no candidation for modification\n      break;\n    }\n  }\n  /// if there is no modification, param_list_set is empty\n  return param_list_set;\n}\n////////////////////////////////////////////////////////////////////////////////////////////\n\n\nimport assert from 'assert';\nimport BN from 'bn.js';\nimport * as BufferLayout from 'buffer-layout';\n\nimport * as Layout from './buffer-cntl';\nimport {BusAccount} from './bvm-acct';\nimport {PubKey} from './bvm-addr';\nimport {SystemController} from './sys-dapp';\nimport {Transaction, TxOperation} from './tx-dapp';\nimport type {TxnSignature} from './tx-dapp';\nimport {launchThenAcknowledgeTx} from './util/launch-then-acknowledge-tx';\nimport type {Connection} from './netutility';\n\n/**\n * Some amount of tokens\n */\nexport class AssetCount extends BN {\n  /**\n   * Convert to Buffer representation\n   */\n  convertToBuffer(): Buffer {\n    const zero_pad_array = super.toArray().reverse();\n    const new_buffer = Buffer.from(zero_pad_array);\n    if (new_buffer.length === 8) {\n      return new_buffer;\n    }\n    assert(new_buffer.length < 8, 'AssetCount beyond limitation');\n\n    const zeroPad = Buffer.alloc(8);\n    new_buffer.copy(zeroPad);\n    return zeroPad;\n  }\n\n  /**\n   * Construct a AssetCount from Buffer representation\n   */\n  static createFromBuffer(buffer: Buffer): AssetCount {\n    assert(buffer.length === 8, `Invalid buffer length: ${buffer.length}`);\n    return new BN(\n      [...buffer]\n        .reverse()\n        .map(i => `00${i.toString(16)}`.slice(-2))\n        .join(''),\n      16,\n    );\n  }\n}\n\n/**\n * Information about a asset\n */\ntype AssetDetail = {|\n  /**\n   * Total supply of tokens\n   */\n  totalSupply: AssetCount,\n\n  /**\n   * Number of base 10 digits to the right of the decimal place\n   */\n  decimalsPosition: number,\n\n  /**\n   * Descriptive name of this asset\n   */\n  name: string,\n\n  /**\n   * Symbol for this asset\n   */\n  symbol: string,\n|};\n\n/**\n * @private\n */\nconst AssetDetailLayout = BufferLayout.struct([\n  Layout.uint64('totalSupply'),\n  BufferLayout.u8('decimalsPosition'),\n  Layout.rustString('name'),\n  Layout.rustString('symbol'),\n]);\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////\nasync function modify_callInput_uint_meaningful(call, unum_diff) {\n  /// the generated parameters\n  var param_list = [];\n  var input_type_list = call.abi.inputs;\n  var input_orig_list = call.param;\n  var param_i = 0;\n  var param_len = input_type_list.length;\n  var modify_found = false;\n  /// for each element in input_orig_list to mutate\n  while(param_i < param_len){\n    var input_type = input_type_list[param_i];\n    if(input_type.type.indexOf('address') == 0){\n      var adds_param = gen_address(input_type.type);\n      if(adds_param != input_orig_list[param_i]){\n        param_list.push(adds_param);\n        modify_found = true;\n      }\n      else{\n        param_list.push(input_orig_list[param_i]);\n      }\n    }\n    else if(input_type.type.indexOf('uint') == 0){\n      var uint_param = modify_uint(input_orig_list, param_i, unum_diff);\n      if(uint_param !== undefined){\n        if(uint_param == 'NaN'){\n          console.log('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa');\n        }\n        param_list.push(uint_param);\n        modify_found = true;\n      }\n      else{\n        param_list.push(input_orig_list[param_i]);\n      }\n    }\n    else{\n      param_list.push(input_orig_list[param_i]);\n    }\n    param_i += 1;\n  }\n  if(modify_found){\n    return [true, param_list];\n  }\n  else{\n    return [false, undefined];\n  }\n}\n\nasync function modify_callGas_meaningful(call, gas_diff) {\n  var times = parseFloat(gas_diff, 10);\n  var gas = Math.ceil(parseInt(call.gas, 10) * times);\n  if(gas < gasMax){\n    return [true, gas];\n  }\n  else{\n    return false;\n  }\n}\n\n\nasync function gen_callGas(gas_min, gas_max){\n  var gas_int = randomNum(gas_min, gas_max);\n  var gas_limit = uintToString(gas_int);\n  return gas_limit;\n}\n\n/// generate a call function based on the abi\nasync function gen_callFun(abi) {\n  var parameters = await gen_callInput(abi, 0, undefined);\n  var gasLimit = await gen_callGas(gasMin, gasMax);\n  var callFun = {\n    from: account_list[0],\n    to: abi.name.indexOf('vultron_') !== -1 ? attack_con.options.address : target_con.options.address,\n    abi: abi,\n    gas: gasLimit,\n    param: parameters\n  }\n  return callFun;\n}\n\n\nasync function modify_callFun_gas(call, gas_min, gas_max){\n  var gasLimit = await gen_callGas(gas_min, gas_max);\n  var callFun = {\n    from: call.from,\n    to: call.to,\n    abi: call.abi,\n    gas: gasLimit,\n    param: call.param.slice()\n  }\n  return callFun;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Information about a asset account\n */\ntype AssetAccountDetail = {|\n  /**\n   * The kind of asset this account holds\n   */\n  publickeyOfAsset: PubKey,\n\n  /**\n   * Owner of this account\n   */\n  publickeyOfOwner: PubKey,\n\n  /**\n   * Amount of assets this account holds\n   */\n  amountOfAsset: AssetCount,\n\n  /**\n   * The source account for the assets.\n   *\n   * If `source` is null, the source is this account.\n   * If `source` is not null, the `amount` of assets in this account represent\n   * an allowance of assets that may be transferred from the source account\n   */\n  publickeyOfSourceAccount: null | PubKey,\n\n  /**\n   * New amount of assets this delegate account was authorized to spend\n   * If `source` is null, originalAmount is zero\n   */\n  originalAmountOfAsset: AssetCount,\n|};\n\n/**\n * @private\n */\nconst TokenAccountDetailLayout = BufferLayout.struct([\n  Layout.pubKey('publickeyOfAsset'),\n  Layout.pubKey('publickeyOfOwner'),\n  Layout.uint64('amountOfAsset'),\n  BufferLayout.u8('sourceOption'),\n  Layout.pubKey('publickeyOfSourceAccount'),\n  Layout.uint64('originalAmountOfAsset'),\n]);\n\ntype AssetAndPubKey = [Token, PubKey]; // This type exists to workaround an esdoc parse error\n\n/**\n * The built-in asset controller\n */\nexport const SYSTEM_TOKEN_CONTROLLER_ID = new PubKey(\n  'Token11111111111111111111111111111111111111',\n  // 'BRC42TKNAAA60000000000000006',\n);\n\n/**\n * An ERC20-like Token\n */\nexport class Asset {\n  /**\n   * @private\n   */\n  connection: Connection;\n\n  /**\n   * The public key identifying this asset\n   */\n  assetId: PubKey;\n\n  /**\n   * Controller Identifier for the Token controller\n   */\n  controllerId: PubKey;\n\n  /**\n   * Create a Token object attached to the specific asset\n   *\n   * @param connection The connection to use\n   * @param assetId Public key of the asset\n   * @param controllerId Optional asset controllerId, uses the system controllerId by default\n   */\n  constructor(\n    connection: Connection,\n    assetId: PubKey,\n    controllerId: PubKey = SYSTEM_TOKEN_CONTROLLER_ID,\n  ) {\n    Object.assign(this, {connection, assetId, controllerId});\n  }\n\n  /**\n   * Create a new Asset\n   *\n   * @param connection The connection to use\n   * @param ownerOfAsset User account that will own the returned Token BusAccount\n   * @param totalSupply Total supply of the new asset\n   * @param assetName Descriptive name of this asset\n   * @param assetSymbol Symbol for this asset\n   * @param assetDecimals Location of the decimal place\n   * @param controllerId Optional asset controllerId, uses the system controllerId by default\n   * @return Token object for the newly minted asset, Public key of the Token BusAccount holding the total supply of new tokens\n   */\n  static async createNewAsset(\n    connection: Connection,\n    ownerOfAsset: BusAccount,\n    totalSupply: AssetCount,\n    assetName: string,\n    assetSymbol: string,\n    assetDecimals: number,\n    controllerId: PubKey = SYSTEM_TOKEN_CONTROLLER_ID,\n  ): Promise<AssetAndPubKey> {\n    const assetAccount = new BusAccount();\n    const asset = new Asset(connection, assetAccount.pubKey, controllerId);\n    const publickeyOfStoreAssetAccount = await asset.createNewAssetAccount(ownerOfAsset, null);\n    let transaction;\n\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      Layout.uint64('totalSupply'),\n      BufferLayout.u8('assetDecimals'),\n      Layout.rustString('assetName'),\n      Layout.rustString('assetSymbol'),\n    ]);\n\n    let data = Buffer.alloc(1024);\n    {\n      const encodeLength = dataLayout.encode(\n        {\n          instruction: 0, // NewToken instruction\n          totalSupply: totalSupply.convertToBuffer(),\n          assetDecimals,\n          assetName,\n          assetSymbol,\n        },\n        data,\n      );\n      data = data.slice(0, encodeLength);\n    }\n\n\n    // Allocate memory for the assetAccount account\n    transaction = SystemController.createNewAccount(\n      ownerOfAsset.pubKey,\n      assetAccount.pubKey,\n      1,\n      0,\n      1 + data.length,\n      controllerId,\n    );\n    await launchThenAcknowledgeTx(connection, transaction, ownerOfAsset);\n\n    transaction = new Transaction().add({\n      keys: [\n        {pubkey: assetAccount.pubKey, isSigner: true, isDebitable: false},\n        {pubkey: publickeyOfStoreAssetAccount, isSigner: false, isDebitable: true},\n      ],\n      controllerId,\n      data,\n    });\n\n    await launchThenAcknowledgeTx(\n      connection,\n      transaction,\n      ownerOfAsset,\n      assetAccount,\n    );\n\n    return [asset, publickeyOfStoreAssetAccount];\n  }\n\n  /**\n   * Create a new and empty asset account.\n   *\n   * This account may then be used as a `transferAsset()` or `approve()` destination\n   *\n   * @param ownerAccount User account that will own the new asset account\n   * @param bvmAddrOfSourceAccount If not null, create a delegate account that when authorized\n   *               may transfer assets from this `source` account\n   * @return Public key of the new empty asset account\n   */\n  async createNewAssetAccount(\n    ownerAccount: BusAccount,\n    bvmAddrOfSourceAccount: null | PubKey = null,\n  ): Promise<PubKey> {\n    const assetAccount = new BusAccount();\n    let transaction;\n    const dataLayout = BufferLayout.struct([BufferLayout.u32('instruction')]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 1, // NewTokenAccount instruction\n      },\n      data,\n    );\n    // Allocate memory for the asset\n    transaction = SystemController.createNewAccount(\n      ownerAccount.pubKey,\n      assetAccount.pubKey,\n      1,\n      0,\n      1 + TokenAccountDetailLayout.span,\n      this.controllerId,\n    );\n    await launchThenAcknowledgeTx(this.connection, transaction, ownerAccount);\n    // Initialize the asset account\n    const keys = [\n      {pubkey: assetAccount.pubKey, isSigner: true, isDebitable: true},\n      {pubkey: ownerAccount.pubKey, isSigner: false, isDebitable: false},\n      {pubkey: this.assetId, isSigner: false, isDebitable: false},\n    ];\n    if (bvmAddrOfSourceAccount) {\n      keys.push({pubkey: bvmAddrOfSourceAccount, isSigner: false, isDebitable: false});\n    }\n    transaction = new Transaction().add({\n      keys,\n      controllerId: this.controllerId,\n      data,\n    });\n    await launchThenAcknowledgeTx(\n      this.connection,\n      transaction,\n      ownerAccount,\n      assetAccount,\n    );\n    return assetAccount.pubKey;\n  }\n\n  /**\n   * Retrieve asset information\n   */\n  async fetchAssetDetail(): Promise<AssetDetail> {\n    const fetchAccountDetail = await this.connection.fetchAccountDetail(this.assetId);\n    if (!fetchAccountDetail.owner.equals(this.controllerId)) {\n      throw new Error(\n        `Invalid asset owner: ${JSON.stringify(fetchAccountDetail.owner)}`,\n      );\n    }\n\n    const data = Buffer.from(fetchAccountDetail.data);\n\n    if (data.readUInt8(0) !== 1) {\n      throw new Error(`Invalid asset data`);\n    }\n    const fetchTokenDetail = AssetDetailLayout.decode(data, 1);\n    fetchTokenDetail.totalSupply = AssetCount.createFromBuffer(fetchTokenDetail.totalSupply);\n    return fetchTokenDetail;\n  }\n\n  /**\n   * Retrieve account information\n   *\n   * @param account Public key of the asset account\n   */\n  async fetchAccountDetail(account: PubKey): Promise<AssetAccountDetail> {\n    const fetchAccountDetail = await this.connection.fetchAccountDetail(account);\n    if (!fetchAccountDetail.owner.equals(this.controllerId)) {\n      throw new Error(`Invalid asset account owner`);\n    }\n\n    const data = Buffer.from(fetchAccountDetail.data);\n    if (data.readUInt8(0) !== 2) {\n      throw new Error(`Invalid asset account data`);\n    }\n    const tokenAccountInfo = TokenAccountDetailLayout.decode(data, 1);\n\n    tokenAccountInfo.publickeyOfAsset = new PubKey(tokenAccountInfo.publickeyOfAsset);\n    tokenAccountInfo.publickeyOfOwner = new PubKey(tokenAccountInfo.publickeyOfOwner);\n    tokenAccountInfo.amountOfAsset = AssetCount.createFromBuffer(tokenAccountInfo.amountOfAsset);\n    if (tokenAccountInfo.sourceOption === 0) {\n      tokenAccountInfo.publickeyOfSourceAccount = null;\n      tokenAccountInfo.originalAmountOfAsset = new AssetCount();\n    } else {\n      tokenAccountInfo.publickeyOfSourceAccount = new PubKey(tokenAccountInfo.publickeyOfSourceAccount);\n      tokenAccountInfo.originalAmountOfAsset = AssetCount.createFromBuffer(\n        tokenAccountInfo.originalAmountOfAsset,\n      );\n    }\n\n    if (!tokenAccountInfo.publickeyOfAsset.equals(this.assetId)) {\n      throw new Error(\n        `Invalid asset account bvmaddr: ${JSON.stringify(\n          tokenAccountInfo.publickeyOfAsset,\n        )} !== ${JSON.stringify(this.assetId)}`,\n      );\n    }\n    return tokenAccountInfo;\n  }\n\n  /**\n   * Transfer tokens to another account\n   *\n   * @param owner Owner of the source asset account\n   * @param source Source asset account\n   * @param destination Destination asset account\n   * @param amount Number of tokens to transfer\n   */\n  async transferAsset(\n    owner: BusAccount,\n    source: PubKey,\n    destination: PubKey,\n    amount: number | AssetCount,\n  ): Promise<?TxnSignature> {\n    return await launchThenAcknowledgeTx(\n      this.connection,\n      new Transaction().add(\n        await this.transferOperation(\n          owner.pubKey,\n          source,\n          destination,\n          amount,\n        ),\n      ),\n      owner,\n    );\n  }\n\n  /**\n   * Grant a third-party permission to transfer up the specified number of tokens from an account\n   *\n   * @param owner Owner of the source asset account\n   * @param account Public key of the asset account\n   * @param delegate Token account authorized to perform a transfer tokens from the source account\n   * @param amount Maximum number of tokens the delegate may transfer\n   */\n  async approve(\n    owner: BusAccount,\n    account: PubKey,\n    delegate: PubKey,\n    amount: number | AssetCount,\n  ): Promise<void> {\n    await launchThenAcknowledgeTx(\n      this.connection,\n      new Transaction().add(\n        this.approveOperation(owner.pubKey, account, delegate, amount),\n      ),\n      owner,\n    );\n  }\n\n  /**\n   * Remove approval for the transfer of any remaining tokens\n   *\n   * @param owner Owner of the source asset account\n   * @param account Public key of the asset account\n   * @param delegate Token account to revoke authorization from\n   */\n  revoke(\n    owner: BusAccount,\n    account: PubKey,\n    delegate: PubKey,\n  ): Promise<void> {\n    return this.approve(owner, account, delegate, 0);\n  }\n\n  /**\n   * Assign a new owner to the account\n   *\n   * @param owner Owner of the asset account\n   * @param account Public key of the asset account\n   * @param newOwner New owner of the asset account\n   */\n  async setOwner(\n    owner: BusAccount,\n    account: PubKey,\n    newOwner: PubKey,\n  ): Promise<void> {\n    await launchThenAcknowledgeTx(\n      this.connection,\n      new Transaction().add(\n        this.setOwnerOperation(owner.pubKey, account, newOwner),\n      ),\n      owner,\n    );\n  }\n\n  /**\n   * Construct a Transfer instruction\n   *\n   * @param owner Owner of the source asset account\n   * @param source Source asset account\n   * @param destination Destination asset account\n   * @param amount Number of tokens to transfer\n   */\n  async transferOperation(\n    owner: PubKey,\n    source: PubKey,\n    destination: PubKey,\n    amount: number | AssetCount,\n  ): Promise<TxOperation> {\n    const fetchAccountDetail = await this.fetchAccountDetail(source);\n    if (!owner.equals(fetchAccountDetail.publickeyOfOwner)) {\n      throw new Error('BusAccount owner mismatch');\n    }\n\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      Layout.uint64('amount'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 2, // Transfer instruction\n        amount: new AssetCount(amount).convertToBuffer(),\n      },\n      data,\n    );\n\n    const keys = [\n      {pubkey: owner, isSigner: true, isDebitable: false},\n      {pubkey: source, isSigner: false, isDebitable: true},\n      {pubkey: destination, isSigner: false, isDebitable: true},\n    ];\n    if (fetchAccountDetail.publickeyOfSourceAccount) {\n      keys.push({\n        pubkey: fetchAccountDetail.publickeyOfSourceAccount,\n        isSigner: false,\n        isDebitable: true,\n      });\n    }\n    return new TxOperation({\n      keys,\n      controllerId: this.controllerId,\n      data,\n    });\n  }\n\n  /**\n   * Construct an Approve instruction\n   *\n   * @param owner Owner of the source asset account\n   * @param account Public key of the asset account\n   * @param delegate Token account authorized to perform a transfer tokens from the source account\n   * @param amount Maximum number of tokens the delegate may transfer\n   */\n  approveOperation(\n    owner: PubKey,\n    account: PubKey,\n    delegate: PubKey,\n    amount: number | AssetCount,\n  ): TxOperation {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      Layout.uint64('amount'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 3, // Approve instruction\n        amount: new AssetCount(amount).convertToBuffer(),\n      },\n      data,\n    );\n\n    return new TxOperation({\n      keys: [\n        {pubkey: owner, isSigner: true, isDebitable: false},\n        {pubkey: account, isSigner: false, isDebitable: true},\n        {pubkey: delegate, isSigner: false, isDebitable: true},\n      ],\n      controllerId: this.controllerId,\n      data,\n    });\n  }\n\n  /**\n   * Construct an Revoke instruction\n   *\n   * @param owner Owner of the source asset account\n   * @param account Public key of the asset account\n   * @param delegate Token account authorized to perform a transfer tokens from the source account\n   */\n  revokeOperation(\n    owner: PubKey,\n    account: PubKey,\n    delegate: PubKey,\n  ): TxOperation {\n    return this.approveOperation(owner, account, delegate, 0);\n  }\n\n  /**\n   * Construct a SetOwner instruction\n   *\n   * @param owner Owner of the asset account\n   * @param account Public key of the asset account\n   * @param newOwner New owner of the asset account\n   */\n  setOwnerOperation(\n    owner: PubKey,\n    account: PubKey,\n    newOwner: PubKey,\n  ): TxOperation {\n    const dataLayout = BufferLayout.struct([BufferLayout.u32('instruction')]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 4, // SetOwner instruction\n      },\n      data,\n    );\n\n    return new TxOperation({\n      keys: [\n        {pubkey: owner, isSigner: true, isDebitable: false},\n        {pubkey: account, isSigner: false, isDebitable: true},\n        {pubkey: newOwner, isSigner: false, isDebitable: true},\n      ],\n      controllerId: this.controllerId,\n      data,\n    });\n  }\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////\nasync function modify_callFun_uint(call, unum_diff){\n  var callFun_set = new Set();\n  // it returns a set of parameter list, because unum_diff can change many parameters\n  var parameters_set = await modify_callInput_uint(call, unum_diff);\n  for(var parameters of parameters_set){\n    var callFun = {\n      from: call.from,\n      to: call.to,\n      abi: call.abi,\n      gas: call.gas,\n      param: parameters\n    };\n    callFun_set.add(callFun);\n  }\n  return callFun_set;\n}\n\nasync function modify_callFun_uint_meaningful(call, unum_diff){\n  // it returns a set of parameter list, because unum_diff can change many parameters\n  var modify_result = await modify_callInput_uint_meaningful(call, unum_diff);\n  if(modify_result[0]){\n    var callFun = {\n      from: call.from,\n      to: call.to,\n      abi: call.abi,\n      gas: call.gas,\n      param: modify_result[1]\n    };  \n    return [true, callFun];\n  }\n  else{\n    return [false, undefined];\n  }\n}\n\nasync function modify_callFun_gas_meaningful(call, gas_diff){\n  // it returns a set of parameter list, because unum_diff can change many parameters\n  var modify_result = await modify_callGas_meaningful(call, gas_diff);\n  if(modify_result[0]){\n    var callFun = {\n      from: call.from,\n      to: call.to,\n      abi: call.abi,\n      gas: modify_result[1],\n      param: call.param\n    };  \n    return [true, callFun];\n  }\n  else{\n    return false;\n  }\n\n}\n\n/// mutate the gas, and generate a list of callsequence\n/// gas does not need BigInt\nasync function mutate_gas(call, callSequence, index){\n  var gas_sequence_list = [];\n  var gas_diff = parseInt(call.gas, 10) - gasMin;\n  var gas_neighbor_index = 0;\n  var gas_neighbor_len = gas_neighbor.length;\n  while(gas_neighbor_index <= gas_neighbor_len){\n    var gas_min, gas_max;\n    if(gas_neighbor_index == 0){\n      gas_min = gasMin;\n    }\n    else{\n      var times = parseFloat(gas_neighbor[gas_neighbor_index -1], 10);\n      gas_min = Math.ceil(gasMin + gas_diff*times);\n    }\n    if(gas_neighbor_index == gas_neighbor_len){\n      gas_max = gasMax;\n    }\n    else{\n      var times = parseFloat(gas_neighbor[gas_neighbor_index], 10);\n      gas_max = Math.ceil(gasMin + gas_diff*times);\n    }\n    /// generate a new call function\n    var callFun = await modify_callFun_gas(call, gas_min, gas_max);\n    /// clone the call sequence\n    var gas_sequence = callSequence.slice();\n    /// replace the given function\n    gas_sequence[index] = callFun;\n    gas_sequence_list.push(gas_sequence);\n    gas_neighbor_index += 1;\n  }\n  return gas_sequence_list;\n}\n\n/// mutate the uint based on previous balances\n/// 'exec_results' is the result of 'call'\nasync function mutate_balance(call, callSequence, index){\n  var bal_sequence_list = [];\n  var exec_index = 0;\n  var exec_len = exec_results.length;\n  while(exec_index <= exec_len){\n    var unum_min, unum_max;\n    if(exec_index == 0){\n      unum_min = 0;\n    }\n    else{\n      unum_min = parseInt(exec_results[exec_index -1]);\n    }\n    if(exec_index == 8){\n      unum_max = undefined;\n    }\n    else{\n      unum_max = parseInt(exec_results[exec_index]);\n    }      \n    /// generate the new calls and execute them\n    var callFun = await modify_callFun_bal_range(call, unum_min, unum_max);\n    if(callFun !== undefined){\n      /// clone the call sequence\n      var bal_sequence = callSequence.slice();\n      /// replace the given function\n      bal_sequence[index] = callFun;\n      bal_sequence_list.push(bal_sequence);\n    }\n    callFun = await modify_callFun_bal_single(call, unum_max);\n    if(callFun !== undefined){\n      /// clone the call sequence\n      var bal_sequence = callSequence.slice();\n      /// replace the given function\n      bal_sequence[index] = callFun;\n      bal_sequence_list.push(bal_sequence);\n    }\n    exec_index += 1;\n  }\n  return bal_sequence_list;  \n}\n\nasync function mutate_uint(call, callSequence, index){\n  var uint_sequence_list = [];\n  var uint_neighbor_index = 0;\n  var uint_neighbor_len = uint_neighbor.length;\n  while(uint_neighbor_index <= uint_neighbor_len){\n    /// unum_diff is not handled here, because it is relevant to multiple parameters\n    /// generate a new call function\n    var unum_diff = uint_neighbor[uint_neighbor_index];\n    var callFun_set = await modify_callFun_uint(call, unum_diff);\n    for(var callFun of callFun_set){\n      /// clone the call sequence\n      var uint_sequence = callSequence.slice();\n      /// replace the given function\n      uint_sequence[index] = callFun;\n      uint_sequence_list.push(uint_sequence);     \n    }\n    uint_neighbor_index += 1;\n  }\n  return uint_sequence_list;\n}\n//////////////////////////////////////////////////////////////////////////////////////////////","// @flow\n\nimport {Connection} from '../netutility';\nimport {dormant} from './dormant';\nimport type {TxnSignature} from '../tx-dapp';\nimport {DEFAULT_TICKS_PER_SLOT, NUM_TICKS_PER_SEC} from '../timing';\n\n\nconst fs = require('fs');\nvar debug = true;\n\nfunction setDebug(value) { debug = value; }\nfunction getDebug() { return debug; }\nfunction cLog(value) { if (debug) console.log(value); }\nfunction testLog(value) { console.log(value); }\nfunction mkdir(path) {\n  try {\n    fs.mkdirSync(path);\n  } catch(e) {\n    if ( e.code != 'EEXIST' ) throw e;\n  }\n }\n\nfunction rmdir(path) {\n  if( fs.existsSync(path) ) {\n    fs.readdirSync(path).forEach(function(file,index){\n      var curPath = path + \"/\" + file;\n      if(fs.lstatSync(curPath).isDirectory()) { // recurse\n        rmdir(curPath);\n      } else { // delete file\n        fs.unlinkSync(curPath);\n      }\n    });\n    fs.rmdirSync(path);\n  }\n }\n\nfunction fileExists(path)\n {\n    if(fs.existsSync(path))\n\treturn true;\n    return false;\n }\n\nfunction readFile(path, callback, cb) {\n    fs.readFile(path, 'utf8',  (err, data) => { callback (err, data, cb) });\n }\n\nfunction writeFile(path, data) {\n   fs.writeFile(path, data, (err) => { if (err) throw err;});\n }\n\nfunction listFiles(dir, recursive = false) {\n\n    var results = [];\n    fs.readdirSync(dir).forEach(function(file) {\n        file = dir+'/'+file;\n        var stat = fs.statSync(file);\n\n        if (stat && stat.isDirectory() && recursive) {\n            results = results.concat(listFiles(file, recursive))\n        } else results.push(file);\n    });\n\n    return results;\n }\n\nfunction listFolders(dir) {\n\n    var results = [];\n    fs.readdirSync(dir).forEach(function(file) {\n        file = dir+'/'+file;\n        var stat = fs.statSync(file);\n\n        if (stat && stat.isDirectory()) {\n            results.push(file);\n        }\n    });\n\n    return results;\n }\n\n\n\n\n/**\n * send transaction to the network\n * get transaction's status by signature\n */\nexport async function launchThenAcknowledgeNativeTxn(\n  connection: Connection,\n  originalTransaction: Buffer,\n): Promise<TxnSignature> {\n  const start_time = Date.now();\n  let tx_signature = await connection.sendNativeTxn(originalTransaction);\n\n  // Wait up to a couple slots for a confirmation\n  let tx_status = null;\n  let failed_status_retries = 6;\n  for (;;) {\n    tx_status = await connection.fetchSignatureState(tx_signature);\n    if (tx_status) {\n      break;\n    }\n\n    // dormant for 500 leader rotation duration\n    await dormant((500 * DEFAULT_TICKS_PER_SLOT) / NUM_TICKS_PER_SEC);\n\n    if (--failed_status_retries <= 0) {\n      const duration = (Date.now() - start_time) / 1000;\n      throw new Error(\n        `Raw Transaction '${tx_signature}' was not confirmed in ${duration.toFixed(\n          2,\n        )} seconds (${JSON.stringify(tx_status)})`,\n      );\n    }\n  }\n\n  if (tx_status && 'Ok' in tx_status) {\n    return tx_signature;\n  }\n\n  throw new Error(\n    `Raw transaction ${tx_signature} failed (${JSON.stringify(tx_status)})`,\n  );\n}\n\n\nvar lastResponse;\nvar nodes = {};\n\n\nfunction startNode (nodeExec, dataDir, genesisPath, listeningPort, finished) \n{\n  var utils = require('./utils.js');\n  var spawn = require('child_process').spawn\n  var options = [\n    '--private', 'privatechain',\n    '-d', dataDir,\n    '--config', genesisPath,\n    '--ipcpath', dataDir + '/geth.ipc',\n    '--ipc',\n    '--listen', listeningPort,\n    '--test',\n    '-a', '0x1122334455667788991011121314151617181920'\n  ]\n  utils.cLog('starting node')\n  utils.cLog(nodeExec + ' ' + options.join(' '))\n  var node = spawn(nodeExec, options)\n  node.stdout.on('data', (data) => {\n    utils.cLog(`stdout: ${data}`)\n  })\n  node.stderr.on('data', (data) => {\n    utils.cLog(`stderr: ${data}`)\n  })\n  node.on('close', (code) => {\n    utils.cLog(`child process exited with code ${code}`)\n  })\n\n  nodes[dataDir] = node;\n  utils.sleep(14000).then(() => {\n\tutils.cLog(\"Node Started\");\n\tfinished();\n  });\n}\n\nfunction stopNode(dataDir, finished)\n{\n  nodes[dataDir].kill();\n  var utils = require('./utils.js');\n  utils.sleep(1000).then(() => {\n\tfinished();\n  });\n}\n\n\nfunction runScriptOnNode(dataDir, jsScript, args, finished)\n{\n\tvar utils = require('./utils.js');\n\tvar ipcPath = dataDir + '/geth.ipc';\n\n\tvar Web3 = require('web3');\n\tvar web3admin = require('./web3Admin.js');\n\tvar net = require('net');\n\n\tutils.cLog(\"Connecting to node at \" + ipcPath);\n\tvar web3 = new Web3(new Web3.providers.IpcProvider(ipcPath, net));\n\tweb3admin.extend(web3);\n\tglobal.web3 = web3;\n\n\tvar onScriptCallback = function (err, data)\n\t{\n\t\tutils.cLog(data);\n\t\tlastResponse = data;\n\t\tfinished();\n\t}\n\tglobal.callback = onScriptCallback;\n\tglobal.args = args;\n\n\tvar vm = require('vm');\n\tutils.cLog(\"Executing \" + jsScript + \" ...\");\n\tfs.readFile(jsScript, 'utf8', function (err, data)\n\t{\n\t\tif (err)\n\t\t{\n\t\t\tutils.cLog(err);\n\t\t\tfinished();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar script = new vm.Script(data);\n\t\t\tscript.runInThisContext();\n\t\t}\n\t});\n}\n\n\nfunction getLastResponse() \n{\n\treturn lastResponse;\n}\n","//@flow\n\nimport {testnetDefaultChannel} from '../../package.json';\n\n\n// defines P2PKH and P2SH address types for standard (prod) and testnet networks\nvar CURRENCIES = [{\n    name: 'bitcoin',\n    symbol: 'btc',\n    addressTypes: {prod: ['00', '05'], testnet: ['6f', 'c4']}\n},{\n    name: 'bitcoincash',\n    symbol: 'bch',\n    addressTypes: {prod: ['00', '05'], testnet: ['6f', 'c4']}\n},{\n    name: 'litecoin',\n    symbol: 'ltc',\n    addressTypes: {prod: ['30', '05', '32'], testnet: ['6f', 'c4']}\n},{\n    name: 'peercoin',\n    symbol: 'ppc',\n    addressTypes: {prod: ['37', '75'], testnet: ['6f', 'c4']}\n},{\n    name: 'dogecoin',\n    symbol: 'doge',\n    addressTypes: {prod: ['1e', '16'], testnet: ['71', 'c4']}\n},{\n    name: 'beavercoin',\n    symbol: 'bvc',\n    addressTypes: {prod: ['19', '05'], testnet: ['6f', 'c4']}\n},{\n    name: 'freicoin',\n    symbol: 'frc',\n    addressTypes: {prod: ['00', '05'], testnet: ['6f', 'c4']}\n},{\n    name: 'protoshares',\n    symbol: 'pts',\n    addressTypes: {prod: ['38', '05'], testnet: ['6f', 'c4']}\n},{\n    name: 'megacoin',\n    symbol: 'mec',\n    addressTypes: {prod: ['32', '05'], testnet: ['6f', 'c4']}\n},{\n    name: 'primecoin',\n    symbol: 'xpm',\n    addressTypes: {prod: ['17', '53'], testnet: ['6f', 'c4']}\n},{\n    name: 'auroracoin',\n    symbol: 'aur',\n    addressTypes: {prod: ['17', '05'], testnet: ['6f', 'c4']}\n},{\n    name: 'namecoin',\n    symbol: 'nmc',\n    addressTypes: {prod: ['34'], testnet: []}\n},{\n    name: 'biocoin',\n    symbol: 'bio',\n    addressTypes: {prod: ['19', '14'], testnet: ['6f', 'c4']}\n},{\n    name: 'garlicoin',\n    symbol: 'grlc',\n    addressTypes: {prod: ['26', '05'], testnet: ['6f', 'c4']}\n},{\n    name: 'vertcoin',\n    symbol: 'vtc',\n    addressTypes: {prod: ['0x', '47'], testnet: ['6f', 'c4']}\n},{\n    name: 'bitcoingold',\n    symbol: 'btg',\n    addressTypes: {prod: ['26', '17'], testnet: ['6f', 'c4']}\n},{\n    name: 'komodo',\n    symbol: 'kmd',\n    addressTypes: {prod: ['3c', '55'], testnet: ['0','5']}\n},{\n    name: 'bitcoinz',\n    symbol: 'btcz',\n    expectedLength: 26,\n    addressTypes: {prod: ['1cb8','1cbd'], testnet: ['1d25', '1cba']}\n},{\n    name: 'bitcoinprivate',\n    symbol: 'btcp',\n    expectedLength: 26,\n    addressTypes: {prod: ['1325','13af'], testnet: ['1957', '19e0']}\n},{\n    name: 'hush',\n    symbol: 'hush',\n    expectedLength: 26,\n    addressTypes: {prod: ['1cb8','1cbd'], testnet: ['1d25', '1cba']}\n},{\n    name: 'snowgem',\n    symbol: 'sng',\n    expectedLength: 26,\n    addressTypes: {prod: ['1c28','1c2d'], testnet: ['1d25', '1cba']}\n},{\n    name: 'zcash',\n    symbol: 'zec',\n    expectedLength: 26,\n    addressTypes: {prod: ['1cb8','1cbd'], testnet: ['1d25', '1cba']}\n},{\n    name: 'zclassic',\n    symbol: 'zcl',\n    expectedLength: 26,\n    addressTypes: {prod: ['1cb8','1cbd'], testnet: ['1d25', '1cba']}\n},{\n    name: 'zencash',\n    symbol: 'zen',\n    expectedLength: 26,\n    addressTypes: {prod: ['2089','2096'], testnet: ['2092','2098']}\n},{\n    name: 'votecoin',\n    symbol: 'vot',\n    expectedLength: 26,\n    addressTypes: {prod: ['1cb8','1cbd'], testnet: ['1d25', '1cba']}\n},{\n    name: 'decred',\n    symbol: 'dcr',\n    addressTypes: {prod: ['073f', '071a'], testnet: ['0f21', '0efc']},\n    hashFunction: 'blake256',\n    expectedLength: 26\n},{\n    name: 'cardano',\n    symbol: 'ada',\n    addressTypes: {prod: [], testnet: []},\n    hashFunction: 'blake224',\n},{\n    name: 'iota',\n    symbol: 'iota',\n    addressTypes: {prod: [], testnet: []},\n},{\n    name: 'nano',\n    symbol: 'nano',\n    addressTypes: {prod: [], testnet: []},\n},{\n    name: 'railblocks',\n    symbol: 'xrb',\n    addressTypes: {prod: [], testnet: []},\n},{\n    name: 'monero',\n    symbol: 'xmr',\n    addressTypes: {prod: [], testnet: []},\n},{\n    name: 'nem',\n    symbol: 'nem',\n    addressTypes: {prod: [], testnet: []},\n},{\n    name: 'digibyte',\n    symbol: 'dgb',\n    addressTypes: {prod: ['1e'], testnet: []},\n},{\n    name: 'ethereum',\n    symbol: 'eth',\n    validator: 'ETHValidator',\n},{\n    name: 'etherzero',\n    symbol: 'etz',\n    validator: 'ETHValidator',\n},{\n    name: 'ethereumclassic',\n    symbol: 'etc',\n    validator: 'ETHValidator',\n},{\n    name: 'callisto',\n    symbol: 'clo',\n    validator: 'ETHValidator',\n},{\n    name: 'icon',\n    symbol: 'icon',\n    validator: 'ETHValidator',\n},{\n    name: 'eos',\n    symbol: 'eos',\n    validator: 'ETHValidator',\n},{\n    name: 'qash',\n    symbol: 'qash',\n    validator: 'ETHValidator',\n},{\n    name: 'republic protocol',\n    symbol: 'ren',\n    validator: 'ETHValidator',\n},{\n    name: 'tronix',\n    symbol: 'trx',\n    validator: 'ETHValidator',\n},{\n    name: 'vechain',\n    symbol: 'vechain',\n    validator: 'ETHValidator',\n},{\n    name: 'ripple',\n    symbol: 'xrp',\n    validator: 'XRPValidator',\n},{\n    name: 'stellar lumens',\n    symbol: 'xlm',\n    addressTypes: {prod: ['1e'], testnet: []},\n},{\n    name: 'dash',\n    symbol: 'dash',\n    addressTypes: {prod: ['4c', '10'], testnet: ['8c', '13']}\n},{\n    name: 'neo',\n    symbol: 'neo',\n    addressTypes: {prod: ['17'], testnet: []}\n},{\n    name: 'neogas',\n    symbol: 'gas',\n    addressTypes: {prod: ['17'], testnet: []}\n},{\n    name: 'qtum',\n    symbol: 'qtum',\n    addressTypes: {prod: ['3a', '32'], testnet: ['6f', 'c4']}\n}];\n\n/**\n * @private\n */\nconst endpoint = {\n  edge: 'https://api.edge.testnet.bitconch.com',\n  beta: 'https://api.beta.testnet.bitconch.com',\n  stable: 'https://api.testnet.bitconch.com',\n};\n\n/**\n * Retrieves the RPC address for the specified testnet release\n * channel\n */\nexport function testnetChannelEndpoint(channel?: string): string {\n  if (!channel) {\n    return endpoint[testnetDefaultChannel];\n  }\n\n  if (endpoint[channel]) {\n    return endpoint[channel];\n  }\n  throw new Error(`Unknown channel: ${channel}`);\n}\n\n\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nvar ALPHABET_MAP = {};\nfor (var i = 0; i < ALPHABET.length; ++i) {\n    ALPHABET_MAP[ALPHABET.charAt(i)] = i;\n}\nvar BASE = ALPHABET.length;\n\nfunction decode(string) {\n  if (string.length === 0) return [];\n\n  var i, j, bytes = [0];\n  for (i = 0; i < string.length; ++i) {\n      var c = string[i];\n      if (!(c in ALPHABET_MAP)) throw new Error('Non-base58 character');\n\n      for (j = 0; j < bytes.length; ++j) bytes[j] *= BASE\n      bytes[0] += ALPHABET_MAP[c];\n\n      var carry = 0;\n      for (j = 0; j < bytes.length; ++j) {\n          bytes[j] += carry;\n          carry = bytes[j] >> 8;\n          bytes[j] &= 0xff\n      }\n\n      while (carry) {\n          bytes.push(carry & 0xff);\n          carry >>= 8;\n      }\n  }\n  // deal with leading zeros\n  for (i = 0; string[i] === '1' && i < string.length - 1; ++i){\n      bytes.push(0);\n  }\n\n  return bytes.reverse();\n}\n"," /// @flow\nexport {BusAccount} from './bvm-acct';\nexport {BpfControllerLoader} from './bvm-dapp-mounter';\nexport {BudgetController} from './bvm-script';\nexport {Connection} from './netutility';\nexport {ControllerLoader} from './dapp-mounter';\nexport {NativeControllerLoader} from './builtin-mounter';\nexport {PubKey} from './bvm-addr';\nexport {SystemController} from './sys-dapp';\nexport {Asset, AssetCount} from './asset-dapp';\nexport {Transaction, TxOperation} from './tx-dapp';\nexport {launchThenAcknowledgeTx} from './util/launch-then-acknowledge-tx';\nexport {\n  launchThenAcknowledgeNativeTxn,\n} from './util/launch-then-acknowledge-original-tx';\nexport {testnetChannelEndpoint} from './util/testnet';\nexport {RpcCall} from './rpc-call';\nexport {RpcParameter} from './rpc-parameter';\nexport {PreCondition} from './preconditions';"],"names":["request","require","AbiCoder","Web3","Promise","truffle_Contract","assert","fs","locks","mutex","createMutex","async","httpRpcAddr","Provider","providers","HttpProvider","web3","g_account_list","eth","accounts","g_from_account","setCharAt","str","index","chr","length","substr","transform","id","newStr","i","charAt","Error","reverse","originalStr","includes","replace","PubKey","value","startsWith","_bn","BN","substring","newstr","bs58","decode","byteLength","pubKey","eq","encode","toBuffer","b","toArrayLike","Buffer","zeroPad","alloc","copy","toBase58","o","BusAccount","privateKey","_keypair","nacl","sign","keyPair","fromSecretKey","publicKey","secretKey","NUM_TICKS_PER_SEC","DEFAULT_TICKS_PER_SLOT","property","BufferLayout","uint64","rustString","rsl","_decode","bind","_encode","buffer","offset","data","chars","toString","from","Object","defineProperty","exports","buffer_1","BufferUtil","source","match","map","x","parseInt","Uint8Array","ArrayBuffer","view","DataView","setUint8","charCodeAt","forEach","push","String","fromCharCode","join","sources","padStart","a","c","set","getDecodedArrayLength","bytes","len_to_return","size","elem_of_array","shift","encodeArrayWithInteger","len","new_len","new_elem","CollectionUtil","binarySearch","sortedArray","item","lowIdx","highIdx","midIdx","Math","floor","PACKET_DATA_SIZE","TxOperation","opts","assign","Transaction","signatures","signature","items","operations","concat","recentPackagehash","keys","numRequiredSignatures","numCreditOnlySignedAccounts","numCreditOnlyUnsignedAccounts","programIds","instruction","keySignerPair","keyStr","pubkey","isSigner","isDebitable","controllerId","keyCount","shortvec","keyIndicesCount","dataCount","programIdIndex","indexOf","keyIndices","keyObj","dataLength","invariant","keyIndex","instructionCount","instructionBuffer","instructionBufferLength","instructionLayout","slice","signDataLayout","Layout","transaction","key","signData","signPartial","partialSigners","accountOrPublicKey","_fetchSignData","detached","signer","findIndex","sigpair","equals","signatureCount","transactionLength","wireTransaction","PUBKEY_LENGTH","SIGNATURE_LENGTH","isCreditDebit","numKeys","byteArray","accountCount","account","programIndex","accountIndexCount","accountIndex","sigPubkeyPair","instructionData","j","some","dormant","ms","resolve","setTimeout","number_type","string_type","object_type","boolean_type","_types","NetworkError","msg","name","tls","net","uuidv4","events","createRpcReq","url","server","jayson","callback","options","method","body","headers","fetch","res","text","args","reject","err","response","ConfigurationError","TransactionError","PrecompiledError","CompileError","FetchBalanceRpcResult","struct","jsonrpc","literal","error","result","FetchReputationRpcResult","jsonRpcResult","resultDescription","jsonRpcVersion","union","AccountDetailResult","executable","owner","difs","reputations","fetchAccountDetailRpcResult","AccountNoticeResult","subscription","ControllerAccountDetailResult","ControllerAccountNoticeResult","path","childProcess","abi","ConfmTxnRpcResult","FetchRoundLeader","GetClusterNodes","list","gossip","tpu","rpc","GetClusterNodes_015","GetEpochVoteAccounts","votePubkey","nodePubkey","stake","commission","FetchSignatureStateRpcResult","Ok","Err","FetchTxnAmountRpcResult","GetTotalSupplyRpcResult","FetchRecentBlockhash","difsPerSignature","maxDifsPerSignature","minDifsPerSignature","targetDifsPerSignature","targetSignaturesPerSlot","GetRecentBlockhash_015","ReqDroneRpcResult","ReqReputationRpcResult","SendTxnRpcResult","secp256k1","keccak","rlp","coder","ethjsUtil","Connection","endpoint","urlParse","_rpcReq","href","_blockhashInfo","seconds","transactionSignatures","protocol","host","port","Number","_rpcWebSock","RpcWebSocketClient","urlFormat","autoconnect","max_reconnects","Infinity","on","_wsOnOpen","_wsOnErr","_wsOnClose","_wsOnAccountNotice","_wsOnProgramAccountNotification","unsafeRes","message","res_015","console","log","node","undefined","blockhash","feeCalculator","to","amount","signers","Date","getSeconds","_disableBlockhashCaching","attempts","startTime","now","fetchRecentBlockhash","serialize","sendNativeTxn","rawTransaction","_rpcWebSockConnected","_updateSubscriptions","code","accountKeys","_accountChangeSubscriptions","programKeys","_controllerAccountChangeSubscriptions","close","subscriptionId","connect","call","notification","sub","_accountChangeSubscriptionCounter","accountId","fetchAccountDetail","_controllerAccountChangeSubscriptionCounter","RpcParameter","type","attributes","_","isUndefined","isNull","param","encrypted","assocIndex","idIndex","reference","isRpcParameter","module","RpcCall","rpcName","params","create","arguments","isArray","toArray","isEmpty","isRpcCall","processParamList","rest","flattenAndRemoveNullishValues","paramList","filter","flatten","convertedParams","stringParam","isNumber","isString","_flattenAndRemoveNullishValues","_processParamList","util","_str","Socket","format","launchThenAcknowledgeTx","connection","failed_send_retries","start_time","sendTxn","tx_signature","tx_status","failed_status_retries","fetchSignatureState","duration","toFixed","JSON","stringify","random","SystemController","createNewAccount","space","dataLayout","span","add","ControllerLoader","payer","controller","chunkSize","array","transactions","all","type_number","type_string","type_object","type_boolean","BpfControllerLoader","elf","load","PreCondition","condition","argumentName","docsPath","argument","isBuffer","serializePayment","payment","toData","writeUInt32LE","serializeTime","when","iso","date","pad","number","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","write","serializeCond","BudgetController","pos","conditions","trimmedData","conditionData","paymentData","condition1","condition2","whenData","NativeControllerLoader","controllerName","AssetCount","zero_pad_array","new_buffer","AssetDetailLayout","TokenAccountDetailLayout","SYSTEM_TOKEN_CONTROLLER_ID","Asset","assetId","ownerAccount","bvmAddrOfSourceAccount","assetAccount","readUInt8","fetchTokenDetail","totalSupply","createFromBuffer","tokenAccountInfo","publickeyOfAsset","publickeyOfOwner","amountOfAsset","sourceOption","publickeyOfSourceAccount","originalAmountOfAsset","destination","transferOperation","delegate","approveOperation","approve","newOwner","setOwnerOperation","convertToBuffer","ownerOfAsset","assetName","assetSymbol","assetDecimals","asset","createNewAssetAccount","publickeyOfStoreAssetAccount","encodeLength","launchThenAcknowledgeNativeTxn","originalTransaction","edge","beta","stable","testnetChannelEndpoint","channel","testnetDefaultChannel"],"mappings":"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"}